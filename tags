!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
.DEFAULT_GOAL	Makefile	/^.DEFAULT_GOAL := commit-and-make$/;"	m
A	abstract-machine/apps/coremark/include/coremark.h	/^	MATDAT *A;$/;"	m	struct:MAT_PARAMS_S	access:public
A	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
A	abstract-machine/apps/microbench/src/fib/fib.c	/^static uint32_t *A, *ans, *T, *tmp;$/;"	v	file:
AEABI_RTABI	abstract-machine/libs/compiler-rt/int_lib.h	44;"	d
ALLMAKE	abstract-machine/Makefile	/^ALLMAKE = $(dir $(shell find . -mindepth 2 -name "Makefile"))$/;"	m
ALL_ALGORITHMS_MASK	abstract-machine/apps/coremark/include/coremark.h	87;"	d
ALWAYS_INLINE	abstract-machine/libs/compiler-rt/int_lib.h	47;"	d
ALWAYS_INLINE	abstract-machine/libs/compiler-rt/int_lib.h	52;"	d
AM_HOME	abstract-machine/Makefile	/^AM_HOME ?= $(shell pwd)$/;"	m
AM_HOME	amgame/Makefile	/^export AM_HOME := $(PWD)\/..\/abstract-machine$/;"	m
AM_SRCS	abstract-machine/am/arch/native.mk	/^AM_SRCS := native\/trm.c \\$/;"	m
AM_SRCS	abstract-machine/am/arch/x86-qemu.mk	/^AM_SRCS := x86\/qemu\/trm.c \\$/;"	m
ARCH	amgame/Makefile	/^export ARCH := x86-qemu$/;"	m
ARCH_H_PATH	abstract-machine/am/am.h	11;"	d
ARR_SIZE	abstract-machine/apps/microbench/src/bench.c	10;"	d	file:
ARR_SIZE	abstract-machine/apps/microbench/src/bf/bf.c	/^static int ARR_SIZE;$/;"	v	file:
ASSERT	abstract-machine/am/src/x86/qemu/devices/apic.c	21;"	d	file:
Accessed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Accessed;                           \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow	access:public
Active	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Active;                             \/\/ Set to true on Begin()$/;"	m	struct:ImGuiWindow	access:public
ActiveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiContext	access:public
ActiveIdAllowOverlap	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdAllowOverlap;               \/\/ Set only by active widget$/;"	m	struct:ImGuiContext	access:public
ActiveIdClickOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ActiveIdClickOffset;                \/\/ Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)$/;"	m	struct:ImGuiContext	access:public
ActiveIdIsAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdIsAlive;$/;"	m	struct:ImGuiContext	access:public
ActiveIdIsJustActivated	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiContext	access:public
ActiveIdPreviousFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiContext	access:public
ActiveIdWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiContext	access:public
Add	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& rhs)
Add	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& rhs)
AddBezierCurve	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0)
AddBezierCurve	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
AddCallback	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  \/\/ Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.$/;"	p	struct:ImDrawList	access:public	signature:(ImDrawCallback callback, void* callback_data)
AddCallback	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList	signature:(ImDrawCallback callback, void* callback_data)
AddCircle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f)
AddCircle	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
AddCircleFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
AddCircleFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
AddConvexPolyFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased)
AddConvexPolyFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)
AddDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddDrawCmd();                                               \/\/ This is useful if you need to forcefully create a new draw call (to allow for dependent rendering \/ blending). Otherwise primitives are merged into the same draw-call as much as possible$/;"	p	struct:ImDrawList	access:public	signature:()
AddDrawCmd	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList	signature:()
AddDrawListToRenderList	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list);$/;"	p	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)
AddDrawListToRenderList	abstract-machine/libs/imgui/src/imgui.cpp	/^static void AddDrawListToRenderList(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)$/;"	f	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImDrawList* draw_list)
AddEdge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  void AddEdge(int u, int v, int c) {$/;"	f	struct:Dinic	access:public	signature:(int u, int v, int c)
AddFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg)
AddFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg)
AddFontDefault	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg = NULL)
AddFontDefault	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg_template)
AddFontFromFileTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromFileTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddFontFromMemoryCompressedBase85TTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              \/\/ 'compressed_ttf_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 paramaeter$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryCompressedBase85TTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
AddFontFromMemoryCompressedTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);  \/\/ 'compressed_ttf_data' still owned by caller. Compress with binary_to_compressed_c.cpp$/;"	p	struct:ImFontAtlas	access:public	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryCompressedTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddFontFromMemoryTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);                                        \/\/ Transfer ownership of 'ttf_data' to ImFontAtlas, will be deleted after Build()$/;"	p	struct:ImFontAtlas	access:public	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
AddFontFromMemoryTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
AddImage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF)
AddImage	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
AddImageQuad	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF)
AddImageQuad	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
AddInputCharacter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void AddInputCharacter(ImWchar c);                        \/\/ Add new character into InputCharacters[]$/;"	p	struct:ImGuiIO	access:public	signature:(ImWchar c)
AddInputCharacter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiIO::AddInputCharacter(ImWchar c)$/;"	f	class:ImGuiIO	signature:(ImWchar c)
AddInputCharactersUTF8	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      \/\/ Add new characters into InputCharacters[] from an UTF-8 string$/;"	p	struct:ImGuiIO	access:public	signature:(const char* utf8_chars)
AddInputCharactersUTF8	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO	signature:(const char* utf8_chars)
AddLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f)
AddLine	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
AddPolyline	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased)
AddPolyline	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)
AddQuad	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f)
AddQuad	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
AddQuadFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
AddQuadFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
AddRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0, float thickness = 1.0f);   \/\/ a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0, float thickness = 1.0f)
AddRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
AddRectFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0);                     \/\/ a: upper-left, b: lower-right$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0)
AddRectFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
AddRectFilledMultiColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
AddRectFilledMultiColor	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
AddRemapChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); \/\/ Makes 'dst' character\/glyph points to 'src' character\/glyph. Currently needs to be called AFTER fonts have been built.$/;"	p	struct:ImFont	access:public	signature:(ImWchar dst, ImWchar src, bool overwrite_dst = true)
AddRemapChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)$/;"	f	class:ImFont	signature:(ImWchar dst, ImWchar src, bool overwrite_dst)
AddText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL)
AddText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL)
AddText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
AddText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
AddTriangle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f)
AddTriangle	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
AddTriangleFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
AddTriangleFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
AddWindowSettings	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiIniData*    AddWindowSettings(const char* name);$/;"	p	file:	signature:(const char* name)
AddWindowSettings	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiIniData* AddWindowSettings(const char* name)$/;"	f	file:	signature:(const char* name)
AddWindowToRenderList	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window);$/;"	p	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)
AddWindowToRenderList	abstract-machine/libs/imgui/src/imgui.cpp	/^static void AddWindowToRenderList(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)$/;"	f	file:	signature:(ImVector<ImDrawList*>& out_render_list, ImGuiWindow* window)
AddWindowToSortedBuffer	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window);$/;"	p	file:	signature:(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)
AddWindowToSortedBuffer	abstract-machine/libs/imgui/src/imgui.cpp	/^static void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)$/;"	f	file:	signature:(ImVector<ImGuiWindow*>& out_sorted_windows, ImGuiWindow* window)
AdvanceCursor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        AdvanceCursor;$/;"	m	struct:ImGuiGroupData	access:public
AlignFirstTextHeightToWidgets	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          AlignFirstTextHeightToWidgets();                                    \/\/ call once if the first item on the line is a Text() item and you want to vertically lower it to match subsequent (bigger) widgets$/;"	p	namespace:ImGui	signature:()
AlignFirstTextHeightToWidgets	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::AlignFirstTextHeightToWidgets()$/;"	f	class:ImGui	signature:()
AllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    AllowKeyboardFocus;     \/\/ == AllowKeyboardFocusStack.back() [empty == true]$/;"	m	struct:ImGuiDrawContext	access:public
AllowKeyboardFocusStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<bool>          AllowKeyboardFocusStack;$/;"	m	struct:ImGuiDrawContext	access:public
Alpha	abstract-machine/libs/imgui/include/imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in ImGui$/;"	m	struct:ImGuiStyle	access:public
AntiAliasedLines	abstract-machine/libs/imgui/include/imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle	access:public
AntiAliasedShapes	abstract-machine/libs/imgui/include/imgui.h	/^    bool        AntiAliasedShapes;          \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle	access:public
ApplySizeFullWithConstraint	abstract-machine/libs/imgui/src/imgui.cpp	/^static void ApplySizeFullWithConstraint(ImGuiWindow* window, ImVec2 new_size)$/;"	f	file:	signature:(ImGuiWindow* window, ImVec2 new_size)
Arr_1_Dim	abstract-machine/apps/dhrystone/dry.c	/^typedef int     Arr_1_Dim [50];$/;"	t	file:
Arr_1_Glob	abstract-machine/apps/dhrystone/dry.c	/^int             Arr_1_Glob [50];$/;"	v
Arr_2_Dim	abstract-machine/apps/dhrystone/dry.c	/^typedef int     Arr_2_Dim [50] [50];$/;"	t	file:
Arr_2_Glob	abstract-machine/apps/dhrystone/dry.c	/^int             Arr_2_Glob [50] [50];$/;"	v
Ascent	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Ascent, Descent;    \/\/              \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
AutoFitFramesX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	access:public
AutoFitFramesY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	access:public
AutoFitOnlyGrows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow	access:public
AutoPosLastDirection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoPosLastDirection;$/;"	m	struct:ImGuiWindow	access:public
B	abstract-machine/am/src/native/devices/video.c	/^static inline uint8_t B(uint32_t p) { return p; }$/;"	f	file:	signature:(uint32_t p)
B	abstract-machine/am/src/x86/qemu/devices/video.c	/^static uint8_t B(uint32_t p) { return p; }$/;"	f	file:	signature:(uint32_t p)
B	abstract-machine/apps/coremark/include/coremark.h	/^	MATDAT *B;$/;"	m	struct:MAT_PARAMS_S	access:public
B	abstract-machine/apps/litenes/include/common.h	/^static inline uint8_t B(uint32_t p) { return p; }$/;"	f	signature:(uint32_t p)
BCAST	abstract-machine/am/src/x86/qemu/devices/apic.c	24;"	d	file:
BENCHMARK_LIST	abstract-machine/apps/microbench/include/benchmark.h	54;"	d
BFS	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  bool BFS() {$/;"	f	struct:Dinic	access:public	signature:()
BF_LG	abstract-machine/apps/microbench/include/benchmark.h	38;"	d
BF_SM	abstract-machine/apps/microbench/include/benchmark.h	37;"	d
BUSY	abstract-machine/am/src/x86/qemu/devices/apic.c	25;"	d	file:
BackupActiveIdIsAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        BackupActiveIdIsAlive;$/;"	m	struct:ImGuiGroupData	access:public
BackupCurrentLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupCurrentLineHeight;$/;"	m	struct:ImGuiGroupData	access:public
BackupCurrentLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupCurrentLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData	access:public
BackupCursorMaxPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData	access:public
BackupCursorPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      BackupCursorPos;$/;"	m	struct:ImGuiGroupData	access:public
BackupFloat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon40	access:public
BackupGroupOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupGroupOffsetX;$/;"	m	struct:ImGuiGroupData	access:public
BackupIndentX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupIndentX;$/;"	m	struct:ImGuiGroupData	access:public
BackupInt	abstract-machine/libs/imgui/include/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon40	access:public
BackupLogLinePosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupLogLinePosY;$/;"	m	struct:ImGuiGroupData	access:public
BackupValue	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec4      BackupValue;$/;"	m	struct:ImGuiColMod	access:public
Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                                                   \/\/ push window to the stack and start appending to it. see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_open' creates a widget on the upper-right to close the window (which sets your bool to false).$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0)
Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0); \/\/ OBSOLETE. this is the older\/longer API. the extra parameters aren't very relevant. call SetNextWindowSize() instead if you want to set a window size. For regular windows, 'size_on_first_use' only applies to the first time EVER the window is created and probably not what you want! might obsolete this API eventually.$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0)
Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  \/\/ Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.$/;"	p	struct:ImGuiListClipper	access:public	signature:(int items_count, float items_height = -1.0f)
Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, ImGuiWindowFlags flags)
Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)
Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiListClipper::Begin(int count, float items_height)$/;"	f	class:ImGuiListClipper	signature:(int count, float items_height)
BeginChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            \/\/ "$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
BeginChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    \/\/ begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
BeginChild	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
BeginChild	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
BeginChildEx	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	file:	signature:(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
BeginChildFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);	\/\/ helper to create a child window \/ scrolling region that looks like a normal widget frame$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0)
BeginChildFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
BeginCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow	access:public
BeginGroup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BeginGroup();                                                       \/\/ lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)$/;"	p	namespace:ImGui	signature:()
BeginGroup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui	signature:()
BeginMainMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMainMenuBar();                                                 \/\/ create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
BeginMainMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui	signature:()
BeginMenu	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  \/\/ create a sub-menu entry. only call EndMenu() if this returns true!$/;"	p	namespace:ImGui	signature:(const char* label, bool enabled = true)
BeginMenu	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, bool enabled)
BeginMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMenuBar();                                                     \/\/ append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set). only call EndMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
BeginMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui	signature:()
BeginPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopup(const char* str_id);                                     \/\/ return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returned true!$/;"	p	namespace:ImGui	signature:(const char* str_id)
BeginPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
BeginPopupContextItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextItem(const char* str_id, int mouse_button = 1);                                        \/\/ helper to open and begin popup when clicked on last item. read comments in .cpp!$/;"	p	namespace:ImGui	signature:(const char* str_id, int mouse_button = 1)
BeginPopupContextItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
BeginPopupContextVoid	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 \/\/ helper to open and begin popup when clicked in void (no window).$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL, int mouse_button = 1)
BeginPopupContextVoid	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
BeginPopupContextWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextWindow(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1);  \/\/ helper to open and begin popup when clicked on current window.$/;"	p	namespace:ImGui	signature:(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1)
BeginPopupContextWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(bool also_over_items, const char* str_id, int mouse_button)
BeginPopupEx	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool             BeginPopupEx(const char* str_id, ImGuiWindowFlags extra_flags);$/;"	p	file:	signature:(const char* str_id, ImGuiWindowFlags extra_flags)
BeginPopupEx	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool BeginPopupEx(const char* str_id, ImGuiWindowFlags extra_flags)$/;"	f	file:	signature:(const char* str_id, ImGuiWindowFlags extra_flags)
BeginPopupModal	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0);               \/\/ modal dialog (block interactions behind the modal window, can't close the modal window by clicking outside)$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0)
BeginPopupModal	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)
BeginTooltip	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BeginTooltip();                                                     \/\/ use to create full-featured tooltip windows that aren't just text$/;"	p	namespace:ImGui	signature:()
BeginTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui	signature:()
Begin_Time	abstract-machine/apps/dhrystone/dry.c	/^long            Begin_Time,$/;"	v
Benchmark	abstract-machine/apps/microbench/include/benchmark.h	/^typedef struct Benchmark {$/;"	s
Benchmark	abstract-machine/apps/microbench/include/benchmark.h	/^} Benchmark;$/;"	t	typeref:struct:Benchmark
Benchmark::desc	abstract-machine/apps/microbench/include/benchmark.h	/^  const char *name, *desc;$/;"	m	struct:Benchmark	access:public
Benchmark::name	abstract-machine/apps/microbench/include/benchmark.h	/^  const char *name, *desc;$/;"	m	struct:Benchmark	access:public
Benchmark::prepare	abstract-machine/apps/microbench/include/benchmark.h	/^  void (*prepare)();$/;"	m	struct:Benchmark	access:public
Benchmark::run	abstract-machine/apps/microbench/include/benchmark.h	/^  void (*run)();$/;"	m	struct:Benchmark	access:public
Benchmark::settings	abstract-machine/apps/microbench/include/benchmark.h	/^  Setting settings[2];$/;"	m	struct:Benchmark	access:public
Benchmark::validate	abstract-machine/apps/microbench/include/benchmark.h	/^  int (*validate)();$/;"	m	struct:Benchmark	access:public
Bool_Glob	abstract-machine/apps/dhrystone/dry.c	/^Boolean         Bool_Glob;$/;"	v
Boolean	abstract-machine/apps/dhrystone/dry.c	/^typedef int     Boolean;$/;"	t	file:
BorderSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   BorderSize;$/;"	m	struct:ImGuiWindow	access:public
Buf	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer	access:public
Buf	abstract-machine/libs/imgui/include/imgui.h	/^    char*               Buf;            \/\/ Current text buffer                  \/\/ Read-write (pointed data only, can't replace the actual pointer)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Buf	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImGuiTextBuffer     Buf;$/;"	m	struct:ExampleAppLog	file:	access:public
BufDirty	abstract-machine/libs/imgui/include/imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf\/BufTextLen!!   \/\/ Write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
BufSize	abstract-machine/libs/imgui/include/imgui.h	/^    int                 BufSize;        \/\/ Maximum text length in bytes         \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
BufSizeA	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 BufSizeA;                   \/\/ end-user buffer size$/;"	m	struct:ImGuiTextEditState	access:public
BufTextLen	abstract-machine/libs/imgui/include/imgui.h	/^    int                 BufTextLen;     \/\/ Current text length in bytes         \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Build	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool              Build();            \/\/ Build pixels data. This is automatically for you by the GetTexData*** functions.$/;"	p	struct:ImFontAtlas	access:public	signature:()
Build	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      Build();$/;"	p	struct:ImGuiTextFilter	access:public	signature:()
Build	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter	signature:()
Build	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas	signature:()
BuildLookupTable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              BuildLookupTable();$/;"	p	struct:ImFont	access:public	signature:()
BuildLookupTable	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont	signature:()
Bullet	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Bullet();                                                               \/\/ draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses$/;"	p	namespace:ImGui	signature:()
Bullet	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui	signature:()
BulletText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
BulletTextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BulletTextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
BulletTextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
Button	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            \/\/ button$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
Button	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ButtonBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0)
ButtonBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)$/;"	f	class:ImGui	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
ButtonEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0)
ButtonEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
ButtonRepeat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ButtonRepeat;           \/\/ == ButtonRepeatStack.back() [empty == false]$/;"	m	struct:ImGuiDrawContext	access:public
ButtonRepeatStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<bool>          ButtonRepeatStack;$/;"	m	struct:ImGuiDrawContext	access:public
ButtonTextAlign	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ButtonTextAlign;            \/\/ Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.$/;"	m	struct:ImGuiStyle	access:public
C	abstract-machine/apps/coremark/include/coremark.h	/^	MATRES *C;$/;"	m	struct:MAT_PARAMS_S	access:public
CAST	abstract-machine/apps/microbench/src/lzip/quicklz.c	25;"	d	file:
CAST	abstract-machine/apps/microbench/src/lzip/quicklz.c	28;"	d	file:
CHARACTER_PER_SECOND	abstract-machine/apps/typing/game.h	6;"	d
CMOS_PORT	abstract-machine/am/src/x86/qemu/devices/apic.c	107;"	d	file:
CMOS_RETURN	abstract-machine/am/src/x86/qemu/devices/apic.c	108;"	d	file:
CODE	abstract-machine/apps/microbench/src/bf/bf.c	28;"	d	file:
COM1	abstract-machine/am/src/x86/qemu/trm.c	18;"	d	file:
COM2	abstract-machine/am/src/x86/qemu/trace.c	19;"	d	file:
COMMON_H	abstract-machine/apps/litenes/include/common.h	2;"	d
COMPILER_FLAGS	abstract-machine/apps/coremark/include/core_portme.h	66;"	d
COMPILER_RT_ABI	abstract-machine/libs/compiler-rt/int_lib.h	36;"	d
COMPILER_RT_ABI	abstract-machine/libs/compiler-rt/int_lib.h	38;"	d
COMPILER_RT_ABI	abstract-machine/libs/compiler-rt/int_lib.h	41;"	d
COMPILER_RT_ALIAS	abstract-machine/libs/compiler-rt/int_lib.h	26;"	d
COMPILER_RT_ALIAS	abstract-machine/libs/compiler-rt/int_lib.h	29;"	d
COMPILER_VERSION	abstract-machine/apps/coremark/include/core_portme.h	60;"	d
COMPILER_VERSION	abstract-machine/apps/coremark/include/core_portme.h	62;"	d
COMPILE_TIME_ASSERT	abstract-machine/libs/compiler-rt/int_util.h	28;"	d
COMPILE_TIME_ASSERT1	abstract-machine/libs/compiler-rt/int_util.h	29;"	d
COMPILE_TIME_ASSERT2	abstract-machine/libs/compiler-rt/int_util.h	30;"	d
COMPLEX_IMAGINARY	abstract-machine/libs/compiler-rt/int_types.h	152;"	d
COMPLEX_IMAGINARY	abstract-machine/libs/compiler-rt/int_types.h	161;"	d
COMPLEX_REAL	abstract-machine/libs/compiler-rt/int_types.h	151;"	d
COMPLEX_REAL	abstract-machine/libs/compiler-rt/int_types.h	160;"	d
CORETIMETYPE	abstract-machine/apps/coremark/src/core_portme.c	32;"	d	file:
CORE_EXPONENT	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_EXPONENT,$/;"	e	enum:CORE_STATE
CORE_FLOAT	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_FLOAT,$/;"	e	enum:CORE_STATE
CORE_INT	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_INT,$/;"	e	enum:CORE_STATE
CORE_INVALID	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_INVALID,$/;"	e	enum:CORE_STATE
CORE_PORTABLE_S	abstract-machine/apps/coremark/include/core_portme.h	/^typedef struct CORE_PORTABLE_S {$/;"	s
CORE_PORTABLE_S::portable_id	abstract-machine/apps/coremark/include/core_portme.h	/^	ee_u8	portable_id;$/;"	m	struct:CORE_PORTABLE_S	access:public
CORE_PORTME_H	abstract-machine/apps/coremark/include/core_portme.h	7;"	d
CORE_S1	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_S1,$/;"	e	enum:CORE_STATE
CORE_S2	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_S2,$/;"	e	enum:CORE_STATE
CORE_SCIENTIFIC	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_SCIENTIFIC,$/;"	e	enum:CORE_STATE
CORE_START	abstract-machine/apps/coremark/include/coremark.h	/^	CORE_START=0,$/;"	e	enum:CORE_STATE
CORE_STATE	abstract-machine/apps/coremark/include/coremark.h	/^typedef enum CORE_STATE {$/;"	g
CORE_TICKS	abstract-machine/apps/coremark/include/core_portme.h	/^typedef uint32_t CORE_TICKS;$/;"	t
CPU	abstract-machine/am/src/x86/x86-qemu.h	26;"	d
CPU_H	abstract-machine/apps/litenes/include/cpu.h	4;"	d
CPU_OP_BIS	abstract-machine/apps/litenes/src/cpu.c	380;"	d	file:
CPU_OP_EIS	abstract-machine/apps/litenes/src/cpu.c	396;"	d	file:
CPU_OP_NII	abstract-machine/apps/litenes/src/cpu.c	388;"	d	file:
CPU_RAM	abstract-machine/apps/litenes/include/cpu.h	/^extern byte CPU_RAM[0x8000];$/;"	x
CPU_RAM	abstract-machine/apps/litenes/src/cpu.c	/^byte CPU_RAM[0x8000];$/;"	v
CPU_STATE	abstract-machine/apps/litenes/include/cpu.h	/^} CPU_STATE;$/;"	t	typeref:struct:__anon5
CR0_PE	abstract-machine/am/include/x86.h	23;"	d
CR0_PE	abstract-machine/am/src/x86/qemu/boot/start.S	/^#define CR0_PE          0x00000001$/;"	d
CR0_PG	abstract-machine/am/include/x86.h	24;"	d
CRT_HAS_128BIT	abstract-machine/libs/compiler-rt/int_types.h	64;"	d
CTE_TRACE_FUNCS	abstract-machine/am/src/x86/qemu/trace.c	109;"	d	file:
CWORD_LEN	abstract-machine/apps/microbench/src/lzip/quicklz.c	21;"	d	file:
CalcExtraSpace	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       CalcExtraSpace(float avail_w);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(float avail_w)
CalcExtraSpace	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiSimpleColumns::CalcExtraSpace(float avail_w)$/;"	f	class:ImGuiSimpleColumns	signature:(float avail_w)
CalcFontSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
CalcItemRectClosestPoint	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   \/\/ utility to find the closest point the last item bounding rectangle edge. useful to visually link items$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, bool on_edge = false, float outward = +0.0f)
CalcItemRectClosestPoint	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)$/;"	f	class:ImGui	signature:(const ImVec2& pos, bool on_edge, float outward)
CalcItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);$/;"	p	namespace:ImGui	signature:(ImVec2 size, float default_x, float default_y)
CalcItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)$/;"	f	class:ImGui	signature:(ImVec2 size, float default_x, float default_y)
CalcItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         CalcItemWidth();                                                    \/\/ width of item given pushed settings and current cursor position$/;"	p	namespace:ImGui	signature:()
CalcItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui	signature:()
CalcListClipping	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    \/\/ calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.$/;"	p	namespace:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
CalcListClipping	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
CalcTextSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f)
CalcTextSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
CalcTextSizeA	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; \/\/ utf8$/;"	p	struct:ImFont	access:public	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const
CalcTextSizeA	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
CalcWordWrapPositionA	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;$/;"	p	struct:ImFont	access:public	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
CalcWordWrapPositionA	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
CalcWrapWidthForPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, float wrap_pos_x)
CalcWrapWidthForPos	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	class:ImGui	signature:(const ImVec2& pos, float wrap_pos_x)
Capacity	abstract-machine/libs/imgui/include/imgui.h	/^    int                         Capacity;$/;"	m	class:ImVector	access:public
Capital_Letter	abstract-machine/apps/dhrystone/dry.c	/^typedef char    Capital_Letter;$/;"	t	file:
CaptureKeyboardFromApp	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        \/\/ manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application handle). e.g. force capture keyboard when your widget is being hovered.$/;"	p	namespace:ImGui	signature:(bool capture = true)
CaptureKeyboardFromApp	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CaptureKeyboardFromApp(bool capture)$/;"	f	class:ImGui	signature:(bool capture)
CaptureKeyboardNextFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     CaptureKeyboardNextFrame;$/;"	m	struct:ImGuiContext	access:public
CaptureMouseFromApp	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           \/\/ manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application handle).$/;"	p	namespace:ImGui	signature:(bool capture = true)
CaptureMouseFromApp	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CaptureMouseFromApp(bool capture)$/;"	f	class:ImGui	signature:(bool capture)
CaptureMouseNextFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     CaptureMouseNextFrame;              \/\/ explicit capture via CaptureInputs() sets those flags$/;"	m	struct:ImGuiContext	access:public
Ch_1_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Ch_1_Comp;$/;"	m	struct:record::__anon12::__anon15	file:	access:public
Ch_1_Glob	abstract-machine/apps/dhrystone/dry.c	/^char            Ch_1_Glob,$/;"	v
Ch_1_Glob	abstract-machine/apps/dhrystone/dry.c	/^extern  char    Ch_1_Glob;$/;"	x
Ch_2_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Ch_2_Comp;$/;"	m	struct:record::__anon12::__anon15	file:	access:public
Ch_2_Glob	abstract-machine/apps/dhrystone/dry.c	/^                Ch_2_Glob;$/;"	v
ChannelsMerge	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsMerge();$/;"	p	struct:ImDrawList	access:public	signature:()
ChannelsMerge	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsMerge()$/;"	f	class:ImDrawList	signature:()
ChannelsSetCurrent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsSetCurrent(int channel_index);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_index)
ChannelsSetCurrent	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsSetCurrent(int idx)$/;"	f	class:ImDrawList	signature:(int idx)
ChannelsSplit	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsSplit(int channels_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channels_count)
ChannelsSplit	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsSplit(int channels_count)$/;"	f	class:ImDrawList	signature:(int channels_count)
CheckStacksSize	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             CheckStacksSize(ImGuiWindow* window, bool write);$/;"	p	file:	signature:(ImGuiWindow* window, bool write)
CheckStacksSize	abstract-machine/libs/imgui/src/imgui.cpp	/^static void CheckStacksSize(ImGuiWindow* window, bool write)$/;"	f	file:	signature:(ImGuiWindow* window, bool write)
Checkbox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Checkbox(const char* label, bool* v);$/;"	p	namespace:ImGui	signature:(const char* label, bool* v)
Checkbox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui	signature:(const char* label, bool* v)
CheckboxFlags	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);$/;"	p	namespace:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
CheckboxFlags	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ChildWindowComparer	abstract-machine/libs/imgui/src/imgui.cpp	/^static int ChildWindowComparer(const void* lhs, const void* rhs)$/;"	f	file:	signature:(const void* lhs, const void* rhs)
ChildWindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       ChildWindowRounding;        \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ChildWindows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiDrawContext	access:public
Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              Clear();                    \/\/ Clear all$/;"	p	struct:ImFontAtlas	access:public	signature:()
Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              Clear();$/;"	p	struct:ImFont	access:public	signature:()
Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      Clear();$/;"	p	struct:ImGuiStorage	access:public	signature:()
Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  Clear();$/;"	p	struct:ImDrawList	access:public	signature:()
Clear	abstract-machine/libs/imgui/include/imgui.h	/^    void                Clear() { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
Clear	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::Clear()$/;"	f	class:ImGuiStorage	signature:()
Clear	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Clear()     { Buf.clear(); LineOffsets.clear(); }$/;"	f	struct:ExampleAppLog	access:public	signature:()
Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFont::Clear()$/;"	f	class:ImFont	signature:()
Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas	signature:()
Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList	signature:()
ClearActiveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^	IMGUI_API void          ClearActiveID();$/;"	p	namespace:ImGui	signature:()
ClearActiveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ClearActiveID()$/;"	f	class:ImGui	signature:()
ClearFonts	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearFonts();               \/\/ Clear the ImGui-side font data (glyphs storage, UV coordinates)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ClearFonts	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas	signature:()
ClearFreeMemory	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ClearFreeMemory();$/;"	p	struct:ImDrawList	access:public	signature:()
ClearFreeMemory	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList	signature:()
ClearInputCharacters	abstract-machine/libs/imgui/include/imgui.h	/^    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   \/\/ Clear the text input buffer manually$/;"	f	struct:ImGuiIO	access:public	signature:()
ClearInputData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearInputData();           \/\/ Clear the input TTF data (inc sizes, glyph ranges)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ClearInputData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas	signature:()
ClearLog	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ClearSelection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ClearSetNextWindowData	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline void ClearSetNextWindowData()$/;"	f	file:	signature:()
ClearSetNextWindowData	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             ClearSetNextWindowData();$/;"	p	file:	signature:()
ClearTexData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearTexData();             \/\/ Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.$/;"	p	struct:ImFontAtlas	access:public	signature:()
ClearTexData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas	signature:()
Clip	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Clip(const ImRect& clip)        { if (Min.x < clip.Min.x) Min.x = clip.Min.x; if (Min.y < clip.Min.y) Min.y = clip.Min.y; if (Max.x > clip.Max.x) Max.x = clip.Max.x; if (Max.y > clip.Max.y) Max.y = clip.Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& clip)
ClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2)$/;"	m	struct:ImDrawCmd	access:public
ClipRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  ClipRect;                           \/\/ = DrawList->clip_rect_stack.back(). Scissoring \/ clipping rectangle. x1, y1, x2, y2.$/;"	m	struct:ImGuiWindow	access:public
ClipboardUserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*       ClipboardUserData;$/;"	m	struct:ImGuiIO	access:public
CloseButton	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& pos, float radius)
CloseButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& pos, float radius)
CloseCurrentPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CloseCurrentPopup();                                                \/\/ close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.$/;"	p	namespace:ImGui	signature:()
CloseCurrentPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui	signature:()
CloseInactivePopups	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             CloseInactivePopups();$/;"	p	file:	signature:()
CloseInactivePopups	abstract-machine/libs/imgui/src/imgui.cpp	/^static void CloseInactivePopups()$/;"	f	file:	signature:()
ClosePopup	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             ClosePopup(ImGuiID id);$/;"	p	file:	signature:(ImGuiID id)
ClosePopup	abstract-machine/libs/imgui/src/imgui.cpp	/^static void ClosePopup(ImGuiID id)$/;"	f	file:	signature:(ImGuiID id)
ClosePopupToLevel	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             ClosePopupToLevel(int remaining);$/;"	p	file:	signature:(int remaining)
ClosePopupToLevel	abstract-machine/libs/imgui/src/imgui.cpp	/^static void ClosePopupToLevel(int remaining)$/;"	f	file:	signature:(int remaining)
CmdBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Commands. Typically 1 command = 1 gpu draw call.$/;"	m	struct:ImDrawList	access:public
CmdBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;$/;"	m	struct:ImDrawChannel	access:public
CmdLists	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawList**    CmdLists;$/;"	m	struct:ImDrawData	access:public
CmdListsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             CmdListsCount;$/;"	m	struct:ImDrawData	access:public
Codepoint	abstract-machine/libs/imgui/include/imgui.h	/^        ImWchar                 Codepoint;$/;"	m	struct:ImFont::Glyph	access:public
Col	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColMod	access:public
Collapsed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow	access:public
Collapsed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Collapsed;$/;"	m	struct:ImGuiIniData	access:public
CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      \/\/ if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags = 0)
CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); \/\/ when 'p_open' isn't NULL, display an additional small close button on upper right of the header$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0)
CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1<<5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); } \/\/ OBSOLETE 1.49+$/;"	f	namespace:ImGui	signature:(const char* label, const char* str_id, bool framed = true, bool default_open = false)
CollapsingHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags)
CollapsingHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
ColorButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorButton(const ImVec4& col, bool small_height = false, bool outline_border = true);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, bool small_height = false, bool outline_border = true)
ColorButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)$/;"	f	class:ImGui	signature:(const ImVec4& col, bool small_height, bool outline_border)
ColorConvertFloat4ToU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);$/;"	p	namespace:ImGui	signature:(const ImVec4& in)
ColorConvertFloat4ToU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui	signature:(const ImVec4& in)
ColorConvertHSVtoRGB	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);$/;"	p	namespace:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ColorConvertHSVtoRGB	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ColorConvertRGBtoHSV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);$/;"	p	namespace:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ColorConvertRGBtoHSV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ColorConvertU32ToFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);$/;"	p	namespace:ImGui	signature:(ImU32 in)
ColorConvertU32ToFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)$/;"	f	class:ImGui	signature:(ImU32 in)
ColorEdit3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorEdit3(const char* label, float col[3]);                            \/\/ Hint: 'float col[3]' function argument is same as 'float* col'. You can pass address of first element out of a contiguous set, e.g. &myvector.x$/;"	p	namespace:ImGui	signature:(const char* label, float col[3])
ColorEdit3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3])$/;"	f	class:ImGui	signature:(const char* label, float col[3])
ColorEdit4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorEdit4(const char* label, float col[4], bool show_alpha = true);    \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, float col[4], bool show_alpha = true)
ColorEdit4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)$/;"	f	class:ImGui	signature:(const char* label, float col[4], bool alpha)
ColorEditMode	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorEditMode(ImGuiColorEditMode mode);                                 \/\/ FIXME-OBSOLETE: This is inconsistent with most of the API and will be obsoleted\/replaced.$/;"	p	namespace:ImGui	signature:(ImGuiColorEditMode mode)
ColorEditMode	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiColorEditMode      ColorEditMode;$/;"	m	struct:ImGuiDrawContext	access:public
ColorEditMode	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorEditMode(ImGuiColorEditMode mode)$/;"	f	class:ImGui	signature:(ImGuiColorEditMode mode)
ColorEditModeStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage            ColorEditModeStorage;               \/\/ Store user selection of color edit mode$/;"	m	struct:ImGuiContext	access:public
ColorModifiers	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiColMod>   ColorModifiers;                     \/\/ Stack for PushStyleColor()\/PopStyleColor()$/;"	m	struct:ImGuiContext	access:public
Colors	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle	access:public
Columns	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);  \/\/ setup number of columns. use an identifier to distinguish multiple column sets. close with Columns(1).$/;"	p	namespace:ImGui	signature:(int count = 1, const char* id = NULL, bool border = true)
Columns	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui	signature:(int columns_count, const char* id, bool border)
ColumnsCellMaxY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsCellMaxY;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsCellMinY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsCellMinY;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     ColumnsCount;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     ColumnsCurrent;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiColumnData> ColumnsData;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsMaxX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsMaxX;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsMinSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns$/;"	m	struct:ImGuiStyle	access:public
ColumnsMinX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsMinX;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsOffsetX;         \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsSetId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ColumnsSetId;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsShowBorders	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ColumnsShowBorders;$/;"	m	struct:ImGuiDrawContext	access:public
ColumnsStartPosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsStartPosY;$/;"	m	struct:ImGuiDrawContext	access:public
Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1)
Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1);      \/\/ separate items with \\0, end item-list with \\0\\0$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1)
Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items)
Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
Commands	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:	access:public
ConfigData	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontConfig*               ConfigData;         \/\/              \/\/ Pointer within ContainerAtlas->ConfigData$/;"	m	struct:ImFont	access:public
ConfigData	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas	access:public
ConfigDataCount	abstract-machine/libs/imgui/include/imgui.h	/^    short                       ConfigDataCount;    \/\/ ~ 1          \/\/ Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.$/;"	m	struct:ImFont	access:public
ContainerAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/              \/\/ What we has been loaded into$/;"	m	struct:ImFont	access:public
Contains	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
Contains	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& p) const
ContentsRegionRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  ContentsRegionRect;                 \/\/ Maximum visible content position in window coordinates. ~~ (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis$/;"	m	struct:ImGuiWindow	access:public
Count	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int         Count;$/;"	m	struct:ImGuiSimpleColumns	access:public
CountGrep	abstract-machine/libs/imgui/include/imgui.h	/^    int                 CountGrep;$/;"	m	struct:ImGuiTextFilter	access:public
CreateContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiContext* CreateContext(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL);$/;"	p	namespace:ImGui	signature:(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL)
CreateContext	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiContext* ImGui::CreateContext(void* (*malloc_fn)(size_t), void (*free_fn)(void*))$/;"	f	class:ImGui	signature:(void* (*malloc_fn)(size_t), void (*free_fn)(void*))
CreateNewWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow*     CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);$/;"	p	file:	signature:(const char* name, ImVec2 size, ImGuiWindowFlags flags)
CreateNewWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)$/;"	f	file:	signature:(const char* name, ImVec2 size, ImGuiWindowFlags flags)
CurLenA	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	access:public
CurLenW	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	access:public
CurrentLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   CurrentLineHeight;$/;"	m	struct:ImGuiDrawContext	access:public
CurrentLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   CurrentLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	access:public
CurrentPopupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiPopupRef> CurrentPopupStack;                  \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiContext	access:public
CurrentSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  CurrentSize;    \/\/ Read-only.	Current window size.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
CurrentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiContext	access:public
CurrentWindowStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiContext	access:public
CursorAnim	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float               CursorAnim;$/;"	m	struct:ImGuiTextEditState	access:public
CursorAnimReset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
CursorClamp	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
CursorFollow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                CursorFollow;$/;"	m	struct:ImGuiTextEditState	access:public
CursorMaxPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorMaxPos;           \/\/ Implicitly calculate the size of our contents, always extending. Saved into window->SizeContents at the end of the frame$/;"	m	struct:ImGuiDrawContext	access:public
CursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
CursorPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiDrawContext	access:public
CursorPosPrevLine	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiDrawContext	access:public
CursorStartPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorStartPos;$/;"	m	struct:ImGuiDrawContext	access:public
CurveTessellationTol	abstract-machine/libs/imgui/include/imgui.h	/^    float       CurveTessellationTol;       \/\/ Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.$/;"	m	struct:ImGuiStyle	access:public
DATA_SIZE	abstract-machine/apps/microbench/src/bf/bf.c	47;"	d	file:
DC	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDrawContext        DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame$/;"	m	struct:ImGuiWindow	access:public
DEASSERT	abstract-machine/am/src/x86/qemu/devices/apic.c	22;"	d	file:
DECL	abstract-machine/am/src/x86/qemu/trace.c	95;"	d	file:
DECL	abstract-machine/apps/microbench/include/benchmark.h	68;"	d
DEF	abstract-machine/am/src/x86/qemu/trace.c	98;"	d	file:
DEF_DEVOP	abstract-machine/am/src/x86/qemu/ioe.c	6;"	d	file:
DELIVS	abstract-machine/am/src/x86/qemu/devices/apic.c	20;"	d	file:
DEPS	Makefile	/^DEPS   := $(shell find . -maxdepth 1 -name "*.h") $(SRCS)$/;"	m
DFS	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int DFS(int x, int a) {$/;"	f	struct:Dinic	access:public	signature:(int x, int a)
DINIC_LG	abstract-machine/apps/microbench/include/benchmark.h	46;"	d
DINIC_SM	abstract-machine/apps/microbench/include/benchmark.h	45;"	d
DPL_KERN	abstract-machine/am/include/x86.h	5;"	d
DPL_USER	abstract-machine/am/include/x86.h	6;"	d
Data	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<Pair>      Data;$/;"	m	struct:ImGuiStorage	access:public
Data	abstract-machine/libs/imgui/include/imgui.h	/^    T*                          Data;$/;"	m	class:ImVector	access:public
DataTypeApplyOp	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* value1, const void* value2);$/;"	p	file:	signature:(ImGuiDataType data_type, int op, void* value1, const void* value2)
DataTypeApplyOp	abstract-machine/libs/imgui/src/imgui.cpp	/^static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* value1, const void* value2)\/\/ Store into value1$/;"	f	file:	signature:(ImGuiDataType data_type, int op, void* value1, const void* value2)
DataTypeApplyOpFromText	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format);$/;"	p	file:	signature:(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)
DataTypeApplyOpFromText	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)$/;"	f	file:	signature:(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)
DataTypeFormatString	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size);$/;"	p	file:	signature:(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)
DataTypeFormatString	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size);$/;"	p	file:	signature:(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)
DataTypeFormatString	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)$/;"	f	file:	signature:(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)
DataTypeFormatString	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)$/;"	f	file:	signature:(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)
Dcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef double _Complex Dcomplex;$/;"	t
Dcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { double real, imaginary; } Dcomplex;$/;"	t	typeref:struct:__anon29
DeIndexAllBuffers	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void DeIndexAllBuffers();               \/\/ For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!$/;"	p	struct:ImDrawData	access:public	signature:()
DeIndexAllBuffers	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData	signature:()
DeclColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       DeclColumns(float w0, float w1, float w2);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(float w0, float w1, float w2)
DeclColumns	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiSimpleColumns::DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	class:ImGuiSimpleColumns	signature:(float w0, float w1, float w2)
Decode85	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static void         Decode85(const unsigned char* src, unsigned char* dst)$/;"	f	file:	signature:(const unsigned char* src, unsigned char* dst)
Decode85Byte	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }$/;"	f	file:	signature:(char c)
DeleteChars	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void    DeleteChars(int pos, int bytes_count);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, int bytes_count)
DeleteChars	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, int bytes_count)
DeltaTime	abstract-machine/libs/imgui/include/imgui.h	/^    float         DeltaTime;                \/\/ = 1.0f\/60.0f         \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO	access:public
Descent	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Ascent, Descent;    \/\/              \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
DesiredSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  DesiredSize;    \/\/ Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
DestroyContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          DestroyContext(ImGuiContext* ctx);$/;"	p	namespace:ImGui	signature:(ImGuiContext* ctx)
DestroyContext	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::DestroyContext(ImGuiContext* ctx)$/;"	f	class:ImGui	signature:(ImGuiContext* ctx)
Dhrystones_Per_Second	abstract-machine/apps/dhrystone/dry.c	/^                Dhrystones_Per_Second;$/;"	v
Dinic	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^struct Dinic {$/;"	s	file:
Dinic::AddEdge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  void AddEdge(int u, int v, int c) {$/;"	f	struct:Dinic	access:public	signature:(int u, int v, int c)
Dinic::BFS	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  bool BFS() {$/;"	f	struct:Dinic	access:public	signature:()
Dinic::DFS	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int DFS(int x, int a) {$/;"	f	struct:Dinic	access:public	signature:(int x, int a)
Dinic::Maxflow	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int Maxflow(int s, int t) {$/;"	f	struct:Dinic	access:public	signature:(int s, int t)
Dinic::cur	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
Dinic::d	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
Dinic::edges	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge edges[MAXM];$/;"	m	struct:Dinic	file:	access:public
Dinic::head	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int head[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
Dinic::init	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  void init(int n) {$/;"	f	struct:Dinic	access:public	signature:(int n)
Dinic::m	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
Dinic::n	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
Dinic::nxt	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int nxt[MAXM];$/;"	m	struct:Dinic	file:	access:public
Dinic::queue	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
Dinic::s	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
Dinic::t	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
Dinic::vis	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  bool vis[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
Discr	abstract-machine/apps/dhrystone/dry.c	/^    Enumeration    Discr;$/;"	m	struct:record	file:	access:public
DisplayEnd	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
DisplayFramebufferScale	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayFramebufferScale;  \/\/ = (1.0f,1.0f)        \/\/ For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.$/;"	m	struct:ImGuiIO	access:public
DisplayOffset	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ = (0.f,1.f)  \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont	access:public
DisplaySafeAreaPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups\/tooltips as well regular windows.$/;"	m	struct:ImGuiStyle	access:public
DisplaySize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplaySize;              \/\/ <unset>              \/\/ Display size, in pixels. For clamping windows positions.$/;"	m	struct:ImGuiIO	access:public
DisplayStart	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
DisplayVisibleMax	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayVisibleMax;        \/\/ <unset> (0.0f,0.0f)  \/\/ If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize$/;"	m	struct:ImGuiIO	access:public
DisplayVisibleMin	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayVisibleMin;        \/\/ <unset> (0.0f,0.0f)  \/\/ If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin\/Max to the visible area.$/;"	m	struct:ImGuiIO	access:public
DisplayWindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.$/;"	m	struct:ImGuiStyle	access:public
Done	abstract-machine/apps/dhrystone/dry.c	/^Boolean		Done;$/;"	v
DragBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power);$/;"	p	namespace:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
DragBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)$/;"	f	class:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
DragCurrentValue	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragCurrentValue;                   \/\/ Currently dragged value, always float, not rounded by end-user precision settings$/;"	m	struct:ImGuiContext	access:public
DragFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
DragFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
DragFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
DragFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
DragFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
DragFloatRange2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , const char* display_format_max = NULL, float power = 1.0f)
DragFloatRange2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
DragInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
DragInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
DragInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
DragInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
DragInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
DragInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
DragInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
DragInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
DragIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
DragIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
DragIntRange2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = , const char* display_format_max = NULL)
DragIntRange2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)$/;"	f	class:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
DragLastMouseDelta	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  DragLastMouseDelta;$/;"	m	struct:ImGuiContext	access:public
DragSpeedDefaultRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedDefaultRatio;              \/\/ If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiContext	access:public
DragSpeedScaleFast	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedScaleFast;$/;"	m	struct:ImGuiContext	access:public
DragSpeedScaleSlow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedScaleSlow;$/;"	m	struct:ImGuiContext	access:public
Draw	abstract-machine/libs/imgui/include/imgui.h	/^    bool                Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    \/\/ Helper calling InputText+Build$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* label = , float width = 0.0f)
Draw	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter	signature:(const char* label, float width)
Draw	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open = NULL)$/;"	f	struct:ExampleAppLog	access:public	signature:(const char* title, bool* p_open = NULL)
Draw	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* title, bool* p_open)
DrawList	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawList*             DrawList;$/;"	m	struct:ImGuiWindow	access:public
DstFont	abstract-machine/libs/imgui/include/imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig	access:public
Dummy	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Dummy(const ImVec2& size);                                          \/\/ add a dummy item of given size$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
Dummy	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
EE_TICKS_PER_SEC	abstract-machine/apps/coremark/src/core_portme.c	37;"	d	file:
ELFHeader	abstract-machine/am/src/x86/qemu/boot/main.c	/^struct ELFHeader {$/;"	s	file:
ELFHeader::ehsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t ehsize;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::elf	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint8_t  elf[12];$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::entry	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t entry;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::flags	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t flags;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::machine	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t machine;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::magic	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t magic;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::phentsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t phentsize;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::phnum	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t phnum;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::phoff	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t phoff;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::shentsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shentsize;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::shnum	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shnum;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::shoff	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t shoff;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::shstrndx	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shstrndx;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::type	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t type;$/;"	m	struct:ELFHeader	file:	access:public
ELFHeader::version	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t version;$/;"	m	struct:ELFHeader	file:	access:public
ENABLE	abstract-machine/am/src/x86/qemu/devices/apic.c	15;"	d	file:
ENTRY	abstract-machine/apps/microbench/src/bench.c	15;"	d	file:
EOI	abstract-machine/am/src/x86/qemu/devices/apic.c	13;"	d	file:
ERR	abstract-machine/am/src/x86/qemu/cte_trap.S	/^#define ERR$/;"	d
ERROR	abstract-machine/am/src/x86/qemu/devices/apic.c	34;"	d	file:
ESR	abstract-machine/am/src/x86/qemu/devices/apic.c	16;"	d	file:
EV	abstract-machine/am/src/x86/qemu/trace.c	35;"	d	file:
EX_DF	abstract-machine/am/include/x86.h	66;"	d
EX_DIV	abstract-machine/am/include/x86.h	63;"	d
EX_GP	abstract-machine/am/include/x86.h	70;"	d
EX_MF	abstract-machine/am/include/x86.h	72;"	d
EX_NM	abstract-machine/am/include/x86.h	65;"	d
EX_NP	abstract-machine/am/include/x86.h	68;"	d
EX_PF	abstract-machine/am/include/x86.h	71;"	d
EX_SS	abstract-machine/am/include/x86.h	69;"	d
EX_SYSCALL	abstract-machine/am/include/x86.h	73;"	d
EX_TS	abstract-machine/am/include/x86.h	67;"	d
EX_UD	abstract-machine/am/include/x86.h	64;"	d
E_Comp_2	abstract-machine/apps/dhrystone/dry.c	/^                  Enumeration E_Comp_2;$/;"	m	struct:record::__anon12::__anon14	file:	access:public
Edge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge(){}$/;"	f	struct:Edge	access:public	signature:()
Edge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge(int from, int to, int cap, int flow) {$/;"	f	struct:Edge	access:public	signature:(int from, int to, int cap, int flow)
Edge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^struct Edge {$/;"	s	file:
Edge::Edge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge(){}$/;"	f	struct:Edge	access:public	signature:()
Edge::Edge	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge(int from, int to, int cap, int flow) {$/;"	f	struct:Edge	access:public	signature:(int from, int to, int cap, int flow)
Edge::cap	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
Edge::flow	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
Edge::from	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
Edge::to	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
ElemCount	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd	access:public
End	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          End();                                                                                                                      \/\/ finish appending to current window, pop it off the window stack.$/;"	p	namespace:ImGui	signature:()
End	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void End();                                               \/\/ Automatically called on the last call of Step() that returns false.$/;"	p	struct:ImGuiListClipper	access:public	signature:()
End	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui	signature:()
End	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiListClipper::End()$/;"	f	class:ImGuiListClipper	signature:()
EndChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndChild();$/;"	p	namespace:ImGui	signature:()
EndChild	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui	signature:()
EndChildFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndChildFrame();$/;"	p	namespace:ImGui	signature:()
EndChildFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui	signature:()
EndFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          EndFrame();                 \/\/ Ends the ImGui frame. Automatically called by Render()! you most likely don't need to ever call that yourself directly. If you don't need to render you can call EndFrame() but you'll have wasted CPU already. If you don't need to render, don't create any windows instead!$/;"	p	namespace:ImGui	signature:()
EndFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndFrame()$/;"	f	class:ImGui	signature:()
EndGroup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndGroup();$/;"	p	namespace:ImGui	signature:()
EndGroup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui	signature:()
EndMainMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMainMenuBar();$/;"	p	namespace:ImGui	signature:()
EndMainMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui	signature:()
EndMenu	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMenu();$/;"	p	namespace:ImGui	signature:()
EndMenu	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui	signature:()
EndMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMenuBar();$/;"	p	namespace:ImGui	signature:()
EndMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui	signature:()
EndPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndPopup();$/;"	p	namespace:ImGui	signature:()
EndPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui	signature:()
EndTooltip	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndTooltip();$/;"	p	namespace:ImGui	signature:()
EndTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui	signature:()
End_Time	abstract-machine/apps/dhrystone/dry.c	/^                End_Time,$/;"	v
Enum_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  Enumeration Enum_Comp;$/;"	m	struct:record::__anon12::__anon13	file:	access:public
Enumeration	abstract-machine/apps/dhrystone/dry.c	/^                Enumeration;$/;"	t	typeref:enum:__anon11	file:
Enumeration	abstract-machine/apps/dhrystone/dry.c	/^  typedef int   Enumeration;$/;"	t	file:
EventChar	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write (replace character or set to zero)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
EventFlag	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One of ImGuiInputTextFlags_Callback* \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
EventKey	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^struct ExampleAppConsole$/;"	s	file:
ExampleAppConsole::ClearLog	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole::Commands	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::Draw	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* title, bool* p_open)
ExampleAppConsole::ExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppConsole::ExecCommand	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* command_line)
ExampleAppConsole::History	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::HistoryPos	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::InputBuf	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::Items	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::ScrollToBottom	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:	access:public
ExampleAppConsole::Strdup	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = kalloc(len); return (char*)memcpy(buff, (const void*)str, len); }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char *str)
ExampleAppConsole::Stricmp	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* str1, const char* str2)
ExampleAppConsole::Strnicmp	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* str1, const char* str2, int n)
ExampleAppConsole::TextEditCallback	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
ExampleAppConsole::TextEditCallbackStub	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
ExampleAppConsole::~ExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
ExampleAppLog	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^struct ExampleAppLog$/;"	s	file:
ExampleAppLog::Buf	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImGuiTextBuffer     Buf;$/;"	m	struct:ExampleAppLog	file:	access:public
ExampleAppLog::Clear	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Clear()     { Buf.clear(); LineOffsets.clear(); }$/;"	f	struct:ExampleAppLog	access:public	signature:()
ExampleAppLog::Draw	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open = NULL)$/;"	f	struct:ExampleAppLog	access:public	signature:(const char* title, bool* p_open = NULL)
ExampleAppLog::Filter	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImGuiTextFilter     Filter;$/;"	m	struct:ExampleAppLog	file:	access:public
ExampleAppLog::LineOffsets	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<int>       LineOffsets;        \/\/ Index to lines offset$/;"	m	struct:ExampleAppLog	file:	access:public
ExampleAppLog::ScrollToBottom	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    bool                ScrollToBottom;$/;"	m	struct:ExampleAppLog	file:	access:public
ExecCommand	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* command_line)
Expand	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
Expand	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }$/;"	f	struct:ImRect	access:public	signature:(const float amount)
F16	abstract-machine/libs/fixmath/include/fix16.h	90;"	d
F16C	abstract-machine/libs/fixmath/include/fix16.h	308;"	d
FAILURE	abstract-machine/apps/microbench/src/bf/bf.c	43;"	d	file:
FBPixel	abstract-machine/am/src/x86/qemu/devices/video.c	/^static struct FBPixel {$/;"	s	file:
FBPixel	abstract-machine/am/src/x86/qemu/devices/video.c	/^typedef struct FBPixel FBPixel;$/;"	t	typeref:struct:FBPixel	file:
FBPixel::b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
FBPixel::g	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
FBPixel::r	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
FCE_H	abstract-machine/apps/litenes/include/fce.h	2;"	d
FIB_LG	abstract-machine/apps/microbench/include/benchmark.h	40;"	d
FIB_SM	abstract-machine/apps/microbench/include/benchmark.h	39;"	d
FILE	abstract-machine/libs/imgui/include/imconfig.h	/^typedef struct FILE {} FILE;$/;"	s
FILE	abstract-machine/libs/imgui/include/imconfig.h	/^typedef struct FILE {} FILE;$/;"	t	typeref:struct:FILE
FIXED	abstract-machine/am/src/x86/qemu/devices/apic.c	26;"	d	file:
FIXMATH_COMBINE_I_M	abstract-machine/libs/fixmath/include/fix16.h	273;"	d
FIXMATH_CONSTANT_POW10	abstract-machine/libs/fixmath/include/fix16.h	238;"	d
FIXMATH_CONVERT_MANTISSA	abstract-machine/libs/fixmath/include/fix16.h	257;"	d
FIXMATH_FUNC_ATTRS	abstract-machine/libs/fixmath/include/fix16.h	18;"	d
FIXMATH_FUNC_ATTRS	abstract-machine/libs/fixmath/include/fix16.h	20;"	d
FIXMATH_FUNC_ATTRS	abstract-machine/libs/fixmath/include/fix16.h	23;"	d
FIXMATH_NO_64BIT	abstract-machine/libs/fixmath/include/fix16.h	4;"	d
FIXMATH_NO_CACHE	abstract-machine/libs/fixmath/include/fix16.h	5;"	d
FIXMATH_TOKLEN	abstract-machine/libs/fixmath/include/fix16.h	235;"	d
FL_IF	abstract-machine/am/include/x86.h	20;"	d
FL_TF	abstract-machine/am/include/x86.h	19;"	d
FNALIAS	abstract-machine/libs/compiler-rt/int_lib.h	24;"	d
FNALIAS	abstract-machine/libs/compiler-rt/int_lib.h	28;"	d
FOUR_DIV_PI	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t FOUR_DIV_PI  = 0x145F3;            \/*!< Fix16 value of 4\/PI *\/$/;"	v
FPS	abstract-machine/am/src/native/devices/video.c	7;"	d	file:
FPS	abstract-machine/apps/litenes/include/fce.h	7;"	d
FPS	abstract-machine/apps/typing/game.h	5;"	d
FULL	abstract-machine/apps/microbench/src/queen/queen.c	/^static unsigned int FULL;$/;"	v	file:
FallbackChar	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar                     FallbackChar;       \/\/ = '?'        \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont	access:public
FallbackGlyph	abstract-machine/libs/imgui/include/imgui.h	/^    const Glyph*                FallbackGlyph;      \/\/ == FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont	access:public
FallbackXAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    float                       FallbackXAdvance;   \/\/ == FallbackGlyph->XAdvance$/;"	m	struct:ImFont	access:public
Fcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef float _Complex Fcomplex;$/;"	t
Fcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { float real, imaginary; } Fcomplex;$/;"	t	typeref:struct:__anon28
Filter	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImGuiTextFilter     Filter;$/;"	m	struct:ExampleAppLog	file:	access:public
Filters	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<TextRange> Filters;$/;"	m	struct:ImGuiTextFilter	access:public
FindBestPopupWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImVec2           FindBestPopupWindowPos(const ImVec2& base_pos, const ImVec2& size, int* last_dir, const ImRect& rect_to_avoid);$/;"	p	file:	signature:(const ImVec2& base_pos, const ImVec2& size, int* last_dir, const ImRect& rect_to_avoid)
FindBestPopupWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImVec2 FindBestPopupWindowPos(const ImVec2& base_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)$/;"	f	file:	signature:(const ImVec2& base_pos, const ImVec2& size, int* last_dir, const ImRect& r_inner)
FindGlyph	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const Glyph*      FindGlyph(ImWchar c) const;$/;"	p	struct:ImFont	access:public	signature:(ImWchar c) const
FindGlyph	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImFont::Glyph* ImFont::FindGlyph(unsigned short c) const$/;"	f	class:ImFont	signature:(unsigned short c) const
FindHoveredWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow*     FindHoveredWindow(ImVec2 pos, bool excluding_childs);$/;"	p	file:	signature:(ImVec2 pos, bool excluding_childs)
FindHoveredWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow* FindHoveredWindow(ImVec2 pos, bool excluding_childs)$/;"	f	file:	signature:(ImVec2 pos, bool excluding_childs)
FindRenderedTextEnd	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); \/\/ Find the optional ## from which we stop displaying text.$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
FindRenderedTextEnd	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
FindWindowByName	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);$/;"	p	namespace:ImGui	signature:(const char* name)
FindWindowByName	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByName(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
FindWindowSettings	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiIniData*    FindWindowSettings(const char* name);$/;"	p	file:	signature:(const char* name)
FindWindowSettings	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiIniData* FindWindowSettings(const char* name)$/;"	f	file:	signature:(const char* name)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16() { value = 0; }$/;"	f	class:Fix16	access:public	signature:()
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const Fix16 &inValue)  { value = inValue.value;             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &inValue)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const double inValue)  { value = fix16_from_dbl(inValue);   }$/;"	f	class:Fix16	access:public	signature:(const double inValue)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const fix16_t inValue) { value = inValue;                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t inValue)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const float inValue)   { value = fix16_from_float(inValue); }$/;"	f	class:Fix16	access:public	signature:(const float inValue)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const int16_t inValue) { value = fix16_from_int(inValue);   }$/;"	f	class:Fix16	access:public	signature:(const int16_t inValue)
Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^class Fix16 {$/;"	c
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16() { value = 0; }$/;"	f	class:Fix16	access:public	signature:()
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const Fix16 &inValue)  { value = inValue.value;             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &inValue)
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const double inValue)  { value = fix16_from_dbl(inValue);   }$/;"	f	class:Fix16	access:public	signature:(const double inValue)
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const fix16_t inValue) { value = inValue;                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t inValue)
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const float inValue)   { value = fix16_from_float(inValue); }$/;"	f	class:Fix16	access:public	signature:(const float inValue)
Fix16::Fix16	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16(const int16_t inValue) { value = fix16_from_int(inValue);   }$/;"	f	class:Fix16	access:public	signature:(const int16_t inValue)
Fix16::acos	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 acos() { return Fix16(fix16_acos(value)); }$/;"	f	class:Fix16	access:public	signature:()
Fix16::asin	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 asin() { return Fix16(fix16_asin(value)); }$/;"	f	class:Fix16	access:public	signature:()
Fix16::atan	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 atan() { return Fix16(fix16_atan(value)); }$/;"	f	class:Fix16	access:public	signature:()
Fix16::atan2	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 atan2(const Fix16 &inY) { return Fix16(fix16_atan2(value, inY.value)); }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &inY)
Fix16::cos	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  cos() { return Fix16(fix16_cos(value));  }$/;"	f	class:Fix16	access:public	signature:()
Fix16::operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const Fix16 &other)  const { return (value != other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const double other)  const { return (value != fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const fix16_t other) const { return (value != other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const float other)   const { return (value != fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const int16_t other) const { return (value != fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const Fix16 &other) const  { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const double other) const  { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const fix16_t other) const { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const float other) const   { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const int16_t other) const { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const Fix16 &rhs)  { value = fix16_mul(value, rhs.value); return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
Fix16::operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const double rhs)  { value = fix16_mul(value, fix16_from_dbl(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
Fix16::operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const fix16_t rhs) { value = fix16_mul(value, rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
Fix16::operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const float rhs)   { value = fix16_mul(value, fix16_from_float(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
Fix16::operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const int16_t rhs) { value *= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
Fix16::operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const Fix16 &other) const  { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const double other) const  { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const fix16_t other) const { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const float other) const   { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const int16_t other) const { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const Fix16 &rhs)  { value += rhs.value;             return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
Fix16::operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const double rhs)  { value += fix16_from_dbl(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
Fix16::operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const fix16_t rhs) { value += rhs;                   return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
Fix16::operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const float rhs)   { value += fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
Fix16::operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const int16_t rhs) { value += fix16_from_int(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
Fix16::operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const Fix16 &other) const  { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const double other) const  { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const fix16_t other) const { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const float other) const   { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const int16_t other) const { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const Fix16 &rhs)  { value -= rhs.value; return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
Fix16::operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const double rhs)  { value -= fix16_from_dbl(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
Fix16::operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const fix16_t rhs) { value -= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
Fix16::operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const float rhs)   { value -= fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
Fix16::operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const int16_t rhs) { value -= fix16_from_int(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
Fix16::operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const Fix16 &other) const  { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const double other) const  { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const fix16_t other) const { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const float other) const   { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const int16_t other) const { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const Fix16 &rhs)  { value = fix16_div(value, rhs.value); return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
Fix16::operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const double rhs)  { value = fix16_div(value, fix16_from_dbl(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
Fix16::operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const fix16_t rhs) { value = fix16_div(value, rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
Fix16::operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const float rhs)   { value = fix16_div(value, fix16_from_float(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
Fix16::operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const int16_t rhs) { value \/= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
Fix16::operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const Fix16 &other)  const { return (value <  other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const double other)  const { return (value <  fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const fix16_t other) const { return (value <  other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const float other)   const { return (value <  fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const int16_t other) const { return (value <  fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const Fix16 &other)  const { return (value <= other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const double other)  const { return (value <= fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const fix16_t other) const { return (value <= other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const float other)   const { return (value <= fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const int16_t other) const { return (value <= fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const Fix16 &rhs)  { value = rhs.value;             return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
Fix16::operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const double rhs)  { value = fix16_from_dbl(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
Fix16::operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const fix16_t rhs) { value = rhs;                   return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
Fix16::operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const float rhs)   { value = fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
Fix16::operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const int16_t rhs) { value = fix16_from_int(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
Fix16::operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const Fix16 &other)  const { return (value == other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const double other)  const { return (value == fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const fix16_t other) const { return (value == other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const float other)   const { return (value == fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const int16_t other) const { return (value == fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const Fix16 &other)  const { return (value >  other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const double other)  const { return (value >  fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const fix16_t other) const { return (value >  other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const float other)   const { return (value >  fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const int16_t other) const { return (value >  fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const Fix16 &other)  const { return (value >= other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const double other)  const { return (value >= fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const fix16_t other) const { return (value >= other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const float other)   const { return (value >= fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const int16_t other) const { return (value >= fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::operator double	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator double()  const { return fix16_to_dbl(value);   }$/;"	f	class:Fix16	access:public	signature:() const
Fix16::operator fix16_t	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator fix16_t() const { return value;                 }$/;"	f	class:Fix16	access:public	signature:() const
Fix16::operator float	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator float()   const { return fix16_to_float(value); }$/;"	f	class:Fix16	access:public	signature:() const
Fix16::operator int16_t	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator int16_t() const { return fix16_to_int(value);   }$/;"	f	class:Fix16	access:public	signature:() const
Fix16::sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const Fix16 &other)  const { Fix16 ret = fix16_sadd(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const double other)  const { Fix16 ret = fix16_sadd(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const fix16_t other) const { Fix16 ret = fix16_sadd(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const float other)   const { Fix16 ret = fix16_sadd(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const int16_t other) const { Fix16 ret = fix16_sadd(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const Fix16 &other)  const { Fix16 ret = fix16_sdiv(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const double other)  const { Fix16 ret = fix16_sdiv(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const fix16_t other) const { Fix16 ret = fix16_sdiv(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const float other)   const { Fix16 ret = fix16_sdiv(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const int16_t other) const { Fix16 ret = fix16_sdiv(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::sin	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  sin() { return Fix16(fix16_sin(value));  }$/;"	f	class:Fix16	access:public	signature:()
Fix16::smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const Fix16 &other)  const { Fix16 ret = fix16_smul(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const double other)  const { Fix16 ret = fix16_smul(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const fix16_t other) const { Fix16 ret = fix16_smul(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const float other)   const { Fix16 ret = fix16_smul(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const int16_t other) const { Fix16 ret = fix16_smul(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::sqrt	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 sqrt() { return Fix16(fix16_sqrt(value)); }$/;"	f	class:Fix16	access:public	signature:()
Fix16::ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const Fix16 &other)  const { Fix16 ret = fix16_sadd(value, -other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
Fix16::ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const double other)  const { Fix16 ret = fix16_sadd(value, -fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
Fix16::ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const fix16_t other) const { Fix16 ret = fix16_sadd(value, -other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
Fix16::ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const float other)   const { Fix16 ret = fix16_sadd(value, -fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
Fix16::ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const int16_t other) const { Fix16 ret = fix16_sadd(value, -fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
Fix16::tan	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  tan() { return Fix16(fix16_tan(value));  }$/;"	f	class:Fix16	access:public	signature:()
Fix16::value	abstract-machine/libs/fixmath/include/fix16.hpp	/^		fix16_t value;$/;"	m	class:Fix16	access:public
Flags	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Flags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindowFlags        Flags;                              \/\/ See enum ImGuiWindowFlags_$/;"	m	struct:ImGuiWindow	access:public
Float	abstract-machine/libs/fixmath/include/fix16.hpp	/^typedef Fix16 Float;$/;"	t
Floor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }$/;"	f	struct:ImRect	access:public	signature:()
FocusIdxAllCounter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllCounter;                 \/\/ Start at -1 and increase as assigned via FocusItemRegister()$/;"	m	struct:ImGuiWindow	access:public
FocusIdxAllRequestCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllRequestCurrent;          \/\/ Item being requested for focus$/;"	m	struct:ImGuiWindow	access:public
FocusIdxAllRequestNext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllRequestNext;             \/\/ Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)$/;"	m	struct:ImGuiWindow	access:public
FocusIdxTabCounter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabCounter;                 \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindow	access:public
FocusIdxTabRequestCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabRequestCurrent;          \/\/ Tab-able item being requested for focus$/;"	m	struct:ImGuiWindow	access:public
FocusIdxTabRequestNext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabRequestNext;             \/\/ "$/;"	m	struct:ImGuiWindow	access:public
FocusWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          FocusWindow(ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window)
FocusWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::FocusWindow(ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiWindow* window)
FocusableItemRegister	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop = true);      \/\/ Return true if focus is requested$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window, bool is_active, bool tab_stop = true)
FocusableItemRegister	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop)$/;"	f	class:ImGui	signature:(ImGuiWindow* window, bool is_active, bool tab_stop)
FocusableItemUnregister	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window)
FocusableItemUnregister	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::FocusableItemUnregister(ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiWindow* window)
FocusedWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            FocusedWindow;                      \/\/ Will catch keyboard inputs$/;"	m	struct:ImGuiContext	access:public
Font	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiContext	access:public
FontAllowUserScaling	abstract-machine/libs/imgui/include/imgui.h	/^    bool          FontAllowUserScaling;     \/\/ = false              \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO	access:public
FontBaseSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Size of characters.$/;"	m	struct:ImGuiContext	access:public
FontData	abstract-machine/libs/imgui/include/imgui.h	/^    void*           FontData;                   \/\/          \/\/ TTF data$/;"	m	struct:ImFontConfig	access:public
FontDataOwnedByAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    bool            FontDataOwnedByAtlas;       \/\/ true     \/\/ TTF data ownership taken by the container ImFontAtlas (will delete memory itself). Set to true$/;"	m	struct:ImFontConfig	access:public
FontDataSize	abstract-machine/libs/imgui/include/imgui.h	/^    int             FontDataSize;               \/\/          \/\/ TTF data size$/;"	m	struct:ImFontConfig	access:public
FontDefault	abstract-machine/libs/imgui/include/imgui.h	/^    ImFont*       FontDefault;              \/\/ = NULL               \/\/ Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].$/;"	m	struct:ImGuiIO	access:public
FontGlobalScale	abstract-machine/libs/imgui/include/imgui.h	/^    float         FontGlobalScale;          \/\/ = 1.0f               \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO	access:public
FontNo	abstract-machine/libs/imgui/include/imgui.h	/^    int             FontNo;                     \/\/ 0        \/\/ Index of font within TTF file$/;"	m	struct:ImFontConfig	access:public
FontSize	abstract-machine/libs/imgui/include/imgui.h	/^    float                       FontSize;           \/\/ <user set>   \/\/ Height of characters, set during loading (don't change after loading)$/;"	m	struct:ImFont	access:public
FontSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize()$/;"	m	struct:ImGuiContext	access:public
FontStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImFont*>       FontStack;                          \/\/ Stack for PushFont()\/PopFont()$/;"	m	struct:ImGuiContext	access:public
FontTexUvWhitePixel	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  FontTexUvWhitePixel;                \/\/ (Shortcut) == Font->TexUvWhitePixel$/;"	m	struct:ImGuiContext	access:public
FontWindowScale	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontWindowScale;                    \/\/ Scale multiplier per-window$/;"	m	struct:ImGuiWindow	access:public
Fonts	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontAtlas*  Fonts;                    \/\/ <auto>               \/\/ Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.$/;"	m	struct:ImGuiIO	access:public
Fonts	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImFont*>           Fonts;              \/\/ Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()\/PopFont() to change the current font.$/;"	m	struct:ImFontAtlas	access:public
FrameCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCount;$/;"	m	struct:ImGuiContext	access:public
FrameCountEnded	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCountEnded;$/;"	m	struct:ImGuiContext	access:public
FrameCountRendered	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiContext	access:public
FramePadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets)$/;"	m	struct:ImGuiStyle	access:public
FrameRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle	access:public
Framerate	abstract-machine/libs/imgui/include/imgui.h	/^    float       Framerate;                  \/\/ Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO	access:public
FramerateSecPerFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FramerateSecPerFrame[120];          \/\/ calculate estimate of framerate for user$/;"	m	struct:ImGuiContext	access:public
FramerateSecPerFrameAccum	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiContext	access:public
FramerateSecPerFrameIdx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiContext	access:public
Func_1	abstract-machine/apps/dhrystone/dry.c	/^Enumeration     Func_1 ();$/;"	p	file:
Func_1	abstract-machine/apps/dhrystone/dry.c	/^Enumeration Func_1 (Ch_1_Par_Val, Ch_2_Par_Val)$/;"	f
Func_2	abstract-machine/apps/dhrystone/dry.c	/^Boolean Func_2 (Str_1_Par_Ref, Str_2_Par_Ref)$/;"	f
Func_2	abstract-machine/apps/dhrystone/dry.c	/^Boolean Func_2 (Str_30, Str_30);$/;"	p	file:
Func_3	abstract-machine/apps/dhrystone/dry.c	/^Boolean Func_3 (Enum_Par_Val)$/;"	f
Func_3	abstract-machine/apps/dhrystone/dry.c	/^Boolean Func_3 (Enumeration);$/;"	p	file:
G	abstract-machine/am/src/native/devices/video.c	/^static inline uint8_t G(uint32_t p) { return p >> 8; }$/;"	f	file:	signature:(uint32_t p)
G	abstract-machine/am/src/x86/qemu/devices/video.c	/^static uint8_t G(uint32_t p) { return p >> 8; }$/;"	f	file:	signature:(uint32_t p)
G	abstract-machine/apps/litenes/include/common.h	/^static inline uint8_t G(uint32_t p) { return p >> 8; }$/;"	f	signature:(uint32_t p)
G	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^static Dinic *G;$/;"	v	file:
GATE	abstract-machine/am/include/x86.h	154;"	d
GDT_ENTRY	abstract-machine/am/src/x86/qemu/boot/start.S	/^#define GDT_ENTRY(n)  \\$/;"	d
GETMYTIME	abstract-machine/apps/coremark/src/core_portme.c	33;"	d	file:
GImDefaultContext	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiContext     GImDefaultContext;$/;"	v	file:
GImDefaultFontAtlas	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImFontAtlas      GImDefaultFontAtlas;$/;"	v	file:
GImGui	abstract-machine/libs/imgui/include/imgui_internal.h	/^extern IMGUI_API ImGuiContext* GImGui;  \/\/ Current implicit ImGui context pointer$/;"	x
GImGui	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiContext*           GImGui = &GImDefaultContext;$/;"	v
GPR1	abstract-machine/am/include/arch/native.h	28;"	d
GPR1	abstract-machine/am/include/arch/x86-qemu.h	13;"	d
GPR2	abstract-machine/am/include/arch/native.h	29;"	d
GPR2	abstract-machine/am/include/arch/x86-qemu.h	14;"	d
GPR3	abstract-machine/am/include/arch/native.h	30;"	d
GPR3	abstract-machine/am/include/arch/x86-qemu.h	15;"	d
GPR4	abstract-machine/am/include/arch/native.h	31;"	d
GPR4	abstract-machine/am/include/arch/x86-qemu.h	16;"	d
GPRx	abstract-machine/am/include/arch/native.h	32;"	d
GPRx	abstract-machine/am/include/arch/x86-qemu.h	17;"	d
GStyleVarInfo	abstract-machine/libs/imgui/src/imgui.cpp	/^static const ImGuiStyleVarInfo GStyleVarInfo[ImGuiStyleVar_Count_] =$/;"	v	file:
GateDesc	abstract-machine/am/include/x86.h	/^typedef struct GateDesc {$/;"	s
GateDesc	abstract-machine/am/include/x86.h	/^} GateDesc;$/;"	t	typeref:struct:GateDesc
GateDesc::args	abstract-machine/am/include/x86.h	/^  uint32_t args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:GateDesc	access:public
GateDesc::cs	abstract-machine/am/include/x86.h	/^  uint32_t cs : 16;         \/\/ Code segment selector$/;"	m	struct:GateDesc	access:public
GateDesc::dpl	abstract-machine/am/include/x86.h	/^  uint32_t dpl : 2;         \/\/ Descriptor(meaning new) privilege level$/;"	m	struct:GateDesc	access:public
GateDesc::off_15_0	abstract-machine/am/include/x86.h	/^  uint32_t off_15_0 : 16;   \/\/ Low 16 bits of offset in segment$/;"	m	struct:GateDesc	access:public
GateDesc::off_31_16	abstract-machine/am/include/x86.h	/^  uint32_t off_31_16 : 16;  \/\/ High bits of offset in segment$/;"	m	struct:GateDesc	access:public
GateDesc::p	abstract-machine/am/include/x86.h	/^  uint32_t p : 1;           \/\/ Present$/;"	m	struct:GateDesc	access:public
GateDesc::rsv1	abstract-machine/am/include/x86.h	/^  uint32_t rsv1 : 3;        \/\/ Reserved(should be zero I guess)$/;"	m	struct:GateDesc	access:public
GateDesc::s	abstract-machine/am/include/x86.h	/^  uint32_t s : 1;           \/\/ Must be 0 (system)$/;"	m	struct:GateDesc	access:public
GateDesc::type	abstract-machine/am/include/x86.h	/^  uint32_t type : 4;        \/\/ Type(STS_{TG,IG32,TG32})$/;"	m	struct:GateDesc	access:public
GetBL	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  \/\/ Bottom-left$/;"	f	struct:ImRect	access:public	signature:() const
GetBR	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetBR() const                   { return Max; }                   \/\/ Bottom-right$/;"	f	struct:ImRect	access:public	signature:() const
GetBool	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool default_val = false) const
GetBool	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool default_val) const
GetBoolRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool default_val = false)
GetBoolRef	abstract-machine/libs/imgui/src/imgui.cpp	/^bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool default_val)
GetCenter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }$/;"	f	struct:ImRect	access:public	signature:() const
GetCharAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }$/;"	f	struct:ImFont	access:public	signature:(ImWchar c) const
GetClipboardText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetClipboardText();$/;"	p	namespace:ImGui	signature:()
GetClipboardText	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetClipboardText()$/;"	f	class:ImGui	signature:()
GetClipboardTextFn	abstract-machine/libs/imgui/include/imgui.h	/^    const char* (*GetClipboardTextFn)(void* user_data);$/;"	m	struct:ImGuiIO	access:public
GetClipboardTextFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static const char*      GetClipboardTextFn_DefaultImpl(void* user_data);$/;"	p	file:	signature:(void* user_data)
GetClipboardTextFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static const char* GetClipboardTextFn_DefaultImpl(void*)$/;"	f	file:	signature:(void*)
GetClosestPoint	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const$/;"	f	struct:ImRect	access:public	signature:(ImVec2 p, bool on_edge) const
GetColorU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  \/\/ retrieve given style color with style alpha applied and optional extra alpha multiplier$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, float alpha_mul = 1.0f)
GetColorU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     \/\/ retrieve given color with style alpha applied$/;"	p	namespace:ImGui	signature:(const ImVec4& col)
GetColorU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)  $/;"	f	class:ImGui	signature:(ImGuiCol idx, float alpha_mul)
GetColorU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::GetColorU32(const ImVec4& col)$/;"	f	class:ImGui	signature:(const ImVec4& col)
GetColumnIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetColumnIndex();                                                   \/\/ get current column index$/;"	p	namespace:ImGui	signature:()
GetColumnIndex	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui	signature:()
GetColumnOffset	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetColumnOffset(int column_index = -1);                             \/\/ get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetcolumnsCount() inclusive. column 0 is usually 0.0f and not resizable unless you call this$/;"	p	namespace:ImGui	signature:(int column_index = -1)
GetColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
GetColumnWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetColumnWidth(int column_index = -1);                              \/\/ column width (== GetColumnOffset(GetColumnIndex()+1) - GetColumnOffset(GetColumnOffset())$/;"	p	namespace:ImGui	signature:(int column_index = -1)
GetColumnWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
GetColumnsCount	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetColumnsCount();                                                  \/\/ number of columns (what was passed to Columns())$/;"	p	namespace:ImGui	signature:()
GetColumnsCount	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui	signature:()
GetContentRegionAvail	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionAvail();                                            \/\/ == GetContentRegionMax() - GetCursorPos()$/;"	p	namespace:ImGui	signature:()
GetContentRegionAvail	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetContentRegionAvail()$/;"	f	class:ImGui	signature:()
GetContentRegionAvailWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetContentRegionAvailWidth();                                       \/\/$/;"	p	namespace:ImGui	signature:()
GetContentRegionAvailWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetContentRegionAvailWidth()$/;"	f	class:ImGui	signature:()
GetContentRegionMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionMax();                                              \/\/ current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates$/;"	p	namespace:ImGui	signature:()
GetContentRegionMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui	signature:()
GetCurrentClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	151;"	d	file:
GetCurrentClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	218;"	d	file:
GetCurrentContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiContext* GetCurrentContext();$/;"	p	namespace:ImGui	signature:()
GetCurrentContext	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiContext* ImGui::GetCurrentContext()$/;"	f	class:ImGui	signature:()
GetCurrentTextureId	abstract-machine/libs/imgui/src/imgui_draw.cpp	152;"	d	file:
GetCurrentTextureId	abstract-machine/libs/imgui/src/imgui_draw.cpp	219;"	d	file:
GetCurrentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }$/;"	f	namespace:ImGui	signature:()
GetCurrentWindowRead	abstract-machine/libs/imgui/include/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }$/;"	f	namespace:ImGui	signature:()
GetCursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorPos();                                                     \/\/ cursor position is relative to window position$/;"	p	namespace:ImGui	signature:()
GetCursorPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui	signature:()
GetCursorPosX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetCursorPosX();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
GetCursorPosX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui	signature:()
GetCursorPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetCursorPosY();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
GetCursorPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui	signature:()
GetCursorScreenPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorScreenPos();                                               \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)$/;"	p	namespace:ImGui	signature:()
GetCursorScreenPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui	signature:()
GetCursorStartPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorStartPos();                                                \/\/ initial cursor position$/;"	p	namespace:ImGui	signature:()
GetCursorStartPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui	signature:()
GetDefaultCompressedFontDataTTFBase85	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static const char*  GetDefaultCompressedFontDataTTFBase85();$/;"	p	file:	signature:()
GetDefaultCompressedFontDataTTFBase85	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static const char* GetDefaultCompressedFontDataTTFBase85()$/;"	f	file:	signature:()
GetDefaultFont	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImFont*          GetDefaultFont();$/;"	p	file:	signature:()
GetDefaultFont	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImFont* GetDefaultFont()$/;"	f	file:	signature:()
GetDraggedColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^static float            GetDraggedColumnOffset(int column_index);$/;"	p	file:	signature:(int column_index)
GetDraggedColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^static float GetDraggedColumnOffset(int column_index)$/;"	f	file:	signature:(int column_index)
GetDrawData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImDrawData*   GetDrawData();                              \/\/ same value as passed to your io.RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()$/;"	p	namespace:ImGui	signature:()
GetDrawData	abstract-machine/libs/imgui/src/imgui.cpp	/^ImDrawData* ImGui::GetDrawData()$/;"	f	class:ImGui	signature:()
GetFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f) const
GetFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val) const
GetFloatRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f)
GetFloatRef	abstract-machine/libs/imgui/src/imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val)
GetFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*       GetFont();                                                          \/\/ get current font$/;"	p	namespace:ImGui	signature:()
GetFont	abstract-machine/libs/imgui/src/imgui.cpp	/^ImFont* ImGui::GetFont()$/;"	f	class:ImGui	signature:()
GetFontSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetFontSize();                                                      \/\/ get current font size (= height in pixels) of current font with current scale applied$/;"	p	namespace:ImGui	signature:()
GetFontSize	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetFontSize()$/;"	f	class:ImGui	signature:()
GetFontTexUvWhitePixel	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                           \/\/ get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API$/;"	p	namespace:ImGui	signature:()
GetFontTexUvWhitePixel	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetFontTexUvWhitePixel()$/;"	f	class:ImGui	signature:()
GetFrameCount	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetFrameCount();$/;"	p	namespace:ImGui	signature:()
GetFrameCount	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui	signature:()
GetFrontMostModalRootWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow*     GetFrontMostModalRootWindow();$/;"	p	file:	signature:()
GetFrontMostModalRootWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImGuiWindow* GetFrontMostModalRootWindow()$/;"	f	file:	signature:()
GetGlyphRangesChinese	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesChinese();    \/\/ Japanese + full set of about 21000 CJK Unified Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesChinese	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChinese()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesCyrillic	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   \/\/ Default + about 400 Cyrillic characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesCyrillic	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesDefault	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesDefault();    \/\/ Basic Latin, Extended Latin$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesDefault	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesJapanese	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   \/\/ Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesJapanese	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesKorean	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesKorean();     \/\/ Default + Korean characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesKorean	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()$/;"	f	class:ImFontAtlas	signature:()
GetGlyphRangesThai	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesThai();       \/\/ Default + Thai characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
GetGlyphRangesThai	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesThai()$/;"	f	class:ImFontAtlas	signature:()
GetHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       GetHeight() const               { return Max.y-Min.y; }$/;"	f	struct:ImRect	access:public	signature:() const
GetI	abstract-machine/apps/microbench/src/ssort/ssort.cpp	67;"	d	file:
GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id);                                          \/\/ calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed$/;"	p	namespace:ImGui	signature:(const char* str_id)
GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
GetID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetID(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* str, const char* str_end = NULL)
GetID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetID(const void* ptr);$/;"	p	struct:ImGuiWindow	access:public	signature:(const void* ptr)
GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow	signature:(const void* ptr)
GetIDNoKeepAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* str, const char* str_end = NULL)
GetIDNoKeepAlive	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
GetIO	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiIO&      GetIO();$/;"	p	namespace:ImGui	signature:()
GetIO	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui	signature:()
GetInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0) const
GetInt	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGuiStorage::GetInt(ImGuiID key, int default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val) const
GetIntRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0)
GetIntRef	abstract-machine/libs/imgui/src/imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val)
GetItemRectMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMax();                                                   \/\/ "$/;"	p	namespace:ImGui	signature:()
GetItemRectMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui	signature:()
GetItemRectMin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMin();                                                   \/\/ get bounding rect of last item in screen space$/;"	p	namespace:ImGui	signature:()
GetItemRectMin	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui	signature:()
GetItemRectSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectSize();                                                  \/\/ "$/;"	p	namespace:ImGui	signature:()
GetItemRectSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui	signature:()
GetItemsLineHeightWithSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetItemsLineHeightWithSpacing();                                    \/\/ distance (in pixels) between 2 consecutive lines of standard height widgets == GetWindowFontSize() + GetStyle().FramePadding.y*2 + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
GetItemsLineHeightWithSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetItemsLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
GetKeyIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    \/\/ map ImGuiKey_* values into user's key index. == io.KeyMap[key]$/;"	p	namespace:ImGui	signature:(ImGuiKey imgui_key)
GetKeyIndex	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey imgui_key)$/;"	f	class:ImGui	signature:(ImGuiKey imgui_key)
GetMouseCursor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                \/\/ get desired cursor type, reset in ImGui::NewFrame(), this updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you$/;"	p	namespace:ImGui	signature:()
GetMouseCursor	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui	signature:()
GetMouseDragDelta	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    \/\/ dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
GetMouseDragDelta	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
GetMousePos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMousePos();                                                      \/\/ shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls$/;"	p	namespace:ImGui	signature:()
GetMousePos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui	signature:()
GetMousePosOnOpeningCurrentPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 \/\/ retrieve backup of mouse positioning at the time of opening popup we have BeginPopup() into$/;"	p	namespace:ImGui	signature:()
GetMousePosOnOpeningCurrentPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()$/;"	f	class:ImGui	signature:()
GetParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImGuiWindow*  GetParentWindow();$/;"	p	namespace:ImGui	signature:()
GetParentWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow* ImGui::GetParentWindow()$/;"	f	class:ImGui	signature:()
GetScrollMaxX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollMaxX();                                                    \/\/ get maximum scrolling amount ~~ ContentSize.X - WindowSize.X$/;"	p	namespace:ImGui	signature:()
GetScrollMaxX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollMaxX()$/;"	f	class:ImGui	signature:()
GetScrollMaxY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollMaxY();                                                    \/\/ get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y$/;"	p	namespace:ImGui	signature:()
GetScrollMaxY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui	signature:()
GetScrollX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollX();                                                       \/\/ get scrolling amount [0..GetScrollMaxX()]$/;"	p	namespace:ImGui	signature:()
GetScrollX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollX()$/;"	f	class:ImGui	signature:()
GetScrollY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollY();                                                       \/\/ get scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:()
GetScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui	signature:()
GetSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
GetStateStorage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStorage* GetStateStorage();$/;"	p	namespace:ImGui	signature:()
GetStateStorage	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui	signature:()
GetStyle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStyle&   GetStyle();$/;"	p	namespace:ImGui	signature:()
GetStyle	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui	signature:()
GetStyleColName	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetStyleColName(ImGuiCol idx);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx)
GetStyleColName	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetStyleColName(ImGuiCol idx)$/;"	f	class:ImGui	signature:(ImGuiCol idx)
GetStyleVarInfo	abstract-machine/libs/imgui/src/imgui.cpp	/^static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)$/;"	f	file:	signature:(ImGuiStyleVar idx)
GetTL	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetTL() const                   { return Min; }                   \/\/ Top-left$/;"	f	struct:ImRect	access:public	signature:() const
GetTR	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  \/\/ Top-right$/;"	f	struct:ImRect	access:public	signature:() const
GetTexDataAsAlpha8	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 1 byte per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
GetTexDataAsAlpha8	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
GetTexDataAsRGBA32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 4 bytes-per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
GetTexDataAsRGBA32	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
GetTextLineHeight	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTextLineHeight();                                                \/\/ height of font == GetWindowFontSize()$/;"	p	namespace:ImGui	signature:()
GetTextLineHeight	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui	signature:()
GetTextLineHeightWithSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTextLineHeightWithSpacing();                                     \/\/ distance (in pixels) between 2 consecutive lines of text == GetWindowFontSize() + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
GetTextLineHeightWithSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
GetTime	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTime();$/;"	p	namespace:ImGui	signature:()
GetTime	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTime()$/;"	f	class:ImGui	signature:()
GetTreeNodeToLabelSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTreeNodeToLabelSpacing();                                            \/\/ horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode$/;"	p	namespace:ImGui	signature:()
GetTreeNodeToLabelSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTreeNodeToLabelSpacing()$/;"	f	class:ImGui	signature:()
GetVarPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^    void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }$/;"	f	struct:ImGuiStyleVarInfo	access:public	signature:() const
GetVersion	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetVersion();$/;"	p	namespace:ImGui	signature:()
GetVersion	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui	signature:()
GetVisibleRect	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImRect           GetVisibleRect();$/;"	p	file:	signature:()
GetVisibleRect	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImRect GetVisibleRect()$/;"	f	file:	signature:()
GetVoidPtr	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; \/\/ default_val is NULL$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key) const
GetVoidPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key) const
GetVoidPtrRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* default_val = NULL)
GetVoidPtrRef	abstract-machine/libs/imgui/src/imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* default_val)
GetWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       GetWidth() const                { return Max.x-Min.x; }$/;"	f	struct:ImRect	access:public	signature:() const
GetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:()
GetWindowContentRegionMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMax();                                        \/\/ content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates$/;"	p	namespace:ImGui	signature:()
GetWindowContentRegionMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui	signature:()
GetWindowContentRegionMin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMin();                                        \/\/ content boundaries min (roughly (0,0)-Scroll), in window coordinates$/;"	p	namespace:ImGui	signature:()
GetWindowContentRegionMin	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui	signature:()
GetWindowContentRegionWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowContentRegionWidth();                                      \/\/$/;"	p	namespace:ImGui	signature:()
GetWindowContentRegionWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowContentRegionWidth()$/;"	f	class:ImGui	signature:()
GetWindowDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImDrawList*   GetWindowDrawList();                                                \/\/ get rendering command-list if you want to append your own draw primitives$/;"	p	namespace:ImGui	signature:()
GetWindowDrawList	abstract-machine/libs/imgui/src/imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui	signature:()
GetWindowFont	abstract-machine/libs/imgui/include/imgui.h	/^    static inline ImFont*   GetWindowFont() { return GetFont(); }                              \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui	signature:()
GetWindowFontSize	abstract-machine/libs/imgui/include/imgui.h	/^    static inline float     GetWindowFontSize() { return GetFontSize(); }                      \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui	signature:()
GetWindowHeight	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowHeight();$/;"	p	namespace:ImGui	signature:()
GetWindowHeight	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowHeight()$/;"	f	class:ImGui	signature:()
GetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowPos();                                                     \/\/ get current window position in screen space (useful if you want to do your own drawing via the DrawList api)$/;"	p	namespace:ImGui	signature:()
GetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui	signature:()
GetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowSize();                                                    \/\/ get current window size$/;"	p	namespace:ImGui	signature:()
GetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui	signature:()
GetWindowWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowWidth();$/;"	p	namespace:ImGui	signature:()
GetWindowWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui	signature:()
Glyph	abstract-machine/libs/imgui/include/imgui.h	/^    struct Glyph$/;"	s	struct:ImFont	access:public
GlyphExtraSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2          GlyphExtraSpacing;          \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs$/;"	m	struct:ImFontConfig	access:public
GlyphOffset	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2          GlyphOffset;                \/\/ 0, 0     \/\/ Offset all glyphs from this font input$/;"	m	struct:ImFontConfig	access:public
GlyphRanges	abstract-machine/libs/imgui/include/imgui.h	/^    const ImWchar*  GlyphRanges;                \/\/          \/\/ Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.$/;"	m	struct:ImFontConfig	access:public
Glyphs	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<Glyph>             Glyphs;             \/\/              \/\/ All glyphs.$/;"	m	struct:ImFont	access:public
GrabMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar.$/;"	m	struct:ImGuiStyle	access:public
GrabRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle	access:public
GroupOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   GroupOffsetX;$/;"	m	struct:ImGuiDrawContext	access:public
GroupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiDrawContext	access:public
GrowIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GrowIndex(int new_size);$/;"	p	struct:ImFont	access:public	signature:(int new_size)
GrowIndex	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::GrowIndex(int new_size)$/;"	f	class:ImFont	signature:(int new_size)
H	abstract-machine/am/src/native/devices/video.c	6;"	d	file:
H	abstract-machine/am/src/x86/qemu/devices/video.c	/^static int W, H;$/;"	v	file:
H	abstract-machine/apps/litenes/include/fce.h	9;"	d
H	abstract-machine/apps/typing/game.h	11;"	d
HAS_FLOAT	abstract-machine/apps/coremark/include/core_portme.h	21;"	d
HAS_PRINTF	abstract-machine/apps/coremark/include/core_portme.h	47;"	d
HAS_STDIO	abstract-machine/apps/coremark/include/core_portme.h	41;"	d
HAS_TIME_H	abstract-machine/apps/coremark/include/core_portme.h	28;"	d
HSV	abstract-machine/libs/imgui/include/imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
HZ	abstract-machine/apps/typing/game.h	4;"	d
HasSelection	abstract-machine/libs/imgui/include/imgui.h	/^    bool    HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiTextEditCallbackData	access:public	signature:() const
HasSelection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
HiddenFrames	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     HiddenFrames;$/;"	m	struct:ImGuiWindow	access:public
History	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:	access:public
HistoryPos	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:	access:public
HotOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              HotOffset;$/;"	m	struct:ImGuiMouseCursorData	access:public
HoveredId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiContext	access:public
HoveredIdAllowOverlap	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    HoveredIdAllowOverlap;$/;"	m	struct:ImGuiContext	access:public
HoveredIdPreviousFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiContext	access:public
HoveredRootWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiContext	access:public
HoveredWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiContext	access:public
ICRHI	abstract-machine/am/src/x86/qemu/devices/apic.c	27;"	d	file:
ICRLO	abstract-machine/am/src/x86/qemu/devices/apic.c	17;"	d	file:
ID	abstract-machine/am/src/x86/qemu/devices/apic.c	10;"	d	file:
ID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ID;                                 \/\/ == ImHash(Name)$/;"	m	struct:ImGuiWindow	access:public
IDStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow	access:public
IDT_ENTRY	abstract-machine/am/src/x86/qemu/cte.c	17;"	d	file:
ID_LIST	abstract-machine/apps/coremark/include/coremark.h	84;"	d
ID_MATRIX	abstract-machine/apps/coremark/include/coremark.h	85;"	d
ID_STATE	abstract-machine/apps/coremark/include/coremark.h	86;"	d
IMGUI_API	abstract-machine/libs/imgui/include/imgui.h	22;"	d
IMGUI_DEFINE_MATH_OPERATORS	abstract-machine/libs/imgui/src/imgui.cpp	620;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	abstract-machine/libs/imgui/src/imgui_draw.cpp	16;"	d	file:
IMGUI_DEFINE_PLACEMENT_NEW	abstract-machine/libs/imgui/src/imgui.cpp	621;"	d	file:
IMGUI_DEFINE_PLACEMENT_NEW	abstract-machine/libs/imgui/src/imgui_draw.cpp	17;"	d	file:
IMGUI_ONCE_UPON_A_FRAME	abstract-machine/libs/imgui/include/imgui.h	895;"	d
IMGUI_STB_NAMESPACE	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^namespace IMGUI_STB_NAMESPACE$/;"	n	file:
IMGUI_VERSION	abstract-machine/libs/imgui/include/imgui.h	18;"	d
IM_ARRAYSIZE	abstract-machine/libs/imgui/include/imgui_internal.h	76;"	d
IM_ARRAYSIZE	abstract-machine/libs/imgui/src/imgui_demo.cpp	51;"	d	file:
IM_ASSERT	abstract-machine/libs/imgui/include/imgui.h	27;"	d
IM_COL32	abstract-machine/libs/imgui/include/imgui.h	1050;"	d
IM_COL32_A_MASK	abstract-machine/libs/imgui/include/imgui.h	1042;"	d
IM_COL32_A_MASK	abstract-machine/libs/imgui/include/imgui.h	1048;"	d
IM_COL32_A_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1041;"	d
IM_COL32_A_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1047;"	d
IM_COL32_BLACK	abstract-machine/libs/imgui/include/imgui.h	1052;"	d
IM_COL32_BLACK_TRANS	abstract-machine/libs/imgui/include/imgui.h	1053;"	d
IM_COL32_B_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1040;"	d
IM_COL32_B_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1046;"	d
IM_COL32_G_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1039;"	d
IM_COL32_G_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1045;"	d
IM_COL32_R_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1038;"	d
IM_COL32_R_SHIFT	abstract-machine/libs/imgui/include/imgui.h	1044;"	d
IM_COL32_WHITE	abstract-machine/libs/imgui/include/imgui.h	1051;"	d
IM_F32_TO_INT8_SAT	abstract-machine/libs/imgui/src/imgui.cpp	884;"	d	file:
IM_F32_TO_INT8_UNBOUND	abstract-machine/libs/imgui/src/imgui.cpp	883;"	d	file:
IM_MAX	abstract-machine/libs/imgui/src/imgui_demo.cpp	52;"	d	file:
IM_NEWLINE	abstract-machine/libs/imgui/src/imgui.cpp	888;"	d	file:
IM_NEWLINE	abstract-machine/libs/imgui/src/imgui.cpp	890;"	d	file:
IM_NEWLINE	abstract-machine/libs/imgui/src/imgui_demo.cpp	46;"	d	file:
IM_NEWLINE	abstract-machine/libs/imgui/src/imgui_demo.cpp	48;"	d	file:
IM_OFFSETOF	abstract-machine/libs/imgui/include/imgui_internal.h	78;"	d
IM_PI	abstract-machine/libs/imgui/include/imgui_internal.h	77;"	d
IM_PLACEMENT_NEW	abstract-machine/libs/imgui/include/imgui_internal.h	145;"	d
IM_PRINTFARGS	abstract-machine/libs/imgui/include/imgui.h	32;"	d
IM_PRINTFARGS	abstract-machine/libs/imgui/include/imgui.h	34;"	d
INCLUDE_STB_TEXTEDIT_H	abstract-machine/libs/imgui/include/stb_textedit.h	272;"	d
INF	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^const int INF = 0x3f3f3f;$/;"	v
INIT	abstract-machine/am/src/x86/qemu/devices/apic.c	18;"	d	file:
INPUT	abstract-machine/apps/microbench/Makefile	/^INPUT ?= REF$/;"	m
INT_ACTIVELOW	abstract-machine/am/src/x86/qemu/devices/apic.c	176;"	d	file:
INT_DISABLED	abstract-machine/am/src/x86/qemu/devices/apic.c	174;"	d	file:
INT_ENDIANNESS_H	abstract-machine/libs/compiler-rt/int_endianness.h	17;"	d
INT_LEVEL	abstract-machine/am/src/x86/qemu/devices/apic.c	175;"	d	file:
INT_LIB_H	abstract-machine/libs/compiler-rt/int_lib.h	17;"	d
INT_LOGICAL	abstract-machine/am/src/x86/qemu/devices/apic.c	177;"	d	file:
INT_TYPES_H	abstract-machine/libs/compiler-rt/int_types.h	19;"	d
INT_UTIL_H	abstract-machine/libs/compiler-rt/int_util.h	20;"	d
IO	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiContext	access:public
IOAPIC	abstract-machine/am/src/x86/qemu/devices/apic.c	/^struct IOAPIC {$/;"	s	file:
IOAPIC	abstract-machine/am/src/x86/qemu/devices/apic.c	/^typedef struct IOAPIC IOAPIC;$/;"	t	typeref:struct:IOAPIC	file:
IOAPIC::data	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
IOAPIC::pad	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
IOAPIC::reg	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
IOAPIC_ADDR	abstract-machine/am/src/x86/qemu/devices/apic.c	163;"	d	file:
IRQ	abstract-machine/am/src/x86/qemu/cte.c	66;"	d	file:
IRQHANDLE_DECL	abstract-machine/am/src/x86/qemu/cte.c	7;"	d	file:
IRQS	abstract-machine/am/include/x86.h	75;"	d
IRQ_DEF	abstract-machine/am/src/x86/qemu/cte_trap.S	/^#define IRQ_DEF(id, dpl, err) \\$/;"	d
IRQ_ERROR	abstract-machine/am/include/x86.h	61;"	d
IRQ_KBD	abstract-machine/am/include/x86.h	60;"	d
IRQ_SPURIOUS	abstract-machine/am/include/x86.h	62;"	d
IRQ_TIMER	abstract-machine/am/include/x86.h	59;"	d
ITERATIONS	abstract-machine/apps/coremark/include/core_portme.h	11;"	d
Id	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID             Id;                         \/\/ widget id owning the text state$/;"	m	struct:ImGuiTextEditState	access:public
Id	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     Id;$/;"	m	struct:ImGuiIniData	access:public
Ident_1	abstract-machine/apps/dhrystone/dry.c	/^  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}$/;"	e	enum:__anon11	file:
Ident_1	abstract-machine/apps/dhrystone/dry.c	369;"	d	file:
Ident_2	abstract-machine/apps/dhrystone/dry.c	/^  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}$/;"	e	enum:__anon11	file:
Ident_2	abstract-machine/apps/dhrystone/dry.c	370;"	d	file:
Ident_3	abstract-machine/apps/dhrystone/dry.c	/^  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}$/;"	e	enum:__anon11	file:
Ident_3	abstract-machine/apps/dhrystone/dry.c	371;"	d	file:
Ident_4	abstract-machine/apps/dhrystone/dry.c	/^  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}$/;"	e	enum:__anon11	file:
Ident_4	abstract-machine/apps/dhrystone/dry.c	372;"	d	file:
Ident_5	abstract-machine/apps/dhrystone/dry.c	/^  typedef       enum    {Ident_1, Ident_2, Ident_3, Ident_4, Ident_5}$/;"	e	enum:__anon11	file:
Ident_5	abstract-machine/apps/dhrystone/dry.c	373;"	d	file:
IdxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList	access:public
IdxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImCharIsSpace	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline bool      ImCharIsSpace(int c)            { return c == ' ' || c == '\\t' || c == 0x3000; }$/;"	f	signature:(int c)
ImClamp	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx)      { return ImVec2(ImClamp(f.x,mn.x,mx.x), ImClamp(f.y,mn.y,mx.y)); }$/;"	f	signature:(const ImVec2& f, const ImVec2& mn, ImVec2 mx)
ImClamp	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImClamp(float v, float mn, float mx)                       { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f	signature:(float v, float mn, float mx)
ImClamp	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline int    ImClamp(int v, int mn, int mx)                             { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f	signature:(int v, int mn, int mx)
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }$/;"	f	struct:ImColor	access:public	signature:()
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(ImU32 rgba)                                             { float sc = 1.0f\/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }$/;"	f	struct:ImColor	access:public	signature:(ImU32 rgba)
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor	access:public	signature:(const ImVec4& col)
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float r, float g, float b, float a = 1.0f)
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f\/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }$/;"	f	struct:ImColor	access:public	signature:(int r, int g, int b, int a = 255)
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^struct ImColor$/;"	s
ImColor	abstract-machine/libs/imgui/include/imgui.h	/^struct ImColor;                     \/\/ Helper functions to create a color that can be converted to either uint32_t or float4$/;"	x
ImColor::HSV	abstract-machine/libs/imgui/include/imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
ImColor::ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }$/;"	f	struct:ImColor	access:public	signature:()
ImColor::ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(ImU32 rgba)                                             { float sc = 1.0f\/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }$/;"	f	struct:ImColor	access:public	signature:(ImU32 rgba)
ImColor::ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor	access:public	signature:(const ImVec4& col)
ImColor::ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float r, float g, float b, float a = 1.0f)
ImColor::ImColor	abstract-machine/libs/imgui/include/imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f\/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }$/;"	f	struct:ImColor	access:public	signature:(int r, int g, int b, int a = 255)
ImColor::SetHSV	abstract-machine/libs/imgui/include/imgui.h	/^    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
ImColor::Value	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor	access:public
ImColor::operator ImU32	abstract-machine/libs/imgui/include/imgui.h	/^    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor	access:public	signature:() const
ImColor::operator ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    inline operator ImVec4() const                                  { return Value; }$/;"	f	struct:ImColor	access:public	signature:() const
ImDrawCallback	abstract-machine/libs/imgui/include/imgui.h	/^typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);$/;"	t
ImDrawChannel	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawChannel$/;"	s
ImDrawChannel	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawChannel;               \/\/ Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()$/;"	x
ImDrawChannel::CmdBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImDrawChannel::IdxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;$/;"	m	struct:ImDrawChannel	access:public
ImDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }$/;"	f	struct:ImDrawCmd	access:public	signature:()
ImDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawCmd$/;"	s
ImDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawCmd;                   \/\/ A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)$/;"	x
ImDrawCmd::ClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2)$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::ElemCount	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::ImDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = -8192.0f; ClipRect.z = ClipRect.w = +8192.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }$/;"	f	struct:ImDrawCmd	access:public	signature:()
ImDrawCmd::TextureId	abstract-machine/libs/imgui/include/imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::UserCallback	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd	access:public
ImDrawCmd::UserCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd	access:public
ImDrawData	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }$/;"	f	struct:ImDrawData	access:public	signature:()
ImDrawData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawData$/;"	s
ImDrawData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawData;                  \/\/ All draw command lists required to render the frame$/;"	x
ImDrawData::CmdLists	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawList**    CmdLists;$/;"	m	struct:ImDrawData	access:public
ImDrawData::CmdListsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             CmdListsCount;$/;"	m	struct:ImDrawData	access:public
ImDrawData::DeIndexAllBuffers	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void DeIndexAllBuffers();               \/\/ For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!$/;"	p	struct:ImDrawData	access:public	signature:()
ImDrawData::DeIndexAllBuffers	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData	signature:()
ImDrawData::ImDrawData	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawData() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; }$/;"	f	struct:ImDrawData	access:public	signature:()
ImDrawData::ScaleClipRects	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void ScaleClipRects(const ImVec2& sc);  \/\/ Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.$/;"	p	struct:ImDrawData	access:public	signature:(const ImVec2& sc)
ImDrawData::ScaleClipRects	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawData::ScaleClipRects(const ImVec2& scale)$/;"	f	class:ImDrawData	signature:(const ImVec2& scale)
ImDrawData::TotalIdxCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all cmd_lists idx_buffer.Size$/;"	m	struct:ImDrawData	access:public
ImDrawData::TotalVtxCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all cmd_lists vtx_buffer.Size$/;"	m	struct:ImDrawData	access:public
ImDrawData::Valid	abstract-machine/libs/imgui/include/imgui.h	/^    bool            Valid;                  \/\/ Only valid after Render() is called and before the next NewFrame() is called.$/;"	m	struct:ImDrawData	access:public
ImDrawIdx	abstract-machine/libs/imgui/include/imgui.h	/^typedef unsigned short ImDrawIdx;$/;"	t
ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawList()  { _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawList$/;"	s
ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawList;                  \/\/ A single draw command list (generally one per window)$/;"	x
ImDrawList::AddBezierCurve	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0)
ImDrawList::AddBezierCurve	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
ImDrawList::AddCallback	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  \/\/ Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.$/;"	p	struct:ImDrawList	access:public	signature:(ImDrawCallback callback, void* callback_data)
ImDrawList::AddCallback	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList	signature:(ImDrawCallback callback, void* callback_data)
ImDrawList::AddCircle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f)
ImDrawList::AddCircle	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
ImDrawList::AddCircleFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12)
ImDrawList::AddCircleFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, ImU32 col, int num_segments)
ImDrawList::AddConvexPolyFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool anti_aliased)
ImDrawList::AddConvexPolyFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool anti_aliased)
ImDrawList::AddDrawCmd	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddDrawCmd();                                               \/\/ This is useful if you need to forcefully create a new draw call (to allow for dependent rendering \/ blending). Otherwise primitives are merged into the same draw-call as much as possible$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::AddDrawCmd	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList	signature:()
ImDrawList::AddImage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,1), ImU32 col = 0xFFFFFFFF)
ImDrawList::AddImage	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
ImDrawList::AddImageQuad	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF);$/;"	p	struct:ImDrawList	access:public	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0,0), const ImVec2& uv_b = ImVec2(1,0), const ImVec2& uv_c = ImVec2(1,1), const ImVec2& uv_d = ImVec2(0,1), ImU32 col = 0xFFFFFFFF)
ImDrawList::AddImageQuad	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList	signature:(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
ImDrawList::AddLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f)
ImDrawList::AddLine	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
ImDrawList::AddPolyline	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness, bool anti_aliased)
ImDrawList::AddPolyline	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)$/;"	f	class:ImDrawList	signature:(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness, bool anti_aliased)
ImDrawList::AddQuad	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f)
ImDrawList::AddQuad	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
ImDrawList::AddQuadFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
ImDrawList::AddQuadFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
ImDrawList::AddRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0, float thickness = 1.0f);   \/\/ a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0, float thickness = 1.0f)
ImDrawList::AddRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
ImDrawList::AddRectFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0);                     \/\/ a: upper-left, b: lower-right$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ~0)
ImDrawList::AddRectFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
ImDrawList::AddRectFilledMultiColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
ImDrawList::AddRectFilledMultiColor	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
ImDrawList::AddText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4* cpu_fine_clip_rect = NULL)
ImDrawList::AddText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL)
ImDrawList::AddText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList	signature:(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
ImDrawList::AddText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList	signature:(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
ImDrawList::AddTriangle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f)
ImDrawList::AddTriangle	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
ImDrawList::AddTriangleFilled	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
ImDrawList::AddTriangleFilled	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
ImDrawList::ChannelsMerge	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsMerge();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::ChannelsMerge	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsMerge()$/;"	f	class:ImDrawList	signature:()
ImDrawList::ChannelsSetCurrent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsSetCurrent(int channel_index);$/;"	p	struct:ImDrawList	access:public	signature:(int channel_index)
ImDrawList::ChannelsSetCurrent	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsSetCurrent(int idx)$/;"	f	class:ImDrawList	signature:(int idx)
ImDrawList::ChannelsSplit	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ChannelsSplit(int channels_count);$/;"	p	struct:ImDrawList	access:public	signature:(int channels_count)
ImDrawList::ChannelsSplit	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ChannelsSplit(int channels_count)$/;"	f	class:ImDrawList	signature:(int channels_count)
ImDrawList::Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  Clear();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList	signature:()
ImDrawList::ClearFreeMemory	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  ClearFreeMemory();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::ClearFreeMemory	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList	signature:()
ImDrawList::CmdBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Commands. Typically 1 command = 1 gpu draw call.$/;"	m	struct:ImDrawList	access:public
ImDrawList::IdxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList	access:public
ImDrawList::ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawList()  { _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList::PathArcTo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10)
ImDrawList::PathArcTo	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float amin, float amax, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, float amin, float amax, int num_segments)
ImDrawList::PathArcToFast	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                \/\/ Use precomputed angles for a 12 steps circle$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
ImDrawList::PathArcToFast	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int amin, int amax)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, int amin, int amax)
ImDrawList::PathBezierCurveTo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0)
ImDrawList::PathBezierCurveTo	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
ImDrawList::PathClear	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathClear()                                                 { _Path.resize(0); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawList::PathFillConvex	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col)
ImDrawList::PathLineTo	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos)
ImDrawList::PathLineToMergeDuplicate	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos)
ImDrawList::PathRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ~0);   \/\/ rounding_corners_flags: 4-bits corresponding to which corner to round$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ~0)
ImDrawList::PathRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
ImDrawList::PathStroke	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col, bool closed, float thickness = 1.0f)
ImDrawList::PopClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PopClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PopClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PopTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PopTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PopTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PrimQuadUV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
ImDrawList::PrimQuadUV	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
ImDrawList::PrimRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      \/\/ Axis aligned rectangle (composed of two triangles)$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col)
ImDrawList::PrimRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col)
ImDrawList::PrimRectUV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
ImDrawList::PrimRectUV	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
ImDrawList::PrimReserve	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);$/;"	p	struct:ImDrawList	access:public	signature:(int idx_count, int vtx_count)
ImDrawList::PrimReserve	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList	signature:(int idx_count, int vtx_count)
ImDrawList::PrimVtx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
ImDrawList::PrimWriteIdx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList	access:public	signature:(ImDrawIdx idx)
ImDrawList::PrimWriteVtx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
ImDrawList::PushClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  \/\/ Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)$/;"	p	struct:ImDrawList	access:public	signature:(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false)
ImDrawList::PushClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImDrawList	signature:(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
ImDrawList::PushClipRectFullScreen	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushClipRectFullScreen();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::PushClipRectFullScreen	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList	signature:()
ImDrawList::PushTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushTextureID(const ImTextureID& texture_id);$/;"	p	struct:ImDrawList	access:public	signature:(const ImTextureID& texture_id)
ImDrawList::PushTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushTextureID(const ImTextureID& texture_id)$/;"	f	class:ImDrawList	signature:(const ImTextureID& texture_id)
ImDrawList::UpdateClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  UpdateClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::UpdateClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList	signature:()
ImDrawList::UpdateTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  UpdateTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
ImDrawList::UpdateTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList	signature:()
ImDrawList::VtxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList	access:public
ImDrawList::_Channels	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawChannel> _Channels;          \/\/ [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_ChannelsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int                     _ChannelsCount;     \/\/ [Internal] number of active channels (1+)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_ChannelsCurrent	abstract-machine/libs/imgui/include/imgui.h	/^    int                     _ChannelsCurrent;   \/\/ [Internal] current channel number (0)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_ClipRectStack	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
ImDrawList::_IdxWritePtr	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
ImDrawList::_OwnerName	abstract-machine/libs/imgui/include/imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name for debugging$/;"	m	struct:ImDrawList	access:public
ImDrawList::_Path	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImVec2>        _Path;              \/\/ [Internal] current path building$/;"	m	struct:ImDrawList	access:public
ImDrawList::_TextureIdStack	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
ImDrawList::_VtxCurrentIdx	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] == VtxBuffer.Size$/;"	m	struct:ImDrawList	access:public
ImDrawList::_VtxWritePtr	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
ImDrawList::~ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList	access:public	signature:()
ImDrawVert	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawVert$/;"	s
ImDrawVert	abstract-machine/libs/imgui/include/imgui.h	/^struct ImDrawVert;                  \/\/ A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)$/;"	x
ImDrawVert::col	abstract-machine/libs/imgui/include/imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert	access:public
ImDrawVert::pos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert	access:public
ImDrawVert::uv	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert	access:public
ImFileLoadToMemory	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API void*         ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size = NULL, int padding_bytes = 0);$/;"	p	signature:(const char* filename, const char* file_open_mode, int* out_file_size = NULL, int padding_bytes = 0)
ImFileLoadToMemory	abstract-machine/libs/imgui/src/imgui.cpp	/^void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)$/;"	f	signature:(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)
ImFileOpen	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API FILE*         ImFileOpen(const char* filename, const char* file_open_mode);         $/;"	p	signature:(const char* filename, const char* file_open_mode)
ImFileOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^FILE* ImFileOpen(const char* filename, const char* mode)$/;"	f	signature:(const char* filename, const char* mode)
ImFloor	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 ImFloor(ImVec2 v)                                          { return ImVec2((float)(int)v.x, (float)(int)v.y); }$/;"	f	signature:(ImVec2 v)
ImFloor	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImFloor(float f)                                           { return (float)(int)f; }$/;"	f	signature:(float f)
ImFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFont	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFont$/;"	s
ImFont	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFont;                      \/\/ Runtime data for a single font within a parent ImFontAtlas$/;"	x
ImFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont	signature:()
ImFont::AddRemapChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); \/\/ Makes 'dst' character\/glyph points to 'src' character\/glyph. Currently needs to be called AFTER fonts have been built.$/;"	p	struct:ImFont	access:public	signature:(ImWchar dst, ImWchar src, bool overwrite_dst = true)
ImFont::AddRemapChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)$/;"	f	class:ImFont	signature:(ImWchar dst, ImWchar src, bool overwrite_dst)
ImFont::Ascent	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Ascent, Descent;    \/\/              \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
ImFont::BuildLookupTable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              BuildLookupTable();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::BuildLookupTable	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont	signature:()
ImFont::CalcTextSizeA	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; \/\/ utf8$/;"	p	struct:ImFont	access:public	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const
ImFont::CalcTextSizeA	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont	signature:(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
ImFont::CalcWordWrapPositionA	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*       CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;$/;"	p	struct:ImFont	access:public	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
ImFont::CalcWordWrapPositionA	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont	signature:(float scale, const char* text, const char* text_end, float wrap_width) const
ImFont::Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              Clear();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFont::Clear()$/;"	f	class:ImFont	signature:()
ImFont::ConfigData	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontConfig*               ConfigData;         \/\/              \/\/ Pointer within ContainerAtlas->ConfigData$/;"	m	struct:ImFont	access:public
ImFont::ConfigDataCount	abstract-machine/libs/imgui/include/imgui.h	/^    short                       ConfigDataCount;    \/\/ ~ 1          \/\/ Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.$/;"	m	struct:ImFont	access:public
ImFont::ContainerAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/              \/\/ What we has been loaded into$/;"	m	struct:ImFont	access:public
ImFont::Descent	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Ascent, Descent;    \/\/              \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont	access:public
ImFont::DisplayOffset	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ = (0.f,1.f)  \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont	access:public
ImFont::FallbackChar	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar                     FallbackChar;       \/\/ = '?'        \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont	access:public
ImFont::FallbackGlyph	abstract-machine/libs/imgui/include/imgui.h	/^    const Glyph*                FallbackGlyph;      \/\/ == FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont	access:public
ImFont::FallbackXAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    float                       FallbackXAdvance;   \/\/ == FallbackGlyph->XAdvance$/;"	m	struct:ImFont	access:public
ImFont::FindGlyph	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const Glyph*      FindGlyph(ImWchar c) const;$/;"	p	struct:ImFont	access:public	signature:(ImWchar c) const
ImFont::FindGlyph	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImFont::Glyph* ImFont::FindGlyph(unsigned short c) const$/;"	f	class:ImFont	signature:(unsigned short c) const
ImFont::FontSize	abstract-machine/libs/imgui/include/imgui.h	/^    float                       FontSize;           \/\/ <user set>   \/\/ Height of characters, set during loading (don't change after loading)$/;"	m	struct:ImFont	access:public
ImFont::GetCharAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexXAdvance.Size) ? IndexXAdvance[(int)c] : FallbackXAdvance; }$/;"	f	struct:ImFont	access:public	signature:(ImWchar c) const
ImFont::Glyph	abstract-machine/libs/imgui/include/imgui.h	/^    struct Glyph$/;"	s	struct:ImFont	access:public
ImFont::Glyph::Codepoint	abstract-machine/libs/imgui/include/imgui.h	/^        ImWchar                 Codepoint;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::U0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::U1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::V0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::V1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::X0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::X1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::XAdvance	abstract-machine/libs/imgui/include/imgui.h	/^        float                   XAdvance;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::Y0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyph::Y1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
ImFont::Glyphs	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<Glyph>             Glyphs;             \/\/              \/\/ All glyphs.$/;"	m	struct:ImFont	access:public
ImFont::GrowIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GrowIndex(int new_size);$/;"	p	struct:ImFont	access:public	signature:(int new_size)
ImFont::GrowIndex	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::GrowIndex(int new_size)$/;"	f	class:ImFont	signature:(int new_size)
ImFont::ImFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::ImFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont	signature:()
ImFont::IndexLookup	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<unsigned short>    IndexLookup;        \/\/              \/\/ Sparse. Index glyphs by Unicode code-point.$/;"	m	struct:ImFont	access:public
ImFont::IndexXAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<float>             IndexXAdvance;      \/\/              \/\/ Sparse. Glyphs->XAdvance in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).$/;"	m	struct:ImFont	access:public
ImFont::IsLoaded	abstract-machine/libs/imgui/include/imgui.h	/^    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont	access:public	signature:() const
ImFont::MetricsTotalSurface	abstract-machine/libs/imgui/include/imgui.h	/^    int                         MetricsTotalSurface;\/\/              \/\/ Total surface in pixels to get an idea of the font rasterization\/texture cost (not exact, we approximate the cost of padding between glyphs)$/;"	m	struct:ImFont	access:public
ImFont::RenderChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;$/;"	p	struct:ImFont	access:public	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const
ImFont::RenderChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const$/;"	f	class:ImFont	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const
ImFont::RenderText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;$/;"	p	struct:ImFont	access:public	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const
ImFont::RenderText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
ImFont::Scale	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Scale;              \/\/ = 1.f        \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()$/;"	m	struct:ImFont	access:public
ImFont::SetFallbackChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              SetFallbackChar(ImWchar c);$/;"	p	struct:ImFont	access:public	signature:(ImWchar c)
ImFont::SetFallbackChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont	signature:(ImWchar c)
ImFont::~ImFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ~ImFont();$/;"	p	struct:ImFont	access:public	signature:()
ImFont::~ImFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont	signature:()
ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFontAtlas$/;"	s
ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFontAtlas;                 \/\/ Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF font loader$/;"	x
ImFontAtlas	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::AddFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFont(const ImFontConfig* font_cfg);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg)
ImFontAtlas::AddFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg)
ImFontAtlas::AddFontDefault	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontDefault(const ImFontConfig* font_cfg = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const ImFontConfig* font_cfg = NULL)
ImFontAtlas::AddFontDefault	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas	signature:(const ImFontConfig* font_cfg_template)
ImFontAtlas::AddFontFromFileTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromFileTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryCompressedBase85TTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              \/\/ 'compressed_ttf_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 paramaeter$/;"	p	struct:ImFontAtlas	access:public	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryCompressedBase85TTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryCompressedTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);  \/\/ 'compressed_ttf_data' still owned by caller. Compress with binary_to_compressed_c.cpp$/;"	p	struct:ImFontAtlas	access:public	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryCompressedTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::AddFontFromMemoryTTF	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*           AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);                                        \/\/ Transfer ownership of 'ttf_data' to ImFontAtlas, will be deleted after Build()$/;"	p	struct:ImFontAtlas	access:public	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL)
ImFontAtlas::AddFontFromMemoryTTF	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas	signature:(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
ImFontAtlas::Build	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool              Build();            \/\/ Build pixels data. This is automatically for you by the GetTexData*** functions.$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::Build	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              Clear();                    \/\/ Clear all$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::Clear	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearFonts	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearFonts();               \/\/ Clear the ImGui-side font data (glyphs storage, UV coordinates)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearFonts	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearInputData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearInputData();           \/\/ Clear the input TTF data (inc sizes, glyph ranges)$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearInputData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ClearTexData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              ClearTexData();             \/\/ Clear the CPU-side texture data. Saves RAM once the texture has been copied to graphics memory.$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ClearTexData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::ConfigData	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::Fonts	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImFont*>           Fonts;              \/\/ Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()\/PopFont() to change the current font.$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::GetGlyphRangesChinese	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesChinese();    \/\/ Japanese + full set of about 21000 CJK Unified Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesChinese	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChinese()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesCyrillic	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesCyrillic();   \/\/ Default + about 400 Cyrillic characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesCyrillic	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesDefault	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesDefault();    \/\/ Basic Latin, Extended Latin$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesDefault	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesJapanese	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesJapanese();   \/\/ Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesJapanese	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesKorean	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesKorean();     \/\/ Default + Korean characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesKorean	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetGlyphRangesThai	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const ImWchar*    GetGlyphRangesThai();       \/\/ Default + Thai characters$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::GetGlyphRangesThai	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesThai()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::GetTexDataAsAlpha8	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 1 byte per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
ImFontAtlas::GetTexDataAsAlpha8	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
ImFontAtlas::GetTexDataAsRGBA32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  \/\/ 4 bytes-per-pixel$/;"	p	struct:ImFontAtlas	access:public	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL)
ImFontAtlas::GetTexDataAsRGBA32	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas	signature:(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
ImFontAtlas::ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::ImFontAtlas	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontAtlas::RenderCustomTexData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderCustomTexData(int pass, void* rects);$/;"	p	struct:ImFontAtlas	access:public	signature:(int pass, void* rects)
ImFontAtlas::RenderCustomTexData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFontAtlas::RenderCustomTexData(int pass, void* p_rects)$/;"	f	class:ImFontAtlas	signature:(int pass, void* p_rects)
ImFontAtlas::SetTexID	abstract-machine/libs/imgui/include/imgui.h	/^    void                        SetTexID(void* id)  { TexID = id; }$/;"	f	struct:ImFontAtlas	access:public	signature:(void* id)
ImFontAtlas::TexDesiredWidth	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexDesiredWidth;    \/\/ Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexHeight	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexHeight;          \/\/ Texture height calculated during Build().$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexID	abstract-machine/libs/imgui/include/imgui.h	/^    void*                       TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It ia passed back to you during rendering.$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexPixelsAlpha8	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexPixelsRGBA32	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexUvWhitePixel	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::TexWidth	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexWidth;           \/\/ Texture width calculated during Build().$/;"	m	struct:ImFontAtlas	access:public
ImFontAtlas::~ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ~ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
ImFontAtlas::~ImFontAtlas	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
ImFontConfig	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFontConfig();$/;"	p	struct:ImFontConfig	access:public	signature:()
ImFontConfig	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFontConfig$/;"	s
ImFontConfig	abstract-machine/libs/imgui/include/imgui.h	/^struct ImFontConfig;                \/\/ Configuration data when adding a font or merging fonts$/;"	x
ImFontConfig	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig	signature:()
ImFontConfig::DstFont	abstract-machine/libs/imgui/include/imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontData	abstract-machine/libs/imgui/include/imgui.h	/^    void*           FontData;                   \/\/          \/\/ TTF data$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontDataOwnedByAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    bool            FontDataOwnedByAtlas;       \/\/ true     \/\/ TTF data ownership taken by the container ImFontAtlas (will delete memory itself). Set to true$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontDataSize	abstract-machine/libs/imgui/include/imgui.h	/^    int             FontDataSize;               \/\/          \/\/ TTF data size$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::FontNo	abstract-machine/libs/imgui/include/imgui.h	/^    int             FontNo;                     \/\/ 0        \/\/ Index of font within TTF file$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::GlyphExtraSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2          GlyphExtraSpacing;          \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::GlyphOffset	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2          GlyphOffset;                \/\/ 0, 0     \/\/ Offset all glyphs from this font input$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::GlyphRanges	abstract-machine/libs/imgui/include/imgui.h	/^    const ImWchar*  GlyphRanges;                \/\/          \/\/ Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::ImFontConfig	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFontConfig();$/;"	p	struct:ImFontConfig	access:public	signature:()
ImFontConfig::ImFontConfig	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig	signature:()
ImFontConfig::MergeMode	abstract-machine/libs/imgui/include/imgui.h	/^    bool            MergeMode;                  \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::Name	abstract-machine/libs/imgui/include/imgui.h	/^    char            Name[32];                               \/\/ Name (strictly for debugging)$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::OversampleH	abstract-machine/libs/imgui/include/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::OversampleV	abstract-machine/libs/imgui/include/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::PixelSnapH	abstract-machine/libs/imgui/include/imgui.h	/^    bool            PixelSnapH;                 \/\/ false    \/\/ Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH\/V to 1.$/;"	m	struct:ImFontConfig	access:public
ImFontConfig::SizePixels	abstract-machine/libs/imgui/include/imgui.h	/^    float           SizePixels;                 \/\/          \/\/ Size in pixels for rasterizer$/;"	m	struct:ImFontConfig	access:public
ImFormatString	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImFormatString(char* buf, int buf_size, const char* fmt, ...)$/;"	f	signature:(char* buf, int buf_size, const char* fmt, ...)
ImFormatStringV	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args);$/;"	p	signature:(char* buf, int buf_size, const char* fmt, va_list args)
ImFormatStringV	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImFormatStringV(char* buf, int buf_size, const char* fmt, va_list args)$/;"	f	signature:(char* buf, int buf_size, const char* fmt, va_list args)
ImGui	abstract-machine/libs/imgui/include/imgui.h	/^namespace ImGui$/;"	n
ImGui	abstract-machine/libs/imgui/include/imgui_internal.h	/^namespace ImGui$/;"	n
ImGui::AlignFirstTextHeightToWidgets	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          AlignFirstTextHeightToWidgets();                                    \/\/ call once if the first item on the line is a Text() item and you want to vertically lower it to match subsequent (bigger) widgets$/;"	p	namespace:ImGui	signature:()
ImGui::AlignFirstTextHeightToWidgets	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::AlignFirstTextHeightToWidgets()$/;"	f	class:ImGui	signature:()
ImGui::Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                                                   \/\/ push window to the stack and start appending to it. see .cpp for details. return false when window is collapsed, so you can early out in your code. 'bool* p_open' creates a widget on the upper-right to close the window (which sets your bool to false).$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0)
ImGui::Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0); \/\/ OBSOLETE. this is the older\/longer API. the extra parameters aren't very relevant. call SetNextWindowSize() instead if you want to set a window size. For regular windows, 'size_on_first_use' only applies to the first time EVER the window is created and probably not what you want! might obsolete this API eventually.$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha = -1.0f, ImGuiWindowFlags flags = 0)
ImGui::Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, ImGuiWindowFlags flags)
ImGui::Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha, ImGuiWindowFlags flags)
ImGui::BeginChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);            \/\/ "$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0);    \/\/ begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size = ImVec2(0,0), bool border = false, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginChild	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
ImGui::BeginChild	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
ImGui::BeginChildFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0);	\/\/ helper to create a child window \/ scrolling region that looks like a normal widget frame$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginChildFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
ImGui::BeginGroup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BeginGroup();                                                       \/\/ lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)$/;"	p	namespace:ImGui	signature:()
ImGui::BeginGroup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui	signature:()
ImGui::BeginMainMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMainMenuBar();                                                 \/\/ create and append to a full screen menu-bar. only call EndMainMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
ImGui::BeginMainMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::BeginMenu	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  \/\/ create a sub-menu entry. only call EndMenu() if this returns true!$/;"	p	namespace:ImGui	signature:(const char* label, bool enabled = true)
ImGui::BeginMenu	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, bool enabled)
ImGui::BeginMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginMenuBar();                                                     \/\/ append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set). only call EndMenuBar() if this returns true!$/;"	p	namespace:ImGui	signature:()
ImGui::BeginMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::BeginPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopup(const char* str_id);                                     \/\/ return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returned true!$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::BeginPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::BeginPopupContextItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextItem(const char* str_id, int mouse_button = 1);                                        \/\/ helper to open and begin popup when clicked on last item. read comments in .cpp!$/;"	p	namespace:ImGui	signature:(const char* str_id, int mouse_button = 1)
ImGui::BeginPopupContextItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
ImGui::BeginPopupContextVoid	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 \/\/ helper to open and begin popup when clicked in void (no window).$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL, int mouse_button = 1)
ImGui::BeginPopupContextVoid	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(const char* str_id, int mouse_button)
ImGui::BeginPopupContextWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupContextWindow(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1);  \/\/ helper to open and begin popup when clicked on current window.$/;"	p	namespace:ImGui	signature:(bool also_over_items = true, const char* str_id = NULL, int mouse_button = 1)
ImGui::BeginPopupContextWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupContextWindow(bool also_over_items, const char* str_id, int mouse_button)$/;"	f	class:ImGui	signature:(bool also_over_items, const char* str_id, int mouse_button)
ImGui::BeginPopupModal	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0);               \/\/ modal dialog (block interactions behind the modal window, can't close the modal window by clicking outside)$/;"	p	namespace:ImGui	signature:(const char* name, bool* p_open = NULL, ImGuiWindowFlags extra_flags = 0)
ImGui::BeginPopupModal	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* name, bool* p_open, ImGuiWindowFlags extra_flags)
ImGui::BeginTooltip	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BeginTooltip();                                                     \/\/ use to create full-featured tooltip windows that aren't just text$/;"	p	namespace:ImGui	signature:()
ImGui::BeginTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui	signature:()
ImGui::Bullet	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Bullet();                                                               \/\/ draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses$/;"	p	namespace:ImGui	signature:()
ImGui::Bullet	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui	signature:()
ImGui::BulletText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::BulletTextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          BulletTextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::BulletTextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::Button	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0,0));            \/\/ button$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ImGui::Button	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ImGui::ButtonBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0)
ImGui::ButtonBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)$/;"	f	class:ImGui	signature:(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
ImGui::ButtonEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size_arg = ImVec2(0,0), ImGuiButtonFlags flags = 0)
ImGui::ButtonEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
ImGui::CalcItemRectClosestPoint	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = +0.0f);   \/\/ utility to find the closest point the last item bounding rectangle edge. useful to visually link items$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, bool on_edge = false, float outward = +0.0f)
ImGui::CalcItemRectClosestPoint	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge, float outward)$/;"	f	class:ImGui	signature:(const ImVec2& pos, bool on_edge, float outward)
ImGui::CalcItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);$/;"	p	namespace:ImGui	signature:(ImVec2 size, float default_x, float default_y)
ImGui::CalcItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)$/;"	f	class:ImGui	signature:(ImVec2 size, float default_x, float default_y)
ImGui::CalcItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         CalcItemWidth();                                                    \/\/ width of item given pushed settings and current cursor position$/;"	p	namespace:ImGui	signature:()
ImGui::CalcItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui	signature:()
ImGui::CalcListClipping	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    \/\/ calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.$/;"	p	namespace:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
ImGui::CalcListClipping	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui	signature:(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
ImGui::CalcTextSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f)
ImGui::CalcTextSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
ImGui::CalcWrapWidthForPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, float wrap_pos_x)
ImGui::CalcWrapWidthForPos	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	class:ImGui	signature:(const ImVec2& pos, float wrap_pos_x)
ImGui::CaptureKeyboardFromApp	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        \/\/ manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application handle). e.g. force capture keyboard when your widget is being hovered.$/;"	p	namespace:ImGui	signature:(bool capture = true)
ImGui::CaptureKeyboardFromApp	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CaptureKeyboardFromApp(bool capture)$/;"	f	class:ImGui	signature:(bool capture)
ImGui::CaptureMouseFromApp	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           \/\/ manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application handle).$/;"	p	namespace:ImGui	signature:(bool capture = true)
ImGui::CaptureMouseFromApp	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CaptureMouseFromApp(bool capture)$/;"	f	class:ImGui	signature:(bool capture)
ImGui::Checkbox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Checkbox(const char* label, bool* v);$/;"	p	namespace:ImGui	signature:(const char* label, bool* v)
ImGui::Checkbox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui	signature:(const char* label, bool* v)
ImGui::CheckboxFlags	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);$/;"	p	namespace:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ImGui::CheckboxFlags	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui	signature:(const char* label, unsigned int* flags, unsigned int flags_value)
ImGui::ClearActiveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^	IMGUI_API void          ClearActiveID();$/;"	p	namespace:ImGui	signature:()
ImGui::ClearActiveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ClearActiveID()$/;"	f	class:ImGui	signature:()
ImGui::CloseButton	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);$/;"	p	namespace:ImGui	signature:(ImGuiID id, const ImVec2& pos, float radius)
ImGui::CloseButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)$/;"	f	class:ImGui	signature:(ImGuiID id, const ImVec2& pos, float radius)
ImGui::CloseCurrentPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          CloseCurrentPopup();                                                \/\/ close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.$/;"	p	namespace:ImGui	signature:()
ImGui::CloseCurrentPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui	signature:()
ImGui::CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);      \/\/ if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags = 0)
ImGui::CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); \/\/ when 'p_open' isn't NULL, display an additional small close button on upper right of the header$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0)
ImGui::CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1<<5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); } \/\/ OBSOLETE 1.49+$/;"	f	namespace:ImGui	signature:(const char* label, const char* str_id, bool framed = true, bool default_open = false)
ImGui::CollapsingHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags)
ImGui::CollapsingHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
ImGui::ColorButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorButton(const ImVec4& col, bool small_height = false, bool outline_border = true);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, bool small_height = false, bool outline_border = true)
ImGui::ColorButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorButton(const ImVec4& col, bool small_height, bool outline_border)$/;"	f	class:ImGui	signature:(const ImVec4& col, bool small_height, bool outline_border)
ImGui::ColorConvertFloat4ToU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);$/;"	p	namespace:ImGui	signature:(const ImVec4& in)
ImGui::ColorConvertFloat4ToU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui	signature:(const ImVec4& in)
ImGui::ColorConvertHSVtoRGB	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);$/;"	p	namespace:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ImGui::ColorConvertHSVtoRGB	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui	signature:(float h, float s, float v, float& out_r, float& out_g, float& out_b)
ImGui::ColorConvertRGBtoHSV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);$/;"	p	namespace:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ImGui::ColorConvertRGBtoHSV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui	signature:(float r, float g, float b, float& out_h, float& out_s, float& out_v)
ImGui::ColorConvertU32ToFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);$/;"	p	namespace:ImGui	signature:(ImU32 in)
ImGui::ColorConvertU32ToFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)$/;"	f	class:ImGui	signature:(ImU32 in)
ImGui::ColorEdit3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorEdit3(const char* label, float col[3]);                            \/\/ Hint: 'float col[3]' function argument is same as 'float* col'. You can pass address of first element out of a contiguous set, e.g. &myvector.x$/;"	p	namespace:ImGui	signature:(const char* label, float col[3])
ImGui::ColorEdit3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3])$/;"	f	class:ImGui	signature:(const char* label, float col[3])
ImGui::ColorEdit4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ColorEdit4(const char* label, float col[4], bool show_alpha = true);    \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, float col[4], bool show_alpha = true)
ImGui::ColorEdit4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], bool alpha)$/;"	f	class:ImGui	signature:(const char* label, float col[4], bool alpha)
ImGui::ColorEditMode	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ColorEditMode(ImGuiColorEditMode mode);                                 \/\/ FIXME-OBSOLETE: This is inconsistent with most of the API and will be obsoleted\/replaced.$/;"	p	namespace:ImGui	signature:(ImGuiColorEditMode mode)
ImGui::ColorEditMode	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ColorEditMode(ImGuiColorEditMode mode)$/;"	f	class:ImGui	signature:(ImGuiColorEditMode mode)
ImGui::Columns	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);  \/\/ setup number of columns. use an identifier to distinguish multiple column sets. close with Columns(1).$/;"	p	namespace:ImGui	signature:(int count = 1, const char* id = NULL, bool border = true)
ImGui::Columns	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui	signature:(int columns_count, const char* id, bool border)
ImGui::Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ImGui::Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1)
ImGui::Combo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1);      \/\/ separate items with \\0, end item-list with \\0\\0$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items = -1)
ImGui::Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ImGui::Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items)
ImGui::Combo	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
ImGui::CreateContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiContext* CreateContext(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL);$/;"	p	namespace:ImGui	signature:(void* (*malloc_fn)(size_t) = NULL, void (*free_fn)(void*) = NULL)
ImGui::CreateContext	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiContext* ImGui::CreateContext(void* (*malloc_fn)(size_t), void (*free_fn)(void*))$/;"	f	class:ImGui	signature:(void* (*malloc_fn)(size_t), void (*free_fn)(void*))
ImGui::DestroyContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          DestroyContext(ImGuiContext* ctx);$/;"	p	namespace:ImGui	signature:(ImGuiContext* ctx)
ImGui::DestroyContext	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::DestroyContext(ImGuiContext* ctx)$/;"	f	class:ImGui	signature:(ImGuiContext* ctx)
ImGui::DragBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power);$/;"	p	namespace:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
ImGui::DragBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)$/;"	f	class:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
ImGui::DragFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
ImGui::DragFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
ImGui::DragFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
ImGui::DragFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , float power = 1.0f)
ImGui::DragFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
ImGui::DragFloatRange2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = , const char* display_format_max = NULL, float power = 1.0f)
ImGui::DragFloatRange2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
ImGui::DragInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       \/\/ If v_min >= v_max we have no bound$/;"	p	namespace:ImGui	signature:(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
ImGui::DragInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
ImGui::DragInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
ImGui::DragInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = )
ImGui::DragInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
ImGui::DragIntRange2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = , const char* display_format_max = NULL)
ImGui::DragIntRange2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)$/;"	f	class:ImGui	signature:(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
ImGui::Dummy	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Dummy(const ImVec2& size);                                          \/\/ add a dummy item of given size$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ImGui::Dummy	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
ImGui::End	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          End();                                                                                                                      \/\/ finish appending to current window, pop it off the window stack.$/;"	p	namespace:ImGui	signature:()
ImGui::End	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui	signature:()
ImGui::EndChild	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndChild();$/;"	p	namespace:ImGui	signature:()
ImGui::EndChild	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui	signature:()
ImGui::EndChildFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndChildFrame();$/;"	p	namespace:ImGui	signature:()
ImGui::EndChildFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui	signature:()
ImGui::EndFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          EndFrame();                 \/\/ Ends the ImGui frame. Automatically called by Render()! you most likely don't need to ever call that yourself directly. If you don't need to render you can call EndFrame() but you'll have wasted CPU already. If you don't need to render, don't create any windows instead!$/;"	p	namespace:ImGui	signature:()
ImGui::EndFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndFrame()$/;"	f	class:ImGui	signature:()
ImGui::EndGroup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndGroup();$/;"	p	namespace:ImGui	signature:()
ImGui::EndGroup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui	signature:()
ImGui::EndMainMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMainMenuBar();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMainMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::EndMenu	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMenu();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMenu	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui	signature:()
ImGui::EndMenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndMenuBar();$/;"	p	namespace:ImGui	signature:()
ImGui::EndMenuBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui	signature:()
ImGui::EndPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndPopup();$/;"	p	namespace:ImGui	signature:()
ImGui::EndPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui	signature:()
ImGui::EndTooltip	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          EndTooltip();$/;"	p	namespace:ImGui	signature:()
ImGui::EndTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui	signature:()
ImGui::FindRenderedTextEnd	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API const char*   FindRenderedTextEnd(const char* text, const char* text_end = NULL); \/\/ Find the optional ## from which we stop displaying text.$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
ImGui::FindRenderedTextEnd	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
ImGui::FindWindowByName	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImGuiWindow*  FindWindowByName(const char* name);$/;"	p	namespace:ImGui	signature:(const char* name)
ImGui::FindWindowByName	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByName(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
ImGui::FocusWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          FocusWindow(ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window)
ImGui::FocusWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::FocusWindow(ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiWindow* window)
ImGui::FocusableItemRegister	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop = true);      \/\/ Return true if focus is requested$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window, bool is_active, bool tab_stop = true)
ImGui::FocusableItemRegister	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::FocusableItemRegister(ImGuiWindow* window, bool is_active, bool tab_stop)$/;"	f	class:ImGui	signature:(ImGuiWindow* window, bool is_active, bool tab_stop)
ImGui::FocusableItemUnregister	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiWindow* window)
ImGui::FocusableItemUnregister	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::FocusableItemUnregister(ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiWindow* window)
ImGui::GetClipboardText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetClipboardText();$/;"	p	namespace:ImGui	signature:()
ImGui::GetClipboardText	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetClipboardText()$/;"	f	class:ImGui	signature:()
ImGui::GetColorU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);                  \/\/ retrieve given style color with style alpha applied and optional extra alpha multiplier$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, float alpha_mul = 1.0f)
ImGui::GetColorU32	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImU32         GetColorU32(const ImVec4& col);                                     \/\/ retrieve given color with style alpha applied$/;"	p	namespace:ImGui	signature:(const ImVec4& col)
ImGui::GetColorU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)  $/;"	f	class:ImGui	signature:(ImGuiCol idx, float alpha_mul)
ImGui::GetColorU32	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImGui::GetColorU32(const ImVec4& col)$/;"	f	class:ImGui	signature:(const ImVec4& col)
ImGui::GetColumnIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetColumnIndex();                                                   \/\/ get current column index$/;"	p	namespace:ImGui	signature:()
ImGui::GetColumnIndex	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui	signature:()
ImGui::GetColumnOffset	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetColumnOffset(int column_index = -1);                             \/\/ get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetcolumnsCount() inclusive. column 0 is usually 0.0f and not resizable unless you call this$/;"	p	namespace:ImGui	signature:(int column_index = -1)
ImGui::GetColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
ImGui::GetColumnWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetColumnWidth(int column_index = -1);                              \/\/ column width (== GetColumnOffset(GetColumnIndex()+1) - GetColumnOffset(GetColumnOffset())$/;"	p	namespace:ImGui	signature:(int column_index = -1)
ImGui::GetColumnWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui	signature:(int column_index)
ImGui::GetColumnsCount	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetColumnsCount();                                                  \/\/ number of columns (what was passed to Columns())$/;"	p	namespace:ImGui	signature:()
ImGui::GetColumnsCount	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui	signature:()
ImGui::GetContentRegionAvail	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionAvail();                                            \/\/ == GetContentRegionMax() - GetCursorPos()$/;"	p	namespace:ImGui	signature:()
ImGui::GetContentRegionAvail	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetContentRegionAvail()$/;"	f	class:ImGui	signature:()
ImGui::GetContentRegionAvailWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetContentRegionAvailWidth();                                       \/\/$/;"	p	namespace:ImGui	signature:()
ImGui::GetContentRegionAvailWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetContentRegionAvailWidth()$/;"	f	class:ImGui	signature:()
ImGui::GetContentRegionMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetContentRegionMax();                                              \/\/ current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates$/;"	p	namespace:ImGui	signature:()
ImGui::GetContentRegionMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui	signature:()
ImGui::GetCurrentContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiContext* GetCurrentContext();$/;"	p	namespace:ImGui	signature:()
ImGui::GetCurrentContext	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiContext* ImGui::GetCurrentContext()$/;"	f	class:ImGui	signature:()
ImGui::GetCurrentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->Accessed = true; return g.CurrentWindow; }$/;"	f	namespace:ImGui	signature:()
ImGui::GetCurrentWindowRead	abstract-machine/libs/imgui/include/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }$/;"	f	namespace:ImGui	signature:()
ImGui::GetCursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorPos();                                                     \/\/ cursor position is relative to window position$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorPosX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetCursorPosX();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPosX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetCursorPosY();                                                    \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorScreenPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorScreenPos();                                               \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorScreenPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui	signature:()
ImGui::GetCursorStartPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetCursorStartPos();                                                \/\/ initial cursor position$/;"	p	namespace:ImGui	signature:()
ImGui::GetCursorStartPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui	signature:()
ImGui::GetDrawData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImDrawData*   GetDrawData();                              \/\/ same value as passed to your io.RenderDrawListsFn() function. valid after Render() and until the next call to NewFrame()$/;"	p	namespace:ImGui	signature:()
ImGui::GetDrawData	abstract-machine/libs/imgui/src/imgui.cpp	/^ImDrawData* ImGui::GetDrawData()$/;"	f	class:ImGui	signature:()
ImGui::GetFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImFont*       GetFont();                                                          \/\/ get current font$/;"	p	namespace:ImGui	signature:()
ImGui::GetFont	abstract-machine/libs/imgui/src/imgui.cpp	/^ImFont* ImGui::GetFont()$/;"	f	class:ImGui	signature:()
ImGui::GetFontSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetFontSize();                                                      \/\/ get current font size (= height in pixels) of current font with current scale applied$/;"	p	namespace:ImGui	signature:()
ImGui::GetFontSize	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetFontSize()$/;"	f	class:ImGui	signature:()
ImGui::GetFontTexUvWhitePixel	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                           \/\/ get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API$/;"	p	namespace:ImGui	signature:()
ImGui::GetFontTexUvWhitePixel	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetFontTexUvWhitePixel()$/;"	f	class:ImGui	signature:()
ImGui::GetFrameCount	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetFrameCount();$/;"	p	namespace:ImGui	signature:()
ImGui::GetFrameCount	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui	signature:()
ImGui::GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id);                                          \/\/ calculate unique ID (hash of whole ID stack + given parameter). useful if you want to query into ImGuiStorage yourself. otherwise rarely needed$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::GetID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiID       GetID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
ImGui::GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::GetIO	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiIO&      GetIO();$/;"	p	namespace:ImGui	signature:()
ImGui::GetIO	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMax();                                                   \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemRectMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectMin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectMin();                                                   \/\/ get bounding rect of last item in screen space$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemRectMin	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui	signature:()
ImGui::GetItemRectSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetItemRectSize();                                                  \/\/ "$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemRectSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui	signature:()
ImGui::GetItemsLineHeightWithSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetItemsLineHeightWithSpacing();                                    \/\/ distance (in pixels) between 2 consecutive lines of standard height widgets == GetWindowFontSize() + GetStyle().FramePadding.y*2 + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
ImGui::GetItemsLineHeightWithSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetItemsLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
ImGui::GetKeyIndex	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    \/\/ map ImGuiKey_* values into user's key index. == io.KeyMap[key]$/;"	p	namespace:ImGui	signature:(ImGuiKey imgui_key)
ImGui::GetKeyIndex	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey imgui_key)$/;"	f	class:ImGui	signature:(ImGuiKey imgui_key)
ImGui::GetMouseCursor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                \/\/ get desired cursor type, reset in ImGui::NewFrame(), this updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you$/;"	p	namespace:ImGui	signature:()
ImGui::GetMouseCursor	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui	signature:()
ImGui::GetMouseDragDelta	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    \/\/ dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
ImGui::GetMouseDragDelta	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
ImGui::GetMousePos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMousePos();                                                      \/\/ shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls$/;"	p	namespace:ImGui	signature:()
ImGui::GetMousePos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui	signature:()
ImGui::GetMousePosOnOpeningCurrentPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 \/\/ retrieve backup of mouse positioning at the time of opening popup we have BeginPopup() into$/;"	p	namespace:ImGui	signature:()
ImGui::GetMousePosOnOpeningCurrentPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()$/;"	f	class:ImGui	signature:()
ImGui::GetParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API ImGuiWindow*  GetParentWindow();$/;"	p	namespace:ImGui	signature:()
ImGui::GetParentWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow* ImGui::GetParentWindow()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollMaxX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollMaxX();                                                    \/\/ get maximum scrolling amount ~~ ContentSize.X - WindowSize.X$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollMaxX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollMaxX()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollMaxY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollMaxY();                                                    \/\/ get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollMaxY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollX();                                                       \/\/ get scrolling amount [0..GetScrollMaxX()]$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollX	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollX()$/;"	f	class:ImGui	signature:()
ImGui::GetScrollY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetScrollY();                                                       \/\/ get scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:()
ImGui::GetScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui	signature:()
ImGui::GetStateStorage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStorage* GetStateStorage();$/;"	p	namespace:ImGui	signature:()
ImGui::GetStateStorage	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui	signature:()
ImGui::GetStyle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStyle&   GetStyle();$/;"	p	namespace:ImGui	signature:()
ImGui::GetStyle	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui	signature:()
ImGui::GetStyleColName	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetStyleColName(ImGuiCol idx);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx)
ImGui::GetStyleColName	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetStyleColName(ImGuiCol idx)$/;"	f	class:ImGui	signature:(ImGuiCol idx)
ImGui::GetTextLineHeight	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTextLineHeight();                                                \/\/ height of font == GetWindowFontSize()$/;"	p	namespace:ImGui	signature:()
ImGui::GetTextLineHeight	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui	signature:()
ImGui::GetTextLineHeightWithSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTextLineHeightWithSpacing();                                     \/\/ distance (in pixels) between 2 consecutive lines of text == GetWindowFontSize() + GetStyle().ItemSpacing.y$/;"	p	namespace:ImGui	signature:()
ImGui::GetTextLineHeightWithSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui	signature:()
ImGui::GetTime	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTime();$/;"	p	namespace:ImGui	signature:()
ImGui::GetTime	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTime()$/;"	f	class:ImGui	signature:()
ImGui::GetTreeNodeToLabelSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetTreeNodeToLabelSpacing();                                            \/\/ horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode$/;"	p	namespace:ImGui	signature:()
ImGui::GetTreeNodeToLabelSpacing	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetTreeNodeToLabelSpacing()$/;"	f	class:ImGui	signature:()
ImGui::GetVersion	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API const char*   GetVersion();$/;"	p	namespace:ImGui	signature:()
ImGui::GetVersion	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      GetWindowCollapsed() { return ImGui::IsWindowCollapsed(); }        \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionMax	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMax();                                        \/\/ content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionMax	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowContentRegionMin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowContentRegionMin();                                        \/\/ content boundaries min (roughly (0,0)-Scroll), in window coordinates$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionMin	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowContentRegionWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowContentRegionWidth();                                      \/\/$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowContentRegionWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowContentRegionWidth()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImDrawList*   GetWindowDrawList();                                                \/\/ get rendering command-list if you want to append your own draw primitives$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowDrawList	abstract-machine/libs/imgui/src/imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowFont	abstract-machine/libs/imgui/include/imgui.h	/^    static inline ImFont*   GetWindowFont() { return GetFont(); }                              \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui	signature:()
ImGui::GetWindowFontSize	abstract-machine/libs/imgui/include/imgui.h	/^    static inline float     GetWindowFontSize() { return GetFontSize(); }                      \/\/ OBSOLETE 1.48+$/;"	f	namespace:ImGui	signature:()
ImGui::GetWindowHeight	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowHeight();$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowHeight	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowHeight()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowPos();                                                     \/\/ get current window position in screen space (useful if you want to do your own drawing via the DrawList api)$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImVec2        GetWindowSize();                                                    \/\/ get current window size$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui	signature:()
ImGui::GetWindowWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float         GetWindowWidth();$/;"	p	namespace:ImGui	signature:()
ImGui::GetWindowWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui	signature:()
ImGui::Image	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0))
ImGui::Image	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
ImGui::ImageButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    \/\/ <0 frame_padding uses default frame padding settings. 0 for no padding$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1))
ImGui::ImageButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
ImGui::Indent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Indent(float indent_w = 0.0f);                                      \/\/ move content position toward the right, by style.IndentSpacing or indent_w if >0$/;"	p	namespace:ImGui	signature:(float indent_w = 0.0f)
ImGui::Indent	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Indent(float indent_w)$/;"	f	class:ImGui	signature:(float indent_w)
ImGui::InputFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
ImGui::InputInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
ImGui::InputInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
ImGui::InputInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
ImGui::InputInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0)
ImGui::InputInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
ImGui::InputIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
ImGui::InputIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
ImGui::InputScalarAsWidgetReplacement	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision);$/;"	p	namespace:ImGui	signature:(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
ImGui::InputScalarAsWidgetReplacement	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)$/;"	f	class:ImGui	signature:(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
ImGui::InputScalarEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
ImGui::InputScalarEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
ImGui::InputText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
ImGui::InputText	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
ImGui::InputTextEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
ImGui::InputTextEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
ImGui::InputTextMultiline	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
ImGui::InputTextMultiline	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
ImGui::InvisibleButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size)
ImGui::InvisibleButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg)
ImGui::IsAnyItemActive	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsAnyItemActive();$/;"	p	namespace:ImGui	signature:()
ImGui::IsAnyItemActive	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui	signature:()
ImGui::IsAnyItemHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsAnyItemHovered();$/;"	p	namespace:ImGui	signature:()
ImGui::IsAnyItemHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsClippedEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
ImGui::IsClippedEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)$/;"	f	class:ImGui	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
ImGui::IsHovered	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs = false);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, ImGuiID id, bool flatten_childs = false)
ImGui::IsHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs)$/;"	f	class:ImGui	signature:(const ImRect& bb, ImGuiID id, bool flatten_childs)
ImGui::IsItemActive	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemActive();                                                     \/\/ was the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemActive	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui	signature:()
ImGui::IsItemClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                \/\/ was the last item clicked? (e.g. button\/node just clicked on)$/;"	p	namespace:ImGui	signature:(int mouse_button = 0)
ImGui::IsItemClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemClicked(int mouse_button)$/;"	f	class:ImGui	signature:(int mouse_button)
ImGui::IsItemHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemHovered();                                                    \/\/ was the last item hovered by mouse?$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsItemHoveredRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemHoveredRect();                                                \/\/ was the last item hovered by mouse? even if another item is active or window is blocked by popup while we are hovering this$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemHoveredRect	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemHoveredRect()$/;"	f	class:ImGui	signature:()
ImGui::IsItemVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemVisible();                                                    \/\/ was the last item visible? (aka not out of sight due to clipping\/scrolling.)$/;"	p	namespace:ImGui	signature:()
ImGui::IsItemVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui	signature:()
ImGui::IsKeyDown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyDown(int user_key_index);                                      \/\/ is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices\/enums according to how your backend\/engine stored them into KeyDown[]!$/;"	p	namespace:ImGui	signature:(int user_key_index)
ImGui::IsKeyDown	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyDown(int user_key_index)$/;"	f	class:ImGui	signature:(int user_key_index)
ImGui::IsKeyPressed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               \/\/ was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay \/ KeyRepeatRate$/;"	p	namespace:ImGui	signature:(int user_key_index, bool repeat = true)
ImGui::IsKeyPressed	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyPressed(int user_key_index, bool repeat)$/;"	f	class:ImGui	signature:(int user_key_index, bool repeat)
ImGui::IsKeyReleased	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  \/\/ was key released (went from Down to !Down)..$/;"	p	namespace:ImGui	signature:(int user_key_index)
ImGui::IsKeyReleased	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyReleased(int user_key_index)$/;"	f	class:ImGui	signature:(int user_key_index)
ImGui::IsMouseClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    \/\/ did mouse button clicked (went from !Down to Down)$/;"	p	namespace:ImGui	signature:(int button, bool repeat = false)
ImGui::IsMouseClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui	signature:(int button, bool repeat)
ImGui::IsMouseDoubleClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   \/\/ did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.$/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsMouseDoubleClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsMouseDown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDown(int button);                                            \/\/ is mouse button held$/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsMouseDown	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsMouseDragging	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      \/\/ is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
ImGui::IsMouseDragging	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
ImGui::IsMouseHoveringAnyWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringAnyWindow();                                         \/\/ is mouse hovering any visible window$/;"	p	namespace:ImGui	signature:()
ImGui::IsMouseHoveringAnyWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringAnyWindow()$/;"	f	class:ImGui	signature:()
ImGui::IsMouseHoveringRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  \/\/ is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus\/window ordering\/blocked by a popup.$/;"	p	namespace:ImGui	signature:(const ImVec2& r_min, const ImVec2& r_max, bool clip = true)
ImGui::IsMouseHoveringRect	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)$/;"	f	class:ImGui	signature:(const ImVec2& r_min, const ImVec2& r_max, bool clip)
ImGui::IsMouseHoveringWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringWindow();                                            \/\/ is mouse hovering current window ("window" in API names always refer to current window). disregarding of any consideration of being blocked by a popup. (unlike IsWindowHovered() this will return true even if the window is blocked because of a popup)$/;"	p	namespace:ImGui	signature:()
ImGui::IsMouseHoveringWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringWindow()$/;"	f	class:ImGui	signature:()
ImGui::IsMouseReleased	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseReleased(int button);                                        \/\/ did mouse button released (went from Down to !Down)$/;"	p	namespace:ImGui	signature:(int button)
ImGui::IsMouseReleased	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::IsPosHoveringAnyWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsPosHoveringAnyWindow(const ImVec2& pos);                          \/\/ is given position hovering any active imgui window$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
ImGui::IsPosHoveringAnyWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsPosHoveringAnyWindow(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
ImGui::IsRectClipped	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
ImGui::IsRectVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      \/\/ test if rectangle (in screen space) is visible \/ not clipped. to perform coarse clipping on user's side.$/;"	p	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
ImGui::IsRectVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  \/\/ test if rectangle (of given size, starting from cursor position) is visible \/ not clipped.$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ImGui::IsRectVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
ImGui::IsRectVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
ImGui::IsRootWindowFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowFocused();                                              \/\/ is current root window focused (root = top-most parent of a child, otherwise self)$/;"	p	namespace:ImGui	signature:()
ImGui::IsRootWindowFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildFocused();                                    \/\/ is current root window or any of its child (including current window) focused$/;"	p	namespace:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildHovered();                                    \/\/ is current root window or any of its child (including current window) hovered and hoverable (not blocked by a popup)$/;"	p	namespace:ImGui	signature:()
ImGui::IsRootWindowOrAnyChildHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildHovered()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowCollapsed();$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowFocused();                                                  \/\/ is current window focused$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowFocused()$/;"	f	class:ImGui	signature:()
ImGui::IsWindowHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowHovered();                                                  \/\/ is current window hovered and hoverable (not blocked by a popup) (differentiate child windows from each others)$/;"	p	namespace:ImGui	signature:()
ImGui::IsWindowHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowHovered()$/;"	f	class:ImGui	signature:()
ImGui::ItemAdd	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ItemAdd(const ImRect& bb, const ImGuiID* id);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, const ImGuiID* id)
ImGui::ItemAdd	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ItemAdd(const ImRect& bb, const ImGuiID* id)$/;"	f	class:ImGui	signature:(const ImRect& bb, const ImGuiID* id)
ImGui::ItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, float text_offset_y = 0.0f)
ImGui::ItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);$/;"	p	namespace:ImGui	signature:(const ImVec2& size, float text_offset_y = 0.0f)
ImGui::ItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ItemSize(const ImRect& bb, float text_offset_y)$/;"	f	class:ImGui	signature:(const ImRect& bb, float text_offset_y)
ImGui::ItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ItemSize(const ImVec2& size, float text_offset_y)$/;"	f	class:ImGui	signature:(const ImVec2& size, float text_offset_y)
ImGui::KeepAliveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          KeepAliveID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
ImGui::KeepAliveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::KeepAliveID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
ImGui::LabelText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, ...)
ImGui::LabelTextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, va_list args)
ImGui::LabelTextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, va_list args)
ImGui::ListBox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ImGui::ListBox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1)
ImGui::ListBox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ImGui::ListBox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_items)
ImGui::ListBoxFooter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ListBoxFooter();                                                    \/\/ terminate the scrolling region$/;"	p	namespace:ImGui	signature:()
ImGui::ListBoxFooter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui	signature:()
ImGui::ListBoxHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); \/\/ use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ImGui::ListBoxHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, int items_count, int height_in_items = -1)
ImGui::ListBoxHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ImGui::ListBoxHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int items_count, int height_in_items)
ImGui::LogButtons	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogButtons();                                                       \/\/ helper to display buttons for logging to tty\/file\/clipboard$/;"	p	namespace:ImGui	signature:()
ImGui::LogButtons	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui	signature:()
ImGui::LogFinish	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogFinish();                                                        \/\/ stop logging (close file, etc.)$/;"	p	namespace:ImGui	signature:()
ImGui::LogFinish	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui	signature:()
ImGui::LogText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::LogToClipboard	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 \/\/ start logging to OS clipboard$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
ImGui::LogToClipboard	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToClipboard(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
ImGui::LogToFile	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         \/\/ start logging to file$/;"	p	namespace:ImGui	signature:(int max_depth = -1, const char* filename = NULL)
ImGui::LogToFile	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToFile(int max_depth, const char* filename)$/;"	f	class:ImGui	signature:(int max_depth, const char* filename)
ImGui::LogToTTY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToTTY(int max_depth = -1);                                       \/\/ start logging to tty$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
ImGui::LogToTTY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToTTY(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
ImGui::MemAlloc	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void*         MemAlloc(size_t sz);$/;"	p	namespace:ImGui	signature:(size_t sz)
ImGui::MemAlloc	abstract-machine/libs/imgui/src/imgui.cpp	/^void* ImGui::MemAlloc(size_t sz)$/;"	f	class:ImGui	signature:(size_t sz)
ImGui::MemFree	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          MemFree(void* ptr);$/;"	p	namespace:ImGui	signature:(void* ptr)
ImGui::MemFree	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui	signature:(void* ptr)
ImGui::MenuItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  \/\/ return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true)
ImGui::MenuItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              \/\/ return true when activated + toggle (*p_selected) if p_selected != NULL$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled = true)
ImGui::MenuItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool selected, bool enabled)
ImGui::MenuItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled)
ImGui::NewFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NewFrame();                                 \/\/ start a new ImGui frame, you can submit any command from this point until NewFrame()\/Render().$/;"	p	namespace:ImGui	signature:()
ImGui::NewFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui	signature:()
ImGui::NewLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NewLine();                                                          \/\/ undo a SameLine()$/;"	p	namespace:ImGui	signature:()
ImGui::NewLine	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NewLine()$/;"	f	class:ImGui	signature:()
ImGui::NextColumn	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NextColumn();                                                       \/\/ next column$/;"	p	namespace:ImGui	signature:()
ImGui::NextColumn	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui	signature:()
ImGui::OpenPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          OpenPopup(const char* str_id);                                      \/\/ mark popup as open. popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()\/EndPopup() block. popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::OpenPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::OpenPopupEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          OpenPopupEx(const char* str_id, bool reopen_existing);$/;"	p	namespace:ImGui	signature:(const char* str_id, bool reopen_existing)
ImGui::OpenPopupEx	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::OpenPopupEx(const char* str_id, bool reopen_existing)$/;"	f	class:ImGui	signature:(const char* str_id, bool reopen_existing)
ImGui::ParseFormatPrecision	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API int           ParseFormatPrecision(const char* fmt, int default_value);$/;"	p	namespace:ImGui	signature:(const char* fmt, int default_value)
ImGui::ParseFormatPrecision	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::ParseFormatPrecision(const char* fmt, int default_precision)$/;"	f	class:ImGui	signature:(const char* fmt, int default_precision)
ImGui::PlotEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);$/;"	p	namespace:ImGui	signature:(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PlotEx	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PlotHistogram	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
ImGui::PlotHistogram	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
ImGui::PlotHistogram	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
ImGui::PlotHistogram	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PlotLines	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
ImGui::PlotLines	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
ImGui::PlotLines	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
ImGui::PlotLines	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
ImGui::PopAllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopAllowKeyboardFocus();$/;"	p	namespace:ImGui	signature:()
ImGui::PopAllowKeyboardFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui	signature:()
ImGui::PopButtonRepeat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopButtonRepeat();$/;"	p	namespace:ImGui	signature:()
ImGui::PopButtonRepeat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui	signature:()
ImGui::PopClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopClipRect();$/;"	p	namespace:ImGui	signature:()
ImGui::PopClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopClipRect()$/;"	f	class:ImGui	signature:()
ImGui::PopFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopFont();$/;"	p	namespace:ImGui	signature:()
ImGui::PopFont	abstract-machine/libs/imgui/src/imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui	signature:()
ImGui::PopID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopID();$/;"	p	namespace:ImGui	signature:()
ImGui::PopID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui	signature:()
ImGui::PopItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopItemWidth();$/;"	p	namespace:ImGui	signature:()
ImGui::PopItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui	signature:()
ImGui::PopStyleColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopStyleColor(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
ImGui::PopStyleColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui	signature:(int count)
ImGui::PopStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopStyleVar(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
ImGui::PopStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui	signature:(int count)
ImGui::PopTextWrapPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopTextWrapPos();$/;"	p	namespace:ImGui	signature:()
ImGui::PopTextWrapPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui	signature:()
ImGui::ProgressBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);$/;"	p	namespace:ImGui	signature:(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL)
ImGui::ProgressBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)$/;"	f	class:ImGui	signature:(float fraction, const ImVec2& size_arg, const char* overlay)
ImGui::PushAllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushAllowKeyboardFocus(bool v);                                     \/\/ allow focusing using TAB\/Shift-TAB, enabled by default but you can disable it for certain widgets$/;"	p	namespace:ImGui	signature:(bool v)
ImGui::PushAllowKeyboardFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui	signature:(bool allow_keyboard_focus)
ImGui::PushButtonRepeat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushButtonRepeat(bool repeat);                                      \/\/ in 'repeat' mode, Button*() functions return repeated true in a typematic manner (uses io.KeyRepeatDelay\/io.KeyRepeatRate for now). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.$/;"	p	namespace:ImGui	signature:(bool repeat)
ImGui::PushButtonRepeat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui	signature:(bool repeat)
ImGui::PushClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);$/;"	p	namespace:ImGui	signature:(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
ImGui::PushClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImGui	signature:(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
ImGui::PushFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushFont(ImFont* font);                                             \/\/ use NULL as a shortcut to push default font$/;"	p	namespace:ImGui	signature:(ImFont* font)
ImGui::PushFont	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui	signature:(ImFont* font)
ImGui::PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const char* str_id);                                         \/\/ push identifier into the ID stack. IDs are hash of the *entire* stack!$/;"	p	namespace:ImGui	signature:(const char* str_id)
ImGui::PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
ImGui::PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(int int_id);$/;"	p	namespace:ImGui	signature:(int int_id)
ImGui::PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
ImGui::PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui	signature:(int int_id)
ImGui::PushItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushItemWidth(float item_width);                                    \/\/ width of items for the common item+label case, pixels. 0.0f = default to ~2\/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)$/;"	p	namespace:ImGui	signature:(float item_width)
ImGui::PushItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui	signature:(float item_width)
ImGui::PushStyleColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
ImGui::PushStyleColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
ImGui::PushStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
ImGui::PushStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, float val)
ImGui::PushStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
ImGui::PushStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, float val)
ImGui::PushTextWrapPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           \/\/ word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space$/;"	p	namespace:ImGui	signature:(float wrap_pos_x = 0.0f)
ImGui::PushTextWrapPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui	signature:(float wrap_pos_x)
ImGui::RadioButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, bool active);$/;"	p	namespace:ImGui	signature:(const char* label, bool active)
ImGui::RadioButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_button)
ImGui::RadioButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui	signature:(const char* label, bool active)
ImGui::RadioButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_button)
ImGui::Render	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Render();                                   \/\/ ends the ImGui frame, finalize rendering data, then call your io.RenderDrawListsFn() function if set.$/;"	p	namespace:ImGui	signature:()
ImGui::Render	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui	signature:()
ImGui::RenderBullet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderBullet(ImVec2 pos);$/;"	p	namespace:ImGui	signature:(ImVec2 pos)
ImGui::RenderBullet	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderBullet(ImVec2 pos)$/;"	f	class:ImGui	signature:(ImVec2 pos)
ImGui::RenderCheckMark	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, ImU32 col)
ImGui::RenderCheckMark	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col)$/;"	f	class:ImGui	signature:(ImVec2 pos, ImU32 col)
ImGui::RenderCollapseTriangle	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderCollapseTriangle(ImVec2 pos, bool is_open, float scale = 1.0f);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, bool is_open, float scale = 1.0f)
ImGui::RenderCollapseTriangle	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderCollapseTriangle(ImVec2 p_min, bool is_open, float scale)$/;"	f	class:ImGui	signature:(ImVec2 p_min, bool is_open, float scale)
ImGui::RenderFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);$/;"	p	namespace:ImGui	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f)
ImGui::RenderFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	class:ImGui	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
ImGui::RenderText	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true)
ImGui::RenderText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	class:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
ImGui::RenderTextClipped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);$/;"	p	namespace:ImGui	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL)
ImGui::RenderTextClipped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
ImGui::RenderTextWrapped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
ImGui::RenderTextWrapped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	class:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
ImGui::ResetMouseDragDelta	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                \/\/$/;"	p	namespace:ImGui	signature:(int button = 0)
ImGui::ResetMouseDragDelta	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui	signature:(int button)
ImGui::RoundScalar	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API float         RoundScalar(float value, int decimal_precision);$/;"	p	namespace:ImGui	signature:(float value, int decimal_precision)
ImGui::RoundScalar	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::RoundScalar(float value, int decimal_precision)$/;"	f	class:ImGui	signature:(float value, int decimal_precision)
ImGui::SameLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              \/\/ call between widgets or groups to layout them horizontally$/;"	p	namespace:ImGui	signature:(float pos_x = 0.0f, float spacing_w = -1.0f)
ImGui::SameLine	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SameLine(float pos_x, float spacing_w)$/;"	f	class:ImGui	signature:(float pos_x, float spacing_w)
ImGui::Selectable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  \/\/ size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height$/;"	p	namespace:ImGui	signature:(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
ImGui::Selectable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
ImGui::Selectable	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
ImGui::Selectable	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
ImGui::Separator	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Separator();                                                        \/\/ horizontal line$/;"	p	namespace:ImGui	signature:()
ImGui::Separator	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui	signature:()
ImGui::SetActiveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiWindow* window)
ImGui::SetActiveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiWindow* window)
ImGui::SetClipboardText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetClipboardText(const char* text);$/;"	p	namespace:ImGui	signature:(const char* text)
ImGui::SetClipboardText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetClipboardText(const char* text)$/;"	f	class:ImGui	signature:(const char* text)
ImGui::SetColumnOffset	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  \/\/ set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column$/;"	p	namespace:ImGui	signature:(int column_index, float offset_x)
ImGui::SetColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui	signature:(int column_index, float offset)
ImGui::SetCurrentContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);$/;"	p	namespace:ImGui	signature:(ImGuiContext* ctx)
ImGui::SetCurrentContext	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCurrentContext(ImGuiContext* ctx)$/;"	f	class:ImGui	signature:(ImGuiContext* ctx)
ImGui::SetCursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                              \/\/ "$/;"	p	namespace:ImGui	signature:(const ImVec2& local_pos)
ImGui::SetCursorPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& local_pos)$/;"	f	class:ImGui	signature:(const ImVec2& local_pos)
ImGui::SetCursorPosX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPosX(float x);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float x)
ImGui::SetCursorPosX	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui	signature:(float x)
ImGui::SetCursorPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPosY(float y);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float y)
ImGui::SetCursorPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui	signature:(float y)
ImGui::SetCursorScreenPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
ImGui::SetCursorScreenPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)$/;"	f	class:ImGui	signature:(const ImVec2& screen_pos)
ImGui::SetHoveredID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          SetHoveredID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
ImGui::SetHoveredID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetHoveredID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
ImGui::SetItemAllowOverlap	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetItemAllowOverlap();                                              \/\/ allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.$/;"	p	namespace:ImGui	signature:()
ImGui::SetItemAllowOverlap	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetItemAllowOverlap()$/;"	f	class:ImGui	signature:()
ImGui::SetKeyboardFocusHere	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               \/\/ focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use negative 'offset' to access previous widgets.$/;"	p	namespace:ImGui	signature:(int offset = 0)
ImGui::SetKeyboardFocusHere	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui	signature:(int offset)
ImGui::SetMouseCursor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              \/\/ set desired cursor type$/;"	p	namespace:ImGui	signature:(ImGuiMouseCursor type)
ImGui::SetMouseCursor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui	signature:(ImGuiMouseCursor cursor_type)
ImGui::SetNextTreeNodeOpen	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond = 0);               \/\/ set next TreeNode\/CollapsingHeader open state.$/;"	p	namespace:ImGui	signature:(bool is_open, ImGuiSetCond cond = 0)
ImGui::SetNextTreeNodeOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool is_open, ImGuiSetCond cond)
ImGui::SetNextWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);      \/\/ set next window collapsed state. call before Begin()$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetNextWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
ImGui::SetNextWindowContentSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                       \/\/ set next window content size (enforce the range of scrollbars). set axis to 0.0f to leave it automatic. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
ImGui::SetNextWindowContentSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowContentSize(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
ImGui::SetNextWindowContentWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowContentWidth(float width);                             \/\/ set next window content width (enforce the range of horizontal scrollbar). call before Begin()$/;"	p	namespace:ImGui	signature:(float width)
ImGui::SetNextWindowContentWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowContentWidth(float width)$/;"	f	class:ImGui	signature:(float width)
ImGui::SetNextWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowFocus();                                               \/\/ set next window to be focused \/ front-most. call before Begin()$/;"	p	namespace:ImGui	signature:()
ImGui::SetNextWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui	signature:()
ImGui::SetNextWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);         \/\/ set next window position. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetNextWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetNextWindowPosCenter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowPosCenter(ImGuiSetCond cond = 0);                      \/\/ set next window position to be centered on screen. call before Begin()$/;"	p	namespace:ImGui	signature:(ImGuiSetCond cond = 0)
ImGui::SetNextWindowPosCenter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(ImGuiSetCond cond)
ImGui::SetNextWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);       \/\/ set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::SetNextWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
ImGui::SetNextWindowSizeConstraints	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL); \/\/ set next window size limits. use -1,-1 on either X\/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.$/;"	p	namespace:ImGui	signature:(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL)
ImGui::SetNextWindowSizeConstraints	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)$/;"	f	class:ImGui	signature:(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)
ImGui::SetScrollFromPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        \/\/ adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.$/;"	p	namespace:ImGui	signature:(float pos_y, float center_y_ratio = 0.5f)
ImGui::SetScrollFromPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)$/;"	f	class:ImGui	signature:(float pos_y, float center_y_ratio)
ImGui::SetScrollHere	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         \/\/ adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.$/;"	p	namespace:ImGui	signature:(float center_y_ratio = 0.5f)
ImGui::SetScrollHere	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollHere(float center_y_ratio)$/;"	f	class:ImGui	signature:(float center_y_ratio)
ImGui::SetScrollPosHere	abstract-machine/libs/imgui/include/imgui.h	/^    static inline void      SetScrollPosHere() { SetScrollHere(); }                            \/\/ OBSOLETE 1.42+$/;"	f	namespace:ImGui	signature:()
ImGui::SetScrollX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollX(float scroll_x);                                         \/\/ set scrolling amount [0..GetScrollMaxX()]$/;"	p	namespace:ImGui	signature:(float scroll_x)
ImGui::SetScrollX	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollX(float scroll_x)$/;"	f	class:ImGui	signature:(float scroll_x)
ImGui::SetScrollY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollY(float scroll_y);                                         \/\/ set scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:(float scroll_y)
ImGui::SetScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui	signature:(float scroll_y)
ImGui::SetStateStorage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                \/\/ replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)$/;"	p	namespace:ImGui	signature:(ImGuiStorage* tree)
ImGui::SetStateStorage	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui	signature:(ImGuiStorage* tree)
ImGui::SetTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::SetTooltipV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetTooltipV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::SetTooltipV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::SetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);          \/\/ (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond = 0);   \/\/ set named window collapsed state$/;"	p	namespace:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond = 0)
ImGui::SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
ImGui::SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond)
ImGui::SetWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFocus();                                                   \/\/ (not recommended) set current window to be focused \/ front-most. prefer using SetNextWindowFocus().$/;"	p	namespace:ImGui	signature:()
ImGui::SetWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFocus(const char* name);                                              \/\/ set named window to be focused \/ front-most. use NULL to remove focus.$/;"	p	namespace:ImGui	signature:(const char* name)
ImGui::SetWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui	signature:()
ImGui::SetWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
ImGui::SetWindowFontScale	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFontScale(float scale);                                    \/\/ per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows$/;"	p	namespace:ImGui	signature:(float scale)
ImGui::SetWindowFontScale	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui	signature:(float scale)
ImGui::SetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);             \/\/ (not recommended) set current window position - call within Begin()\/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0);      \/\/ set named window position.$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0)
ImGui::SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond)
ImGui::SetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);           \/\/ (not recommended) set current window size - call within Begin()\/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.    $/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::SetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond = 0);    \/\/ set named window size. set axis to 0.0f to force an auto-fit on this axis.$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond = 0)
ImGui::SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
ImGui::SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond)
ImGui::ShowMetricsWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     \/\/ metrics window for debugging ImGui (browse draw commands, individual vertices, window list, etc.)$/;"	p	namespace:ImGui	signature:(bool* p_open = NULL)
ImGui::ShowMetricsWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* p_open)$/;"	f	class:ImGui	signature:(bool* p_open)
ImGui::ShowStyleEditor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    \/\/ style editor block. you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)$/;"	p	namespace:ImGui	signature:(ImGuiStyle* ref = NULL)
ImGui::ShowStyleEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui	signature:(ImGuiStyle* ref)
ImGui::ShowStyleEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle*) {}$/;"	f	class:ImGui	signature:(ImGuiStyle*)
ImGui::ShowTestWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowTestWindow(bool* p_open = NULL);        \/\/ test window demonstrating ImGui features$/;"	p	namespace:ImGui	signature:(bool* p_open = NULL)
ImGui::ShowTestWindow	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool* p_open)$/;"	f	class:ImGui	signature:(bool* p_open)
ImGui::ShowTestWindow	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool*) {}$/;"	f	class:ImGui	signature:(bool*)
ImGui::ShowUserGuide	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowUserGuide();                            \/\/ help block$/;"	p	namespace:ImGui	signature:()
ImGui::ShowUserGuide	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowUserGuide() {}$/;"	f	class:ImGui	signature:()
ImGui::ShowUserGuide	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui	signature:()
ImGui::Shutdown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Shutdown();$/;"	p	namespace:ImGui	signature:()
ImGui::Shutdown	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Shutdown()$/;"	f	class:ImGui	signature:()
ImGui::SliderAngle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f)
ImGui::SliderAngle	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)$/;"	f	class:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
ImGui::SliderBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0)
ImGui::SliderBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)$/;"	f	class:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)
ImGui::SliderFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     \/\/ adjust display_format to decorate the value with a prefix or a suffix. Use power!=1.0 for logarithmic sliders$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format = , float power = 1.0f)
ImGui::SliderFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format = , float power = 1.0f)
ImGui::SliderFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format = , float power = 1.0f)
ImGui::SliderFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format = , float power = 1.0f)
ImGui::SliderFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
ImGui::SliderFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
ImGui::SliderInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format = )
ImGui::SliderInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format)
ImGui::SliderInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format = )
ImGui::SliderInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format)
ImGui::SliderInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format = )
ImGui::SliderInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format)
ImGui::SliderInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format = )
ImGui::SliderInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format)
ImGui::SliderIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
ImGui::SliderIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
ImGui::SmallButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SmallButton(const char* label);                                         \/\/ button with FramePadding=(0,0)$/;"	p	namespace:ImGui	signature:(const char* label)
ImGui::SmallButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
ImGui::Spacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Spacing();                                                          \/\/ add vertical spacing$/;"	p	namespace:ImGui	signature:()
ImGui::Spacing	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui	signature:()
ImGui::Text	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::TextColored	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
ImGui::TextColoredV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
ImGui::TextColoredV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
ImGui::TextDisabled	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::TextDisabledV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextDisabledV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextDisabledV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextUnformatted	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);         \/\/ doesn't require null terminated string if 'text_end' is specified. no copy done to any bounded stack buffer, recommended for long chunks of text$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
ImGui::TextUnformatted	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
ImGui::TextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextWrapped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
ImGui::TextWrappedV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextWrappedV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
ImGui::TextWrappedV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
ImGui::TreeAdvanceToLabelPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreeAdvanceToLabelPos();                                                \/\/ advance cursor x position by GetTreeNodeToLabelSpacing()$/;"	p	namespace:ImGui	signature:()
ImGui::TreeAdvanceToLabelPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreeAdvanceToLabelPos()$/;"	f	class:ImGui	signature:()
ImGui::TreeNode	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNode(const char* label);                                            \/\/ if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().$/;"	p	namespace:ImGui	signature:(const char* label)
ImGui::TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
ImGui::TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, ...)
ImGui::TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
ImGui::TreeNodeBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL)
ImGui::TreeNodeBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
ImGui::TreeNodeBehaviorIsOpen	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     \/\/ Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags = 0)
ImGui::TreeNodeBehaviorIsOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags)
ImGui::TreeNodeEx	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags = 0)
ImGui::TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags)
ImGui::TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
ImGui::TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
ImGui::TreeNodeExV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
ImGui::TreeNodeExV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
ImGui::TreeNodeExV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
ImGui::TreeNodeExV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
ImGui::TreeNodeV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args);           \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
ImGui::TreeNodeV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args);           \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
ImGui::TreeNodeV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
ImGui::TreeNodeV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
ImGui::TreePop	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePop();                                                              \/\/ ~ Unindent()+PopId()$/;"	p	namespace:ImGui	signature:()
ImGui::TreePop	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui	signature:()
ImGui::TreePush	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePush(const char* str_id = NULL);                                    \/\/ ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push\/Pop yourself for layout purpose$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL)
ImGui::TreePush	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                    \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id = NULL)
ImGui::TreePush	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
ImGui::TreePush	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
ImGui::TreePushRawID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          TreePushRawID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
ImGui::TreePushRawID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePushRawID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
ImGui::Unindent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Unindent(float indent_w = 0.0f);                                    \/\/ move content position back to the left, by style.IndentSpacing or indent_w if >0$/;"	p	namespace:ImGui	signature:(float indent_w = 0.0f)
ImGui::Unindent	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Unindent(float indent_w)$/;"	f	class:ImGui	signature:(float indent_w)
ImGui::VSliderFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = , float power = 1.0f)
ImGui::VSliderFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
ImGui::VSliderInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = )
ImGui::VSliderInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
ImGui::Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, bool b);$/;"	p	namespace:ImGui	signature:(const char* prefix, bool b)
ImGui::Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);$/;"	p	namespace:ImGui	signature:(const char* prefix, float v, const char* float_format = NULL)
ImGui::Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, int v)
ImGui::Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
ImGui::Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui	signature:(const char* prefix, bool b)
ImGui::Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui	signature:(const char* prefix, float v, const char* float_format)
ImGui::Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui	signature:(const char* prefix, int v)
ImGui::Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
ImGui::ValueColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ValueColor(const char* prefix, ImU32 v);$/;"	p	namespace:ImGui	signature:(const char* prefix, ImU32 v)
ImGui::ValueColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ValueColor(const char* prefix, const ImVec4& v);$/;"	p	namespace:ImGui	signature:(const char* prefix, const ImVec4& v)
ImGui::ValueColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ValueColor(const char* prefix, ImU32 v)$/;"	f	class:ImGui	signature:(const char* prefix, ImU32 v)
ImGui::ValueColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ValueColor(const char* prefix, const ImVec4& v)$/;"	f	class:ImGui	signature:(const char* prefix, const ImVec4& v)
ImGuiButtonFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^typedef int ImGuiButtonFlags;     \/\/ enum ImGuiButtonFlags_$/;"	t
ImGuiButtonFlags_	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiButtonFlags_$/;"	g
ImGuiButtonFlags_AlignTextBaseLine	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 8,   \/\/ vertically align button to match text baseline - ButtonEx() only$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_AllowOverlapMode	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_AllowOverlapMode       = 1 << 10   \/\/ require previous frame HoveredId to either match id or be null before being usable$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Disabled	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_Disabled               = 1 << 7,   \/\/ disable interaction$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_DontClosePopups	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_DontClosePopups        = 1 << 6,   \/\/ disable automatically closing parent popup on press$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_FlattenChilds	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_FlattenChilds          = 1 << 5,   \/\/ allow interaction even if a child window is overlapping$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoKeyModifiers	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_NoKeyModifiers         = 1 << 9,   \/\/ disable interaction if a key modifier is held$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClick	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   \/\/ return pressed on click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClickRelease	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   \/\/ (default) return pressed on click+release on same item (default if no PressedOn** flag is set)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnDoubleClick	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   \/\/ return pressed on double-click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnRelease	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   \/\/ return pressed on release (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Repeat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiButtonFlags_Repeat                 = 1 << 0,   \/\/ hold to repeat$/;"	e	enum:ImGuiButtonFlags_
ImGuiCol	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiCol;               \/\/ a color identifier for styling       \/\/ enum ImGuiCol_$/;"	t
ImGuiColMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiColMod$/;"	s
ImGuiColMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiColMod;$/;"	x
ImGuiColMod::BackupValue	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec4      BackupValue;$/;"	m	struct:ImGuiColMod	access:public
ImGuiColMod::Col	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColMod	access:public
ImGuiCol_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiCol_$/;"	g
ImGuiCol_Border	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_Border,$/;"	e	enum:ImGuiCol_
ImGuiCol_BorderShadow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_BorderShadow,$/;"	e	enum:ImGuiCol_
ImGuiCol_Button	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_Button,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_COUNT	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_COUNT$/;"	e	enum:ImGuiCol_
ImGuiCol_CheckMark	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_CheckMark,$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildWindowBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ChildWindowBg,         \/\/ Background of child windows$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButton	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_CloseButton,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_CloseButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_CloseButtonHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_CloseButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Column	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_Column,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ColumnActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ColumnHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ColumnHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ComboBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ComboBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_FrameBg,               \/\/ Background of checkbox, radio button, plot, slider, text input$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_FrameBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_FrameBgHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Header	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_Header,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_HeaderActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_HeaderHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_MenuBarBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_MenuBarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDarkening	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ModalWindowDarkening,  \/\/ darken entire screen when a modal window is active$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogram	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_PlotHistogram,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogramHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_PlotHistogramHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLines	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_PlotLines,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLinesHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_PlotLinesHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PopupBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_PopupBg,               \/\/ Background of popups, menus, tooltips windows$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGrip	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ResizeGrip,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ResizeGripActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ResizeGripHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ScrollbarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrab	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ScrollbarGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ScrollbarGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabHovered	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_ScrollbarGrabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrab	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_SliderGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrabActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_SliderGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Text	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_Text,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextDisabled	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_TextDisabled,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextSelectedBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_TextSelectedBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_TitleBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgActive	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_TitleBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_TitleBgCollapsed,$/;"	e	enum:ImGuiCol_
ImGuiCol_WindowBg	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiCol_WindowBg,              \/\/ Background of normal windows$/;"	e	enum:ImGuiCol_
ImGuiColorEditMode	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiColorEditMode;     \/\/ color edit mode for ColorEdit*()     \/\/ enum ImGuiColorEditMode_$/;"	t
ImGuiColorEditMode_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiColorEditMode_$/;"	g
ImGuiColorEditMode_HEX	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiColorEditMode_HEX = 2$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_HSV	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiColorEditMode_HSV = 1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_RGB	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiColorEditMode_RGB = 0,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelect	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiColorEditMode_UserSelect = -2,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColorEditMode_UserSelectShowButton	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiColorEditMode_UserSelectShowButton = -1,$/;"	e	enum:ImGuiColorEditMode_
ImGuiColumnData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiColumnData$/;"	s
ImGuiColumnData::OffsetNorm	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       OffsetNorm;     \/\/ Column start offset, normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiColumnData	access:public
ImGuiContext	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiContext;                \/\/ ImGui context (opaque)$/;"	x
ImGuiContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiContext()$/;"	f	struct:ImGuiContext	access:public	signature:()
ImGuiContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiContext$/;"	s
ImGuiContext::ActiveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdAllowOverlap	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdAllowOverlap;               \/\/ Set only by active widget$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdClickOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ActiveIdClickOffset;                \/\/ Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdIsAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdIsAlive;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdIsJustActivated	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdPreviousFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ActiveIdWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::CaptureKeyboardNextFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     CaptureKeyboardNextFrame;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::CaptureMouseNextFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     CaptureMouseNextFrame;              \/\/ explicit capture via CaptureInputs() sets those flags$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ColorEditModeStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage            ColorEditModeStorage;               \/\/ Store user selection of color edit mode$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ColorModifiers	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiColMod>   ColorModifiers;                     \/\/ Stack for PushStyleColor()\/PopStyleColor()$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::CurrentPopupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiPopupRef> CurrentPopupStack;                  \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::CurrentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::CurrentWindowStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::DragCurrentValue	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragCurrentValue;                   \/\/ Currently dragged value, always float, not rounded by end-user precision settings$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::DragLastMouseDelta	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  DragLastMouseDelta;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::DragSpeedDefaultRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedDefaultRatio;              \/\/ If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::DragSpeedScaleFast	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedScaleFast;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::DragSpeedScaleSlow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   DragSpeedScaleSlow;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FocusedWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            FocusedWindow;                      \/\/ Will catch keyboard inputs$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Font	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FontBaseSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Size of characters.$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FontSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize()$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FontStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImFont*>       FontStack;                          \/\/ Stack for PushFont()\/PopFont()$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FontTexUvWhitePixel	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  FontTexUvWhitePixel;                \/\/ (Shortcut) == Font->TexUvWhitePixel$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FrameCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCount;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FrameCountEnded	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCountEnded;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FrameCountRendered	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FramerateSecPerFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FramerateSecPerFrame[120];          \/\/ calculate estimate of framerate for user$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FramerateSecPerFrameAccum	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::FramerateSecPerFrameIdx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::HoveredId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::HoveredIdAllowOverlap	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    HoveredIdAllowOverlap;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::HoveredIdPreviousFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::HoveredRootWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::HoveredWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::IO	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ImGuiContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiContext()$/;"	f	struct:ImGuiContext	access:public	signature:()
ImGuiContext::Initialized	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Initialized;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::InputTextPasswordFont	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImFont                  InputTextPasswordFont;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::InputTextState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextEditState      InputTextState;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::LogAutoExpandMaxDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LogAutoExpandMaxDepth;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::LogClipboard	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextBuffer*        LogClipboard;                       \/\/ Else log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::LogEnabled	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::LogFile	abstract-machine/libs/imgui/include/imgui_internal.h	/^    FILE*                   LogFile;                            \/\/ If != NULL log to stdout\/ file$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::LogStartDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LogStartDepth;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ModalWindowDarkeningRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ModalWindowDarkeningRatio;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::MouseCursor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::MouseCursorData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::MovedWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            MovedWindow;                        \/\/ Track the child window we clicked on to move a window.$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::MovedWindowMoveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 MovedWindowMoveId;                  \/\/ == MovedWindow->RootWindow->MoveId$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::OpenPopupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiPopupRef> OpenPopupStack;                     \/\/ Which popups are open (persistent)$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::OsImePosRequest	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::OsImePosSet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::OverlayDrawList	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawList              OverlayDrawList;                    \/\/ Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::PrivateClipboard	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*                   PrivateClipboard;                   \/\/ If no custom clipboard handler is defined$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::RenderDrawData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawData              RenderDrawData;                     \/\/ Main ImDrawData instance to pass render information to the user$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::RenderDrawLists	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImDrawList*>   RenderDrawLists[3];$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ScalarAsInputTextId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ScalarAsInputTextId;                \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::ScrollbarClickDeltaToGrabCenter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollbarClickDeltaToGrabCenter;    \/\/ Distance between mouse and center of grab box, normalized in parent space. Use storage?$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextTreeNodeOpenCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextTreeNodeOpenCond;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextTreeNodeOpenVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextTreeNodeOpenVal;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowCollapsedCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowCollapsedCond;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowCollapsedVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowCollapsedVal;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowContentSizeCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowContentSizeCond;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowContentSizeVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowContentSizeVal;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowFocus	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowFocus;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowPosCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowPosCond;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowPosVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowPosVal;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowSizeCond;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeConstraint	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowSizeConstraint;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeConstraintCallback	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSizeConstraintCallback SetNextWindowSizeConstraintCallback;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeConstraintCallbackUserData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void*                       SetNextWindowSizeConstraintCallbackUserData;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeConstraintRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  SetNextWindowSizeConstraintRect;           \/\/ Valid if 'SetNextWindowSizeConstraint' is true$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SetNextWindowSizeVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowSizeVal;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Settings	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiIniData>  Settings;                           \/\/ .ini Settings$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::SettingsDirtyTimer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   SettingsDirtyTimer;                 \/\/ Save .ini Settings on disk when time reaches zero$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Style	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::StyleModifiers	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiStyleMod> StyleModifiers;                     \/\/ Stack for PushStyleVar()\/PopStyleVar()$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::TempBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char                    TempBuffer[1024*3+1];               \/\/ temporary text buffer$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Time	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   Time;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Tooltip	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char                    Tooltip[1024];$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::Windows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  Windows;$/;"	m	struct:ImGuiContext	access:public
ImGuiContext::WindowsSortBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiContext	access:public
ImGuiCorner	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiCorner$/;"	g
ImGuiCorner_All	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCorner_All         = 0x0F$/;"	e	enum:ImGuiCorner
ImGuiCorner_BottomLeft	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCorner_BottomLeft  = 1 << 3, \/\/ 8$/;"	e	enum:ImGuiCorner
ImGuiCorner_BottomRight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCorner_BottomRight = 1 << 2, \/\/ 4$/;"	e	enum:ImGuiCorner
ImGuiCorner_TopLeft	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCorner_TopLeft     = 1 << 0, \/\/ 1$/;"	e	enum:ImGuiCorner
ImGuiCorner_TopRight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiCorner_TopRight    = 1 << 1, \/\/ 2$/;"	e	enum:ImGuiCorner
ImGuiDataType	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiDataType$/;"	g
ImGuiDataType_Float	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDataType_Float,$/;"	e	enum:ImGuiDataType
ImGuiDataType_Float2	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDataType_Float2,$/;"	e	enum:ImGuiDataType
ImGuiDataType_Int	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDataType_Int,$/;"	e	enum:ImGuiDataType
ImGuiDrawContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDrawContext()$/;"	f	struct:ImGuiDrawContext	access:public	signature:()
ImGuiDrawContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct IMGUI_API ImGuiDrawContext$/;"	s
ImGuiDrawContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiDrawContext;$/;"	x
ImGuiDrawContext::AllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    AllowKeyboardFocus;     \/\/ == AllowKeyboardFocusStack.back() [empty == true]$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::AllowKeyboardFocusStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<bool>          AllowKeyboardFocusStack;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ButtonRepeat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ButtonRepeat;           \/\/ == ButtonRepeatStack.back() [empty == false]$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ButtonRepeatStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<bool>          ButtonRepeatStack;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ChildWindows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColorEditMode	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiColorEditMode      ColorEditMode;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsCellMaxY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsCellMaxY;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsCellMinY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsCellMinY;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     ColumnsCount;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     ColumnsCurrent;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiColumnData> ColumnsData;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsMaxX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsMaxX;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsMinX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsMinX;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsOffsetX;         \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsSetId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ColumnsSetId;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsShowBorders	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ColumnsShowBorders;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ColumnsStartPosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ColumnsStartPosY;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CurrentLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   CurrentLineHeight;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CurrentLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   CurrentLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CursorMaxPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorMaxPos;           \/\/ Implicitly calculate the size of our contents, always extending. Saved into window->SizeContents at the end of the frame$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CursorPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CursorPosPrevLine	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::CursorStartPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  CursorStartPos;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::GroupOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   GroupOffsetX;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::GroupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ImGuiDrawContext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDrawContext()$/;"	f	struct:ImGuiDrawContext	access:public	signature:()
ImGuiDrawContext::IndentX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   IndentX;                \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ItemWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::ItemWidthStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LastItemHoveredAndUsable	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LastItemHoveredAndUsable;  \/\/ Item rectangle is hovered, and its window is currently interactable with (not blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LastItemHoveredRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LastItemHoveredRect;       \/\/ Item rectangle is hovered, but its window may or not be currently interactable with (might be blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LastItemId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 LastItemId;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LastItemRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LayoutType	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::LogLinePosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::MenuBarAppending	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    MenuBarAppending;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::MenuBarOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   MenuBarOffsetX;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::PrevLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   PrevLineHeight;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::PrevLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::StackSizesBackup	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::StateStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::TextWrapPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::TextWrapPosStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiDrawContext::TreeDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     TreeDepth;$/;"	m	struct:ImGuiDrawContext	access:public
ImGuiGroupData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiGroupData$/;"	s
ImGuiGroupData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiGroupData;$/;"	x
ImGuiGroupData::AdvanceCursor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        AdvanceCursor;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupActiveIdIsAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        BackupActiveIdIsAlive;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupCurrentLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupCurrentLineHeight;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupCurrentLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupCurrentLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupCursorMaxPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupCursorPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      BackupCursorPos;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupGroupOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupGroupOffsetX;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupIndentX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupIndentX;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiGroupData::BackupLogLinePosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       BackupLogLinePosY;$/;"	m	struct:ImGuiGroupData	access:public
ImGuiID	abstract-machine/libs/imgui/include/imgui.h	/^typedef unsigned int ImGuiID;       \/\/ unique ID used by widgets (typically hashed from a stack of string)$/;"	t
ImGuiIO	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API   ImGuiIO();$/;"	p	struct:ImGuiIO	access:public	signature:()
ImGuiIO	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiIO$/;"	s
ImGuiIO	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiIO;                     \/\/ Main configuration and I\/O between your application and ImGui$/;"	x
ImGuiIO	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO	signature:()
ImGuiIO::AddInputCharacter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void AddInputCharacter(ImWchar c);                        \/\/ Add new character into InputCharacters[]$/;"	p	struct:ImGuiIO	access:public	signature:(ImWchar c)
ImGuiIO::AddInputCharacter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiIO::AddInputCharacter(ImWchar c)$/;"	f	class:ImGuiIO	signature:(ImWchar c)
ImGuiIO::AddInputCharactersUTF8	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      \/\/ Add new characters into InputCharacters[] from an UTF-8 string$/;"	p	struct:ImGuiIO	access:public	signature:(const char* utf8_chars)
ImGuiIO::AddInputCharactersUTF8	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO	signature:(const char* utf8_chars)
ImGuiIO::ClearInputCharacters	abstract-machine/libs/imgui/include/imgui.h	/^    inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   \/\/ Clear the text input buffer manually$/;"	f	struct:ImGuiIO	access:public	signature:()
ImGuiIO::ClipboardUserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*       ClipboardUserData;$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DeltaTime	abstract-machine/libs/imgui/include/imgui.h	/^    float         DeltaTime;                \/\/ = 1.0f\/60.0f         \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplayFramebufferScale	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayFramebufferScale;  \/\/ = (1.0f,1.0f)        \/\/ For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplaySize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplaySize;              \/\/ <unset>              \/\/ Display size, in pixels. For clamping windows positions.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplayVisibleMax	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayVisibleMax;        \/\/ <unset> (0.0f,0.0f)  \/\/ If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::DisplayVisibleMin	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2        DisplayVisibleMin;        \/\/ <unset> (0.0f,0.0f)  \/\/ If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin\/Max to the visible area.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::FontAllowUserScaling	abstract-machine/libs/imgui/include/imgui.h	/^    bool          FontAllowUserScaling;     \/\/ = false              \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::FontDefault	abstract-machine/libs/imgui/include/imgui.h	/^    ImFont*       FontDefault;              \/\/ = NULL               \/\/ Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::FontGlobalScale	abstract-machine/libs/imgui/include/imgui.h	/^    float         FontGlobalScale;          \/\/ = 1.0f               \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::Fonts	abstract-machine/libs/imgui/include/imgui.h	/^    ImFontAtlas*  Fonts;                    \/\/ <auto>               \/\/ Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::Framerate	abstract-machine/libs/imgui/include/imgui.h	/^    float       Framerate;                  \/\/ Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::GetClipboardTextFn	abstract-machine/libs/imgui/include/imgui.h	/^    const char* (*GetClipboardTextFn)(void* user_data);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::ImGuiIO	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API   ImGuiIO();$/;"	p	struct:ImGuiIO	access:public	signature:()
ImGuiIO::ImGuiIO	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO	signature:()
ImGuiIO::ImeSetInputScreenPosFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::ImeWindowHandle	abstract-machine/libs/imgui/include/imgui.h	/^    void*       ImeWindowHandle;            \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::IniFilename	abstract-machine/libs/imgui/include/imgui.h	/^    const char*   IniFilename;              \/\/ = "imgui.ini"        \/\/ Path to .ini file. NULL to disable .ini saving.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::IniSavingRate	abstract-machine/libs/imgui/include/imgui.h	/^    float         IniSavingRate;            \/\/ = 5.0f               \/\/ Maximum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::InputCharacters	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar     InputCharacters[16+1];      \/\/ List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyAlt	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyAlt;                     \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyCtrl	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyCtrl;                    \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyMap	abstract-machine/libs/imgui/include/imgui.h	/^    int           KeyMap[ImGuiKey_COUNT];   \/\/ <unset>              \/\/ Map of indices into the KeysDown[512] entries array$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyRepeatDelay	abstract-machine/libs/imgui/include/imgui.h	/^    float         KeyRepeatDelay;           \/\/ = 0.250f             \/\/ When holding a key\/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyRepeatRate	abstract-machine/libs/imgui/include/imgui.h	/^    float         KeyRepeatRate;            \/\/ = 0.020f             \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeyShift	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyShift;                   \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeySuper	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeySuper;                   \/\/ Keyboard modifier pressed: Cmd\/Super\/Windows$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDown	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeysDown[512];              \/\/ Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDownDuration	abstract-machine/libs/imgui/include/imgui.h	/^    float       KeysDownDuration[512];      \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::KeysDownDurationPrev	abstract-machine/libs/imgui/include/imgui.h	/^    float       KeysDownDurationPrev[512];  \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::LogFilename	abstract-machine/libs/imgui/include/imgui.h	/^    const char*   LogFilename;              \/\/ = "imgui_log.txt"    \/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MemAllocFn	abstract-machine/libs/imgui/include/imgui.h	/^    void*       (*MemAllocFn)(size_t sz);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MemFreeFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*MemFreeFn)(void* ptr);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsActiveWindows	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsActiveWindows;       \/\/ Number of visible root windows (exclude child windows)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsAllocs	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsAllocs;              \/\/ Number of active memory allocations$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsRenderIndices	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsRenderIndices;       \/\/ Indices output during last call to Render() = number of triangles * 3$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MetricsRenderVertices	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsRenderVertices;      \/\/ Vertices output during last call to Render()$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClicked	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseClicked[5];            \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClickedPos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MouseClickedPos[5];         \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseClickedTime	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseClickedTime[5];        \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDelta	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MouseDelta;                 \/\/ Mouse delta. Note that this is zero if either current or previous position are negative, so a disappearing\/reappearing mouse won't have a huge delta for one frame.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClickMaxDist	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDoubleClickMaxDist;  \/\/ = 6.0f               \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClickTime	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDoubleClickTime;     \/\/ = 0.30f              \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDoubleClicked	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDoubleClicked[5];      \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDown	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDown[5];               \/\/ Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownDuration	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDownDuration[5];       \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownDurationPrev	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDownDurationPrev[5];   \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDownOwned	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDownOwned[5];          \/\/ Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDragMaxDistanceSqr	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDragMaxDistanceSqr[5]; \/\/ Squared maximum distance of how much mouse has traveled from the click point$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDragThreshold	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDragThreshold;       \/\/ = 6.0f               \/\/ Distance threshold before considering we are dragging$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseDrawCursor	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDrawCursor;            \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MousePos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MousePos;                   \/\/ Mouse position, in pixels (set to -1,-1 if no mouse \/ on another screen, etc.)$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MousePosPrev	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MousePosPrev;               \/\/ Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseReleased	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseReleased[5];           \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::MouseWheel	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseWheel;                 \/\/ Mouse wheel: 1 unit scrolls about 5 lines text.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::OSXBehaviors	abstract-machine/libs/imgui/include/imgui.h	/^    bool          OSXBehaviors;             \/\/ = defined(__APPLE__) \/\/ OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd\/Super instead of Ctrl, Line\/Text Start and End using Cmd+Arrows instead of Home\/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd\/Super instead of Ctrl$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::RenderDrawListsFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::SetClipboardTextFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*SetClipboardTextFn)(void* user_data, const char* text);$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*         UserData;                 \/\/ = NULL               \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::WantCaptureKeyboard	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantCaptureKeyboard;        \/\/ Widget is active (= ImGui will use your keyboard input). Use to hide keyboard from the rest of your application$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::WantCaptureMouse	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantCaptureMouse;           \/\/ Mouse is hovering a window or widget is active (= ImGui will use your mouse input). Use to hide mouse from the rest of your application$/;"	m	struct:ImGuiIO	access:public
ImGuiIO::WantTextInput	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantTextInput;              \/\/ Some text input widget is active, which will read input characters from the InputCharacters array. Use to activate on screen keyboard if your system needs one$/;"	m	struct:ImGuiIO	access:public
ImGuiIniData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiIniData$/;"	s
ImGuiIniData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiIniData;$/;"	x
ImGuiIniData::Collapsed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Collapsed;$/;"	m	struct:ImGuiIniData	access:public
ImGuiIniData::Id	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     Id;$/;"	m	struct:ImGuiIniData	access:public
ImGuiIniData::Name	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*       Name;$/;"	m	struct:ImGuiIniData	access:public
ImGuiIniData::Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Pos;$/;"	m	struct:ImGuiIniData	access:public
ImGuiIniData::Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Size;$/;"	m	struct:ImGuiIniData	access:public
ImGuiInputTextFlags	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiInputTextFlags;    \/\/ flags for InputText*()               \/\/ enum ImGuiInputTextFlags_$/;"	t
ImGuiInputTextFlags_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiInputTextFlags_$/;"	g
ImGuiInputTextFlags_AllowTabInput	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  \/\/ Pressing TAB input a '\\t' character into the text field$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysInsertMode	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  \/\/ Insert mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AutoSelectAll	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   \/\/ Select entire text when first taking mouse focus$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackAlways	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   \/\/ Call user function every time. User code may query cursor position, modify text buffer.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCharFilter	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   \/\/ Call user function to filter character. Modify data->EventChar to replace\/filter input, or return 1 to discard character.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCompletion	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   \/\/ Call user function on pressing TAB (for completion handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackHistory	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   \/\/ Call user function on pressing Up\/Down arrows (for history handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsDecimal	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   \/\/ Allow 0123456789.+-*\/$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsHexadecimal	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   \/\/ Allow 0123456789ABCDEFabcdef$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsNoBlank	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   \/\/ Filter out spaces, tabs$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsUppercase	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   \/\/ Turn a..z into A..Z$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CtrlEnterForNewLine	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  \/\/ In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_EnterReturnsTrue	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   \/\/ Return 'true' when Enter is pressed (as opposed to when the value was modified)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Multiline	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_Multiline           = 1 << 20   \/\/ For internal use by InputTextMultiline()$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoHorizontalScroll	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  \/\/ Disable following the cursor horizontally$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Password	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_Password            = 1 << 15,  \/\/ Password mode, display all characters as '*'$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_ReadOnly	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  \/\/ Read-only mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiKey	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiKey;               \/\/ a key identifier (ImGui-side enum)   \/\/ enum ImGuiKey_$/;"	t
ImGuiKey_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiKey_$/;"	g
ImGuiKey_A	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_A,         \/\/ for text edit CTRL+A: select all$/;"	e	enum:ImGuiKey_
ImGuiKey_Backspace	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Backspace, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_C	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_C,         \/\/ for text edit CTRL+C: copy$/;"	e	enum:ImGuiKey_
ImGuiKey_COUNT	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_COUNT$/;"	e	enum:ImGuiKey_
ImGuiKey_Delete	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Delete,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_DownArrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_DownArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_End	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_End,       \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Enter	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Enter,     \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Escape	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Escape,    \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Home	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Home,      \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_LeftArrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_LeftArrow, \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_PageDown	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_PageDown,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageUp	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_PageUp,$/;"	e	enum:ImGuiKey_
ImGuiKey_RightArrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_RightArrow,\/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_Tab	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Tab,       \/\/ for tabbing through fields$/;"	e	enum:ImGuiKey_
ImGuiKey_UpArrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_UpArrow,   \/\/ for text edit$/;"	e	enum:ImGuiKey_
ImGuiKey_V	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_V,         \/\/ for text edit CTRL+V: paste$/;"	e	enum:ImGuiKey_
ImGuiKey_X	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_X,         \/\/ for text edit CTRL+X: cut$/;"	e	enum:ImGuiKey_
ImGuiKey_Y	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Y,         \/\/ for text edit CTRL+Y: redo$/;"	e	enum:ImGuiKey_
ImGuiKey_Z	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey_Z,         \/\/ for text edit CTRL+Z: undo$/;"	e	enum:ImGuiKey_
ImGuiLayoutType	abstract-machine/libs/imgui/include/imgui_internal.h	/^typedef int ImGuiLayoutType;      \/\/ enum ImGuiLayoutType_$/;"	t
ImGuiLayoutType_	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiLayoutType_$/;"	g
ImGuiLayoutType_Horizontal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiLayoutType_Horizontal$/;"	e	enum:ImGuiLayoutType_
ImGuiLayoutType_Vertical	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiLayoutType_Vertical,$/;"	e	enum:ImGuiLayoutType_
ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } \/\/ NB: Begin() initialize every fields (as we allow user to call Begin\/End multiple times on a same instance if they want).$/;"	f	struct:ImGuiListClipper	access:public	signature:(int items_count = -1, float items_height = -1.0f)
ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiListClipper$/;"	s
ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiListClipper;            \/\/ Helper to manually clip large list of items$/;"	x
ImGuiListClipper::Begin	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void Begin(int items_count, float items_height = -1.0f);  \/\/ Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.$/;"	p	struct:ImGuiListClipper	access:public	signature:(int items_count, float items_height = -1.0f)
ImGuiListClipper::Begin	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiListClipper::Begin(int count, float items_height)$/;"	f	class:ImGuiListClipper	signature:(int count, float items_height)
ImGuiListClipper::DisplayEnd	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::DisplayStart	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::End	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void End();                                               \/\/ Automatically called on the last call of Step() that returns false.$/;"	p	struct:ImGuiListClipper	access:public	signature:()
ImGuiListClipper::End	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiListClipper::End()$/;"	f	class:ImGuiListClipper	signature:()
ImGuiListClipper::ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } \/\/ NB: Begin() initialize every fields (as we allow user to call Begin\/End multiple times on a same instance if they want).$/;"	f	struct:ImGuiListClipper	access:public	signature:(int items_count = -1, float items_height = -1.0f)
ImGuiListClipper::ItemsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::ItemsHeight	abstract-machine/libs/imgui/include/imgui.h	/^    float   ItemsHeight;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::StartPosY	abstract-machine/libs/imgui/include/imgui.h	/^    float   StartPosY;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::Step	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool Step();                                              \/\/ Call until it returns false. The DisplayStart\/DisplayEnd fields will be set and you can process\/draw those items.$/;"	p	struct:ImGuiListClipper	access:public	signature:()
ImGuiListClipper::Step	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiListClipper::Step()$/;"	f	class:ImGuiListClipper	signature:()
ImGuiListClipper::StepNo	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ImGuiListClipper::~ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      \/\/ Assert if user forgot to call End() or Step() until false.$/;"	f	struct:ImGuiListClipper	access:public	signature:()
ImGuiMouseCursor	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiMouseCursor;       \/\/ a mouse cursor identifier            \/\/ enum ImGuiMouseCursor_$/;"	t
ImGuiMouseCursorData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiMouseCursorData$/;"	s
ImGuiMouseCursorData	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiMouseCursorData;$/;"	x
ImGuiMouseCursorData::HotOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              HotOffset;$/;"	m	struct:ImGuiMouseCursorData	access:public
ImGuiMouseCursorData::Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              Size;$/;"	m	struct:ImGuiMouseCursorData	access:public
ImGuiMouseCursorData::TexUvMax	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              TexUvMax[2];$/;"	m	struct:ImGuiMouseCursorData	access:public
ImGuiMouseCursorData::TexUvMin	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              TexUvMin[2];$/;"	m	struct:ImGuiMouseCursorData	access:public
ImGuiMouseCursorData::Type	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursor    Type;$/;"	m	struct:ImGuiMouseCursorData	access:public
ImGuiMouseCursor_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiMouseCursor_$/;"	g
ImGuiMouseCursor_Arrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_Arrow = 0,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Count_	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_Count_$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Move	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_Move,              \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_None	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_None = -1,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeEW	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_ResizeEW,          \/\/ When hovering over a column$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNESW	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_ResizeNESW,        \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNS	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_ResizeNS,          \/\/ Unused$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNWSE	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_ResizeNWSE,        \/\/ When hovering over the bottom-right corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_TextInput	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiMouseCursor_TextInput,         \/\/ When hovering over InputText, etc.$/;"	e	enum:ImGuiMouseCursor_
ImGuiOnceUponAFrame	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:()
ImGuiOnceUponAFrame	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiOnceUponAFrame$/;"	s
ImGuiOnceUponAFrame	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiOnceUponAFrame;         \/\/ Simple helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro$/;"	x
ImGuiOnceUponAFrame::ImGuiOnceUponAFrame	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:()
ImGuiOnceUponAFrame::RefFrame	abstract-machine/libs/imgui/include/imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame	access:public
ImGuiOnceUponAFrame::operator bool	abstract-machine/libs/imgui/include/imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:() const
ImGuiPlotArrayGetterData	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData	access:public	signature:(const float* values, int stride)
ImGuiPlotArrayGetterData	abstract-machine/libs/imgui/src/imgui.cpp	/^struct ImGuiPlotArrayGetterData$/;"	s	file:
ImGuiPlotArrayGetterData::ImGuiPlotArrayGetterData	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData	access:public	signature:(const float* values, int stride)
ImGuiPlotArrayGetterData::Stride	abstract-machine/libs/imgui/src/imgui.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
ImGuiPlotArrayGetterData::Values	abstract-machine/libs/imgui/src/imgui.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
ImGuiPlotType	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiPlotType$/;"	g
ImGuiPlotType_Histogram	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiPlotType_Histogram$/;"	e	enum:ImGuiPlotType
ImGuiPlotType_Lines	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiPlotType_Lines,$/;"	e	enum:ImGuiPlotType
ImGuiPopupRef	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; MousePosOnOpen = mouse_pos; }$/;"	f	struct:ImGuiPopupRef	access:public	signature:(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos)
ImGuiPopupRef	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiPopupRef$/;"	s
ImGuiPopupRef	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiPopupRef;$/;"	x
ImGuiPopupRef::ImGuiPopupRef	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiPopupRef(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos) { PopupId = id; Window = NULL; ParentWindow = parent_window; ParentMenuSet = parent_menu_set; MousePosOnOpen = mouse_pos; }$/;"	f	struct:ImGuiPopupRef	access:public	signature:(ImGuiID id, ImGuiWindow* parent_window, ImGuiID parent_menu_set, const ImVec2& mouse_pos)
ImGuiPopupRef::MousePosOnOpen	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2          MousePosOnOpen; \/\/ Copy of mouse position at the time of opening popup$/;"	m	struct:ImGuiPopupRef	access:public
ImGuiPopupRef::ParentMenuSet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID         ParentMenuSet;  \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ImGuiPopupRef::ParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*    ParentWindow;   \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ImGuiPopupRef::PopupId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID         PopupId;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ImGuiPopupRef::Window	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*    Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ImGuiSelectableFlags	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiSelectableFlags;   \/\/ flags for Selectable()               \/\/ enum ImGuiSelectableFlags_$/;"	t
ImGuiSelectableFlagsPrivate_	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiSelectableFlagsPrivate_$/;"	g
ImGuiSelectableFlags_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiSelectableFlags_$/;"	g
ImGuiSelectableFlags_AllowDoubleClick	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2    \/\/ Generate press events on double clicks too$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_Disabled	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSelectableFlags_Disabled           = 1 << 5,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_DontClosePopups	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   \/\/ Clicking this don't close parent popup window$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DrawFillAvailWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 6$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_Menu	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSelectableFlags_Menu               = 1 << 3,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_MenuItem	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSelectableFlags_MenuItem           = 1 << 4,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SpanAllColumns	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   \/\/ Selectable frame can span all columns (text will still fit in current column)$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSetCond	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiSetCond;           \/\/ condition flags for Set*()           \/\/ enum ImGuiSetCond_$/;"	t
ImGuiSetCond_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiSetCond_$/;"	g
ImGuiSetCond_Always	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSetCond_Always        = 1 << 0, \/\/ Set the variable$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Appearing	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSetCond_Appearing     = 1 << 3  \/\/ Set the variable if the window is appearing after being hidden\/inactive (or the first time)$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_FirstUseEver	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSetCond_FirstUseEver  = 1 << 2, \/\/ Set the variable if the window has no saved data (if doesn't exist in the .ini file)$/;"	e	enum:ImGuiSetCond_
ImGuiSetCond_Once	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiSetCond_Once          = 1 << 1, \/\/ Set the variable once per runtime session (only the first call with succeed)$/;"	e	enum:ImGuiSetCond_
ImGuiSimpleColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSimpleColumns();$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:()
ImGuiSimpleColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct IMGUI_API ImGuiSimpleColumns$/;"	s
ImGuiSimpleColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiSimpleColumns;$/;"	x
ImGuiSimpleColumns	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiSimpleColumns::ImGuiSimpleColumns()$/;"	f	class:ImGuiSimpleColumns	signature:()
ImGuiSimpleColumns::CalcExtraSpace	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       CalcExtraSpace(float avail_w);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(float avail_w)
ImGuiSimpleColumns::CalcExtraSpace	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiSimpleColumns::CalcExtraSpace(float avail_w)$/;"	f	class:ImGuiSimpleColumns	signature:(float avail_w)
ImGuiSimpleColumns::Count	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int         Count;$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSimpleColumns::DeclColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       DeclColumns(float w0, float w1, float w2);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(float w0, float w1, float w2)
ImGuiSimpleColumns::DeclColumns	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiSimpleColumns::DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	class:ImGuiSimpleColumns	signature:(float w0, float w1, float w2)
ImGuiSimpleColumns::ImGuiSimpleColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSimpleColumns();$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:()
ImGuiSimpleColumns::ImGuiSimpleColumns	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiSimpleColumns::ImGuiSimpleColumns()$/;"	f	class:ImGuiSimpleColumns	signature:()
ImGuiSimpleColumns::NextWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSimpleColumns::NextWidths	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSimpleColumns::Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSimpleColumns::Spacing	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Spacing;$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSimpleColumns::Update	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Update(int count, float spacing, bool clear);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(int count, float spacing, bool clear)
ImGuiSimpleColumns::Update	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiSimpleColumns::Update(int count, float spacing, bool clear)$/;"	f	class:ImGuiSimpleColumns	signature:(int count, float spacing, bool clear)
ImGuiSimpleColumns::Width	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	access:public
ImGuiSizeConstraintCallback	abstract-machine/libs/imgui/include/imgui.h	/^typedef void (*ImGuiSizeConstraintCallback)(ImGuiSizeConstraintCallbackData* data);$/;"	t
ImGuiSizeConstraintCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiSizeConstraintCallbackData$/;"	s
ImGuiSizeConstraintCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiSizeConstraintCallbackData;\/\/ Structure used to constraint window size in custom ways when using custom ImGuiSizeConstraintCallback (rare\/advanced use)$/;"	x
ImGuiSizeConstraintCallbackData::CurrentSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  CurrentSize;    \/\/ Read-only.	Current window size.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
ImGuiSizeConstraintCallbackData::DesiredSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  DesiredSize;    \/\/ Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
ImGuiSizeConstraintCallbackData::Pos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  Pos;            \/\/ Read-only.	Window position, for reference.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
ImGuiSizeConstraintCallbackData::UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*   UserData;       \/\/ Read-only.   What user passed to SetNextWindowSizeConstraints()$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
ImGuiSliderFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^typedef int ImGuiSliderFlags;     \/\/ enum ImGuiSliderFlags_$/;"	t
ImGuiSliderFlags_	abstract-machine/libs/imgui/include/imgui_internal.h	/^enum ImGuiSliderFlags_$/;"	g
ImGuiSliderFlags_Vertical	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSliderFlags_Vertical               = 1 << 0$/;"	e	enum:ImGuiSliderFlags_
ImGuiStb	abstract-machine/libs/imgui/include/imgui_internal.h	/^namespace ImGuiStb$/;"	n
ImGuiStb	abstract-machine/libs/imgui/src/imgui.cpp	/^namespace ImGuiStb$/;"	n	file:
ImGuiStb::STB_TEXTEDIT_DELETECHARS	abstract-machine/libs/imgui/src/imgui.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int pos, int n)
ImGuiStb::STB_TEXTEDIT_GETCHAR	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }$/;"	f	namespace:ImGuiStb	signature:(const STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStb::STB_TEXTEDIT_GETWIDTH	abstract-machine/libs/imgui/src/imgui.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize \/ GImGui->Font->FontSize); }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)
ImGuiStb::STB_TEXTEDIT_INSERTCHARS	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
ImGuiStb::STB_TEXTEDIT_KEYTOTEXT	abstract-machine/libs/imgui/src/imgui.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }$/;"	f	namespace:ImGuiStb	signature:(int key)
ImGuiStb::STB_TEXTEDIT_LAYOUTROW	abstract-machine/libs/imgui/src/imgui.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	namespace:ImGuiStb	signature:(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
ImGuiStb::STB_TEXTEDIT_MOVEWORDLEFT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStb::STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStb::STB_TEXTEDIT_NEWLINE	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	m	namespace:ImGuiStb	file:
ImGuiStb::STB_TEXTEDIT_STRINGLEN	abstract-machine/libs/imgui/src/imgui.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	namespace:ImGuiStb	signature:(const STB_TEXTEDIT_STRING* obj)
ImGuiStb::is_separator	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	namespace:ImGuiStb	signature:(unsigned int c)
ImGuiStb::is_word_boundary_from_left	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->Text[idx-1] ) && is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStb::is_word_boundary_from_right	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->Text[idx-1] ) && !is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
ImGuiStorage	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiStorage$/;"	s
ImGuiStorage	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiStorage;                \/\/ Simple custom key value storage$/;"	x
ImGuiStorage::Clear	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      Clear();$/;"	p	struct:ImGuiStorage	access:public	signature:()
ImGuiStorage::Clear	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::Clear()$/;"	f	class:ImGuiStorage	signature:()
ImGuiStorage::Data	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<Pair>      Data;$/;"	m	struct:ImGuiStorage	access:public
ImGuiStorage::GetBool	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool default_val = false) const
ImGuiStorage::GetBool	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool default_val) const
ImGuiStorage::GetBoolRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool*     GetBoolRef(ImGuiID key, bool default_val = false);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool default_val = false)
ImGuiStorage::GetBoolRef	abstract-machine/libs/imgui/src/imgui.cpp	/^bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool default_val)
ImGuiStorage::GetFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f) const
ImGuiStorage::GetFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val) const
ImGuiStorage::GetFloatRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API float*    GetFloatRef(ImGuiID key, float default_val = 0.0f);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float default_val = 0.0f)
ImGuiStorage::GetFloatRef	abstract-machine/libs/imgui/src/imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float default_val)
ImGuiStorage::GetInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0) const
ImGuiStorage::GetInt	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGuiStorage::GetInt(ImGuiID key, int default_val) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val) const
ImGuiStorage::GetIntRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API int*      GetIntRef(ImGuiID key, int default_val = 0);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int default_val = 0)
ImGuiStorage::GetIntRef	abstract-machine/libs/imgui/src/imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int default_val)
ImGuiStorage::GetVoidPtr	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void*     GetVoidPtr(ImGuiID key) const; \/\/ default_val is NULL$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key) const
ImGuiStorage::GetVoidPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage	signature:(ImGuiID key) const
ImGuiStorage::GetVoidPtrRef	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void**    GetVoidPtrRef(ImGuiID key, void* default_val = NULL);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* default_val = NULL)
ImGuiStorage::GetVoidPtrRef	abstract-machine/libs/imgui/src/imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* default_val)
ImGuiStorage::Pair	abstract-machine/libs/imgui/include/imgui.h	/^    struct Pair$/;"	s	struct:ImGuiStorage	access:public
ImGuiStorage::Pair::Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, float _val_f)
ImGuiStorage::Pair::Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, int _val_i)
ImGuiStorage::Pair::Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, void* _val_p)
ImGuiStorage::Pair::__anon59::val_f	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
ImGuiStorage::Pair::__anon59::val_i	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
ImGuiStorage::Pair::__anon59::val_p	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
ImGuiStorage::Pair::key	abstract-machine/libs/imgui/include/imgui.h	/^        ImGuiID key;$/;"	m	struct:ImGuiStorage::Pair	access:public
ImGuiStorage::SetAllInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetAllInt(int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(int val)
ImGuiStorage::SetAllInt	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage	signature:(int v)
ImGuiStorage::SetBool	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetBool(ImGuiID key, bool val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool val)
ImGuiStorage::SetBool	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetBool(ImGuiID key, bool val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool val)
ImGuiStorage::SetFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetFloat(ImGuiID key, float val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float val)
ImGuiStorage::SetFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetFloat(ImGuiID key, float val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float val)
ImGuiStorage::SetInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetInt(ImGuiID key, int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int val)
ImGuiStorage::SetInt	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetInt(ImGuiID key, int val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int val)
ImGuiStorage::SetVoidPtr	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* val)
ImGuiStorage::SetVoidPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* val)
ImGuiStyle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStyle();$/;"	p	struct:ImGuiStyle	access:public	signature:()
ImGuiStyle	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiStyle$/;"	s
ImGuiStyle	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiStyle;                  \/\/ Runtime data for styling\/colors$/;"	x
ImGuiStyle	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle	signature:()
ImGuiStyle::Alpha	abstract-machine/libs/imgui/include/imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in ImGui$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::AntiAliasedLines	abstract-machine/libs/imgui/include/imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::AntiAliasedShapes	abstract-machine/libs/imgui/include/imgui.h	/^    bool        AntiAliasedShapes;          \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ButtonTextAlign	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ButtonTextAlign;            \/\/ Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ChildWindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       ChildWindowRounding;        \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::Colors	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ColumnsMinSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::CurveTessellationTol	abstract-machine/libs/imgui/include/imgui.h	/^    float       CurveTessellationTol;       \/\/ Tessellation tolerance. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::DisplaySafeAreaPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups\/tooltips as well regular windows.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::DisplayWindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::FramePadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::FrameRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::GrabMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::GrabRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ImGuiStyle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ImGuiStyle();$/;"	p	struct:ImGuiStyle	access:public	signature:()
ImGuiStyle::ImGuiStyle	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle	signature:()
ImGuiStyle::IndentSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ItemInnerSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ItemSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ScrollbarRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::ScrollbarSize	abstract-machine/libs/imgui/include/imgui.h	/^    float       ScrollbarSize;              \/\/ Width of the vertical scrollbar, Height of the horizontal scrollbar$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::TouchExtraPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyle::WindowTitleAlign	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowTitleAlign;           \/\/ Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.$/;"	m	struct:ImGuiStyle	access:public
ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, ImVec2 v)
ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, float v)
ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, int v)
ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiStyleMod$/;"	s
ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiStyleMod;$/;"	x
ImGuiStyleMod::ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, ImVec2 v)
ImGuiStyleMod::ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, float v)
ImGuiStyleMod::ImGuiStyleMod	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }$/;"	f	struct:ImGuiStyleMod	access:public	signature:(ImGuiStyleVar idx, int v)
ImGuiStyleMod::VarIdx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleVar   VarIdx;$/;"	m	struct:ImGuiStyleMod	access:public
ImGuiStyleMod::__anon40::BackupFloat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon40	access:public
ImGuiStyleMod::__anon40::BackupInt	abstract-machine/libs/imgui/include/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon40	access:public
ImGuiStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiStyleVar;          \/\/ a variable identifier for styling    \/\/ enum ImGuiStyleVar_$/;"	t
ImGuiStyleVarInfo	abstract-machine/libs/imgui/src/imgui.cpp	/^struct ImGuiStyleVarInfo$/;"	s	file:
ImGuiStyleVarInfo::GetVarPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^    void*           GetVarPtr() const { return (void*)((unsigned char*)&GImGui->Style + Offset); }$/;"	f	struct:ImGuiStyleVarInfo	access:public	signature:() const
ImGuiStyleVarInfo::Offset	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImU32           Offset;$/;"	m	struct:ImGuiStyleVarInfo	file:	access:public
ImGuiStyleVarInfo::Type	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImGuiDataType   Type;$/;"	m	struct:ImGuiStyleVarInfo	file:	access:public
ImGuiStyleVar_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiStyleVar_$/;"	g
ImGuiStyleVar_Alpha	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_Alpha,               \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ButtonTextAlign	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_ButtonTextAlign,     \/\/ flags ImGuiAlign_*$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildWindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_ChildWindowRounding, \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_Count_	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_Count_$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FramePadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_FramePadding,        \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameRounding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_FrameRounding,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_GrabMinSize,         \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_IndentSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_IndentSpacing,       \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemInnerSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_ItemInnerSpacing,    \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_ItemSpacing,         \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_WindowMinSize,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_WindowPadding,       \/\/ ImVec2$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiStyleVar_WindowRounding,      \/\/ float$/;"	e	enum:ImGuiStyleVar_
ImGuiTextBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTextBuffer()   { Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextBuffer$/;"	s
ImGuiTextBuffer	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextBuffer;             \/\/ Text buffer for logging\/accumulating text$/;"	x
ImGuiTextBuffer::Buf	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer	access:public
ImGuiTextBuffer::ImGuiTextBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTextBuffer()   { Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::append	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextBuffer::append(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, ...)
ImGuiTextBuffer::appendv	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      appendv(const char* fmt, va_list args);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, va_list args)
ImGuiTextBuffer::appendv	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextBuffer::appendv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, va_list args)
ImGuiTextBuffer::begin	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         begin() const { return &Buf.front(); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextBuffer::c_str	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         c_str() const { return Buf.Data; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextBuffer::clear	abstract-machine/libs/imgui/include/imgui.h	/^    void                clear() { Buf.clear(); Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::empty	abstract-machine/libs/imgui/include/imgui.h	/^    bool                empty() { return Buf.Size <= 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
ImGuiTextBuffer::end	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         end() const { return &Buf.back(); }      \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextBuffer::operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline char         operator[](int i) { return Buf.Data[i]; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:(int i)
ImGuiTextBuffer::size	abstract-machine/libs/imgui/include/imgui.h	/^    int                 size() const { return Buf.Size - 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
ImGuiTextEditCallback	abstract-machine/libs/imgui/include/imgui.h	/^typedef int (*ImGuiTextEditCallback)(ImGuiTextEditCallbackData *data);$/;"	t
ImGuiTextEditCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextEditCallbackData$/;"	s
ImGuiTextEditCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextEditCallbackData;   \/\/ Shared state of ImGui::InputText() when using custom ImGuiTextEditCallback (rare\/advanced use)$/;"	x
ImGuiTextEditCallbackData::Buf	abstract-machine/libs/imgui/include/imgui.h	/^    char*               Buf;            \/\/ Current text buffer                  \/\/ Read-write (pointed data only, can't replace the actual pointer)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::BufDirty	abstract-machine/libs/imgui/include/imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf\/BufTextLen!!   \/\/ Write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::BufSize	abstract-machine/libs/imgui/include/imgui.h	/^    int                 BufSize;        \/\/ Maximum text length in bytes         \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::BufTextLen	abstract-machine/libs/imgui/include/imgui.h	/^    int                 BufTextLen;     \/\/ Current text length in bytes         \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::CursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::DeleteChars	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void    DeleteChars(int pos, int bytes_count);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, int bytes_count)
ImGuiTextEditCallbackData::DeleteChars	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, int bytes_count)
ImGuiTextEditCallbackData::EventChar	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write (replace character or set to zero)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::EventFlag	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One of ImGuiInputTextFlags_Callback* \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::EventKey	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::Flags	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::HasSelection	abstract-machine/libs/imgui/include/imgui.h	/^    bool    HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiTextEditCallbackData	access:public	signature:() const
ImGuiTextEditCallbackData::InsertChars	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, const char* text, const char* text_end = NULL)
ImGuiTextEditCallbackData::InsertChars	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, const char* new_text, const char* new_text_end)
ImGuiTextEditCallbackData::ReadOnly	abstract-machine/libs/imgui/include/imgui.h	/^    bool                ReadOnly;       \/\/ Read-only mode                       \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::SelectionEnd	abstract-machine/libs/imgui/include/imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::SelectionStart	abstract-machine/libs/imgui/include/imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write (== to SelectionEnd when no selection)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditCallbackData::UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
ImGuiTextEditState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct IMGUI_API ImGuiTextEditState$/;"	s
ImGuiTextEditState	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiTextEditState;$/;"	x
ImGuiTextEditState::BufSizeA	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 BufSizeA;                   \/\/ end-user buffer size$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::ClearSelection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                ClearSelection()            { StbState.select_start = StbState.select_end = StbState.cursor; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::CurLenA	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::CurLenW	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                 CurLenA, CurLenW;           \/\/ we need to maintain our buffer length in both UTF-8 and wchar format.$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::CursorAnim	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float               CursorAnim;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::CursorAnimReset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                CursorAnimReset()           { CursorAnim = -0.30f; }                                   \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::CursorClamp	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                CursorClamp()               { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::CursorFollow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                CursorFollow;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::HasSelection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                HasSelection() const        { return StbState.select_start != StbState.select_end; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:() const
ImGuiTextEditState::Id	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID             Id;                         \/\/ widget id owning the text state$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::ImGuiTextEditState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextEditState()                            { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::InitialText	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<char>      InitialText;                \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::OnKeyPressed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                OnKeyPressed(int key);$/;"	p	struct:ImGuiTextEditState	access:public	signature:(int key)
ImGuiTextEditState::OnKeyPressed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditState::OnKeyPressed(int key)$/;"	f	class:ImGuiTextEditState	signature:(int key)
ImGuiTextEditState::ScrollX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float               ScrollX;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::SelectAll	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
ImGuiTextEditState::SelectedAllMouseLock	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                SelectedAllMouseLock;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::StbState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStb::STB_TexteditState   StbState;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::TempTextBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<char>      TempTextBuffer;$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextEditState::Text	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImWchar>   Text;                       \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiTextEditState	access:public
ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTextFilter(const char* default_filter = "");$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* default_filter = )
ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextFilter$/;"	s
ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^struct ImGuiTextFilter;             \/\/ Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"$/;"	x
ImGuiTextFilter	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter	signature:(const char* default_filter)
ImGuiTextFilter::Build	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      Build();$/;"	p	struct:ImGuiTextFilter	access:public	signature:()
ImGuiTextFilter::Build	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter	signature:()
ImGuiTextFilter::Clear	abstract-machine/libs/imgui/include/imgui.h	/^    void                Clear() { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
ImGuiTextFilter::CountGrep	abstract-machine/libs/imgui/include/imgui.h	/^    int                 CountGrep;$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::Draw	abstract-machine/libs/imgui/include/imgui.h	/^    bool                Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    \/\/ Helper calling InputText+Build$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* label = , float width = 0.0f)
ImGuiTextFilter::Draw	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter	signature:(const char* label, float width)
ImGuiTextFilter::Filters	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<TextRange> Filters;$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTextFilter(const char* default_filter = "");$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* default_filter = )
ImGuiTextFilter::ImGuiTextFilter	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter	signature:(const char* default_filter)
ImGuiTextFilter::InputBuf	abstract-machine/libs/imgui/include/imgui.h	/^    char                InputBuf[256];$/;"	m	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::IsActive	abstract-machine/libs/imgui/include/imgui.h	/^    bool                IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:() const
ImGuiTextFilter::PassFilter	abstract-machine/libs/imgui/include/imgui.h	/^    bool                PassFilter(const char* text, const char* text_end = NULL) const;$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* text, const char* text_end = NULL) const
ImGuiTextFilter::PassFilter	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const$/;"	f	class:ImGuiTextFilter	signature:(const char* text, const char* text_end) const
ImGuiTextFilter::TextRange	abstract-machine/libs/imgui/include/imgui.h	/^    struct TextRange$/;"	s	struct:ImGuiTextFilter	access:public
ImGuiTextFilter::TextRange::TextRange	abstract-machine/libs/imgui/include/imgui.h	/^        TextRange() { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
ImGuiTextFilter::TextRange::TextRange	abstract-machine/libs/imgui/include/imgui.h	/^        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(const char* _b, const char* _e)
ImGuiTextFilter::TextRange::b	abstract-machine/libs/imgui/include/imgui.h	/^        const char* b;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
ImGuiTextFilter::TextRange::begin	abstract-machine/libs/imgui/include/imgui.h	/^        const char* begin() const { return b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::e	abstract-machine/libs/imgui/include/imgui.h	/^        const char* e;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
ImGuiTextFilter::TextRange::empty	abstract-machine/libs/imgui/include/imgui.h	/^        bool empty() const { return b == e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::end	abstract-machine/libs/imgui/include/imgui.h	/^        const char* end() const { return e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::front	abstract-machine/libs/imgui/include/imgui.h	/^        char front() const { return *b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
ImGuiTextFilter::TextRange::is_blank	abstract-machine/libs/imgui/include/imgui.h	/^        static bool is_blank(char c) { return c == ' ' || c == '\\t'; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(char c)
ImGuiTextFilter::TextRange::split	abstract-machine/libs/imgui/include/imgui.h	/^        IMGUI_API void split(char separator, ImVector<TextRange>& out);$/;"	p	struct:ImGuiTextFilter::TextRange	access:public	signature:(char separator, ImVector<TextRange>& out)
ImGuiTextFilter::TextRange::split	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)$/;"	f	class:ImGuiTextFilter::TextRange	signature:(char separator, ImVector<TextRange>& out)
ImGuiTextFilter::TextRange::trim_blanks	abstract-machine/libs/imgui/include/imgui.h	/^        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
ImGuiTextFilter::~ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImGuiTextFilter() {}$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
ImGuiTreeNodeFlags	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiTreeNodeFlags;     \/\/ flags for TreeNode*(), Collapsing*() \/\/ enum ImGuiTreeNodeFlags_$/;"	t
ImGuiTreeNodeFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^typedef int ImGuiTreeNodeFlags;   \/\/ enum ImGuiTreeNodeFlags_$/;"	t
ImGuiTreeNodeFlags_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiTreeNodeFlags_$/;"	g
ImGuiTreeNodeFlags_AllowOverlapMode	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_AllowOverlapMode     = 1 << 2,   \/\/ Hit testing to allow subsequent widgets to overlap this one$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Bullet	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   \/\/ Display a bullet instead of arrow$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_CollapsingHeader	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoAutoOpenOnLog$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_DefaultOpen	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   \/\/ Default node to be open$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Framed	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_Framed               = 1 << 1,   \/\/ Full colored frame (e.g. for CollapsingHeader)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Leaf	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   \/\/ No collapsing, no arrow (use as a convenience for leaf nodes). $/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoAutoOpenOnLog	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   \/\/ Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoTreePushOnOpen	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   \/\/ Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnArrow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   \/\/ Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnDoubleClick	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   \/\/ Need double-click to open node$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Selected	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiTreeNodeFlags_Selected             = 1 << 0,   \/\/ Draw as selected$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow(const char* name);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* name)
ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct IMGUI_API ImGuiWindow$/;"	s
ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImGuiWindow;$/;"	x
ImGuiWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow::ImGuiWindow(const char* name)$/;"	f	class:ImGuiWindow	signature:(const char* name)
ImGuiWindow::Accessed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Accessed;                           \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Active	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Active;                             \/\/ Set to true on Begin()$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::AutoFitFramesX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::AutoFitFramesY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::AutoFitOnlyGrows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::AutoPosLastDirection	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     AutoPosLastDirection;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::BeginCount	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::BorderSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   BorderSize;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::CalcFontSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       CalcFontSize() const                    { return GImGui->FontBaseSize * FontWindowScale; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::ClipRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  ClipRect;                           \/\/ = DrawList->clip_rect_stack.back(). Scissoring \/ clipping rectangle. x1, y1, x2, y2.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Collapsed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ContentsRegionRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  ContentsRegionRect;                 \/\/ Maximum visible content position in window coordinates. ~~ (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::DC	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiDrawContext        DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::DrawList	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawList*             DrawList;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Flags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindowFlags        Flags;                              \/\/ See enum ImGuiWindowFlags_$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxAllCounter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllCounter;                 \/\/ Start at -1 and increase as assigned via FocusItemRegister()$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxAllRequestCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllRequestCurrent;          \/\/ Item being requested for focus$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxAllRequestNext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxAllRequestNext;             \/\/ Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxTabCounter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabCounter;                 \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxTabRequestCurrent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabRequestCurrent;          \/\/ Tab-able item being requested for focus$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FocusIdxTabRequestNext	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     FocusIdxTabRequestNext;             \/\/ "$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::FontWindowScale	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   FontWindowScale;                    \/\/ Scale multiplier per-window$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::GetID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetID(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* str, const char* str_end = NULL)
ImGuiWindow::GetID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetID(const void* ptr);$/;"	p	struct:ImGuiWindow	access:public	signature:(const void* ptr)
ImGuiWindow::GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
ImGuiWindow::GetID	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow	signature:(const void* ptr)
ImGuiWindow::GetIDNoKeepAlive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* str, const char* str_end = NULL)
ImGuiWindow::GetIDNoKeepAlive	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow	signature:(const char* str, const char* str_end)
ImGuiWindow::HiddenFrames	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     HiddenFrames;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ID;                                 \/\/ == ImHash(Name)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::IDStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow(const char* name);$/;"	p	struct:ImGuiWindow	access:public	signature:(const char* name)
ImGuiWindow::ImGuiWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow::ImGuiWindow(const char* name)$/;"	f	class:ImGuiWindow	signature:(const char* name)
ImGuiWindow::IndexWithinParent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     IndexWithinParent;                  \/\/ Order within immediate parent window, if we are a child window. Otherwise 0.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ItemWidthDefault	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::LastFrameActive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LastFrameActive;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::MenuBarHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::MenuBarRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::MenuColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSimpleColumns      MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::MoveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 MoveId;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Name	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*                   Name;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            ParentWindow;                       \/\/ If we are a child window, this is pointing to our parent window. Else point to NULL.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::PopupId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 PopupId;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Pos;                                \/\/ Position rounded-up to nearest pixel$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::PosFloat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  PosFloat;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Rect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::RootNonPopupWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            RootNonPopupWindow;                 \/\/ If we are a child window, this is pointing to the first non-child non-popup parent window. Else point to ourself.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::RootWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            RootWindow;                         \/\/ If we are a child window, this is pointing to the first non-child parent window. Else point to ourself.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Scroll	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Scroll;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ScrollTarget	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollTarget;                       \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ScrollTargetCenterRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollTargetCenterRatio;            \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ScrollbarSizes	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollbarSizes;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ScrollbarX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::ScrollbarY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SetWindowCollapsedAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowCollapsedAllowFlags;       \/\/ bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SetWindowPosAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowPosAllowFlags;             \/\/ bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SetWindowPosCenterWanted	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetWindowPosCenterWanted;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SetWindowSizeAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowSizeAllowFlags;            \/\/ bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SizeContents	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeContents;                       \/\/ Size of contents (== extents reach of the drawing cursor) from previous frame$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SizeContentsExplicit	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeContentsExplicit;               \/\/ Size of contents explicitly set by the user via SetNextWindowContentSize()$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SizeFull	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::SkipItems	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SkipItems;                          \/\/ == Visible && !Collapsed$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::StateStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::TitleBarHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::TitleBarRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
ImGuiWindow::WasActive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::WindowPadding	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::WindowRectClipped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  WindowRectClipped;                  \/\/ = WindowRect just after setup in Begin(). == window->Rect() for root window.$/;"	m	struct:ImGuiWindow	access:public
ImGuiWindow::~ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ~ImGuiWindow();$/;"	p	struct:ImGuiWindow	access:public	signature:()
ImGuiWindow::~ImGuiWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow	signature:()
ImGuiWindowFlags	abstract-machine/libs/imgui/include/imgui.h	/^typedef int ImGuiWindowFlags;       \/\/ window flags for Begin*()            \/\/ enum ImGuiWindowFlags_$/;"	t
ImGuiWindowFlags_	abstract-machine/libs/imgui/include/imgui.h	/^enum ImGuiWindowFlags_$/;"	g
ImGuiWindowFlags_AlwaysAutoResize	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   \/\/ Resize every window to its content every frame$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysHorizontalScrollbar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  \/\/ Always show horizontal scrollbar (even if ContentSize.x < Size.x)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysUseWindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  \/\/ Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysVerticalScrollbar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  \/\/ Always show vertical scrollbar (even if ContentSize.y < Size.y)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildMenu	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ChildMenu              = 1 << 27   \/\/ Don't use! For internal use by BeginMenu()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindow	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ChildWindow            = 1 << 20,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitX	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitX    = 1 << 21,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindowAutoFitY	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ChildWindowAutoFitY    = 1 << 22,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ComboBox	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ComboBox               = 1 << 23,  \/\/ Don't use! For internal use by ComboBox()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_HorizontalScrollbar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  \/\/ Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_MenuBar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_MenuBar                = 1 << 10,  \/\/ Has a menu-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Modal	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_Modal                  = 1 << 26,  \/\/ Don't use! For internal use by BeginPopupModal()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBringToFrontOnFocus	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  \/\/ Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoCollapse	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoCollapse             = 1 << 5,   \/\/ Disable user collapsing window by double-clicking on it$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoFocusOnAppearing	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  \/\/ Disable taking focus when transitioning from hidden to visible state$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoInputs	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoInputs               = 1 << 9,   \/\/ Disable catching mouse or keyboard inputs$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMove	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoMove                 = 1 << 2,   \/\/ Disable user moving the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoResize	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoResize               = 1 << 1,   \/\/ Disable user resizing with the lower-right grip$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoSavedSettings	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   \/\/ Never load\/save settings in .ini file$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollWithMouse	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   \/\/ Disable user vertically scrolling with mouse wheel$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollbar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   \/\/ Disable scrollbars (window can still scroll with mouse or programatically)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoTitleBar	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   \/\/ Disable title-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Popup	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_Popup                  = 1 << 25,  \/\/ Don't use! For internal use by BeginPopup()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ShowBorders	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_ShowBorders            = 1 << 7,   \/\/ Show borders around windows and items$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Tooltip	abstract-machine/libs/imgui/include/imgui.h	/^    ImGuiWindowFlags_Tooltip                = 1 << 24,  \/\/ Don't use! For internal use by BeginTooltip()$/;"	e	enum:ImGuiWindowFlags_
ImHash	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API ImU32         ImHash(const void* data, int data_size, ImU32 seed = 0);    \/\/ Pass data_size==0 for zero-terminated strings$/;"	p	signature:(const void* data, int data_size, ImU32 seed = 0)
ImHash	abstract-machine/libs/imgui/src/imgui.cpp	/^ImU32 ImHash(const void* data, int data_size, ImU32 seed)$/;"	f	signature:(const void* data, int data_size, ImU32 seed)
ImInvLength	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f \/ sqrtf(d); return fail_value; }$/;"	f	signature:(const ImVec2& lhs, float fail_value)
ImIsPointInTriangle	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API bool          ImIsPointInTriangle(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c);$/;"	p	signature:(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)
ImIsPointInTriangle	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImIsPointInTriangle(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)$/;"	f	signature:(const ImVec2& p, const ImVec2& a, const ImVec2& b, const ImVec2& c)
ImLengthSqr	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }$/;"	f	signature:(const ImVec2& lhs)
ImLengthSqr	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }$/;"	f	signature:(const ImVec4& lhs)
ImLerp	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }$/;"	f	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& t)
ImLerp	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImLerp(float a, float b, float t)                          { return a + (b - a) * t; }$/;"	f	signature:(float a, float b, float t)
ImMax	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMax(lhs.x,rhs.x), ImMax(lhs.y,rhs.y)); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
ImMax	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImMax(float lhs, float rhs)                                { return lhs >= rhs ? lhs : rhs; }$/;"	f	signature:(float lhs, float rhs)
ImMax	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline int    ImMax(int lhs, int rhs)                                    { return lhs >= rhs ? lhs : rhs; }$/;"	f	signature:(int lhs, int rhs)
ImMin	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(ImMin(lhs.x,rhs.x), ImMin(lhs.y,rhs.y)); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
ImMin	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImMin(float lhs, float rhs)                                { return lhs < rhs ? lhs : rhs; }$/;"	f	signature:(float lhs, float rhs)
ImMin	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline int    ImMin(int lhs, int rhs)                                    { return lhs < rhs ? lhs : rhs; }$/;"	f	signature:(int lhs, int rhs)
ImPlacementNewDummy	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImPlacementNewDummy {};$/;"	s
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect	access:public	signature:()
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& min, const ImVec2& max)
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec4& v)
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect	access:public	signature:(float x1, float y1, float x2, float y2)
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct IMGUI_API ImRect$/;"	s
ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^struct ImRect;$/;"	x
ImRect::Add	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Add(const ImRect& rhs)          { if (Min.x > rhs.Min.x) Min.x = rhs.Min.x; if (Min.y > rhs.Min.y) Min.y = rhs.Min.y; if (Max.x < rhs.Max.x) Max.x = rhs.Max.x; if (Max.y < rhs.Max.y) Max.y = rhs.Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& rhs)
ImRect::Add	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Add(const ImVec2& rhs)          { if (Min.x > rhs.x)     Min.x = rhs.x;     if (Min.y > rhs.y) Min.y = rhs.y;         if (Max.x < rhs.x) Max.x = rhs.x;         if (Max.y < rhs.y) Max.y = rhs.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& rhs)
ImRect::Clip	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Clip(const ImRect& clip)        { if (Min.x < clip.Min.x) Min.x = clip.Min.x; if (Min.y < clip.Min.y) Min.y = clip.Min.y; if (Max.x > clip.Max.x) Max.x = clip.Max.x; if (Max.y > clip.Max.y) Max.y = clip.Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& clip)
ImRect::Contains	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x < Max.x && r.Max.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
ImRect::Contains	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Contains(const ImVec2& p) const { return p.x >= Min.x     && p.y >= Min.y     && p.x < Max.x     && p.y < Max.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& p) const
ImRect::Expand	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Expand(const ImVec2& amount)    { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
ImRect::Expand	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Expand(const float amount)      { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }$/;"	f	struct:ImRect	access:public	signature:(const float amount)
ImRect::Floor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Floor()                         { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }$/;"	f	struct:ImRect	access:public	signature:()
ImRect::GetBL	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetBL() const                   { return ImVec2(Min.x, Max.y); }  \/\/ Bottom-left$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetBR	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetBR() const                   { return Max; }                   \/\/ Bottom-right$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetCenter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetCenter() const               { return ImVec2((Min.x+Max.x)*0.5f, (Min.y+Max.y)*0.5f); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetClosestPoint	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetClosestPoint(ImVec2 p, bool on_edge) const$/;"	f	struct:ImRect	access:public	signature:(ImVec2 p, bool on_edge) const
ImRect::GetHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       GetHeight() const               { return Max.y-Min.y; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetSize() const                 { return ImVec2(Max.x-Min.x, Max.y-Min.y); }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetTL	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetTL() const                   { return Min; }                   \/\/ Top-left$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetTR	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      GetTR() const                   { return ImVec2(Max.x, Min.y); }  \/\/ Top-right$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::GetWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       GetWidth() const                { return Max.x-Min.x; }$/;"	f	struct:ImRect	access:public	signature:() const
ImRect::ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect	access:public	signature:()
ImRect::ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& min, const ImVec2& max)
ImRect::ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect	access:public	signature:(const ImVec4& v)
ImRect::ImRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect	access:public	signature:(float x1, float y1, float x2, float y2)
ImRect::Max	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Max;    \/\/ Lower-right$/;"	m	struct:ImRect	access:public
ImRect::Min	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Min;    \/\/ Upper-left$/;"	m	struct:ImRect	access:public
ImRect::Overlaps	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
ImRect::Reduce	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Reduce(const ImVec2& amount)    { Min.x += amount.x; Min.y += amount.y; Max.x -= amount.x; Max.y -= amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
ImSaturate	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }$/;"	f	signature:(float f)
ImStrbolW	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API const ImWchar*ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin); \/\/ Find beginning-of-line$/;"	p	signature:(const ImWchar* buf_mid_line, const ImWchar* buf_begin)
ImStrbolW	abstract-machine/libs/imgui/src/imgui.cpp	/^const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) \/\/ find beginning-of-line$/;"	f	signature:(const ImWchar* buf_mid_line, const ImWchar* buf_begin)
ImStrdup	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API char*         ImStrdup(const char* str);$/;"	p	signature:(const char* str)
ImStrdup	abstract-machine/libs/imgui/src/imgui.cpp	/^char* ImStrdup(const char *str)$/;"	f	signature:(const char *str)
ImStricmp	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImStricmp(const char* str1, const char* str2);$/;"	p	signature:(const char* str1, const char* str2)
ImStricmp	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImStricmp(const char* str1, const char* str2)$/;"	f	signature:(const char* str1, const char* str2)
ImStristr	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API const char*   ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);$/;"	p	signature:(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
ImStristr	abstract-machine/libs/imgui/src/imgui.cpp	/^const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)$/;"	f	signature:(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
ImStrlenW	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImStrlenW(const ImWchar* str);$/;"	p	signature:(const ImWchar* str)
ImStrlenW	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImStrlenW(const ImWchar* str)$/;"	f	signature:(const ImWchar* str)
ImStrncpy	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImStrncpy(char* dst, const char* src, int count)$/;"	f	signature:(char* dst, const char* src, int count)
ImStrnicmp	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, int count);$/;"	p	signature:(const char* str1, const char* str2, int count)
ImStrnicmp	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImStrnicmp(const char* str1, const char* str2, int count)$/;"	f	signature:(const char* str1, const char* str2, int count)
ImTextCharFromUtf8	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          \/\/ return input UTF-8 bytes count$/;"	p	signature:(unsigned int* out_char, const char* in_text, const char* in_text_end)
ImTextCharFromUtf8	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)$/;"	f	signature:(unsigned int* out_char, const char* in_text, const char* in_text_end)
ImTextCharToUtf8	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)$/;"	f	file:	signature:(char* buf, int buf_size, unsigned int c)
ImTextCountCharsFromUtf8	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            \/\/ return number of UTF-8 code-points (NOT bytes count)$/;"	p	signature:(const char* in_text, const char* in_text_end)
ImTextCountCharsFromUtf8	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)$/;"	f	signature:(const char* in_text, const char* in_text_end)
ImTextCountUtf8BytesFromChar	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline int ImTextCountUtf8BytesFromChar(unsigned int c)$/;"	f	file:	signature:(unsigned int c)
ImTextCountUtf8BytesFromStr	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   \/\/ return number of bytes to express string as UTF-8 code-points$/;"	p	signature:(const ImWchar* in_text, const ImWchar* in_text_end)
ImTextCountUtf8BytesFromStr	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f	signature:(const ImWchar* in_text, const ImWchar* in_text_end)
ImTextStrFromUtf8	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   \/\/ return input UTF-8 bytes count$/;"	p	signature:(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL)
ImTextStrFromUtf8	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)$/;"	f	signature:(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
ImTextStrToUtf8	abstract-machine/libs/imgui/include/imgui_internal.h	/^IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end);      \/\/ return output UTF-8 bytes count$/;"	p	signature:(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
ImTextStrToUtf8	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f	signature:(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
ImTextureID	abstract-machine/libs/imgui/include/imgui.h	/^typedef void* ImTextureID;          \/\/ user data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)$/;"	t
ImU32	abstract-machine/libs/imgui/include/imgui.h	/^typedef unsigned int ImU32;         \/\/ 32-bit unsigned integer (typically used to store packed colors)$/;"	t
ImUpperPowerOfTwo	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }$/;"	f	signature:(int v)
ImVec2	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2() { x = y = 0.0f; }$/;"	f	struct:ImVec2	access:public	signature:()
ImVec2	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2	access:public	signature:(float _x, float _y)
ImVec2	abstract-machine/libs/imgui/include/imgui.h	/^struct ImVec2$/;"	s
ImVec2::ImVec2	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2() { x = y = 0.0f; }$/;"	f	struct:ImVec2	access:public	signature:()
ImVec2::ImVec2	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2	access:public	signature:(float _x, float _y)
ImVec2::x	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
ImVec2::y	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4() { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4	access:public	signature:()
ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4	access:public	signature:(float _x, float _y, float _z, float _w)
ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^struct ImVec4$/;"	s
ImVec4::ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4() { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4	access:public	signature:()
ImVec4::ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4	access:public	signature:(float _x, float _y, float _z, float _w)
ImVec4::w	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::x	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::y	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVec4::z	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
ImVector	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector()                  { Size = Capacity = 0; Data = NULL; }$/;"	f	class:ImVector	access:public	signature:()
ImVector	abstract-machine/libs/imgui/include/imgui.h	/^class ImVector$/;"	c
ImVector::Capacity	abstract-machine/libs/imgui/include/imgui.h	/^    int                         Capacity;$/;"	m	class:ImVector	access:public
ImVector::Data	abstract-machine/libs/imgui/include/imgui.h	/^    T*                          Data;$/;"	m	class:ImVector	access:public
ImVector::ImVector	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector()                  { Size = Capacity = 0; Data = NULL; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::Size	abstract-machine/libs/imgui/include/imgui.h	/^    int                         Size;$/;"	m	class:ImVector	access:public
ImVector::_grow_capacity	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
ImVector::back	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::back	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::begin	abstract-machine/libs/imgui/include/imgui.h	/^    inline const_iterator       begin() const                   { return Data; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::begin	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             begin()                         { return Data; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::capacity	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  capacity() const                { return Capacity; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::clear	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }$/;"	f	class:ImVector	access:public	signature:()
ImVector::const_iterator	abstract-machine/libs/imgui/include/imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	class:ImVector	access:public
ImVector::empty	abstract-machine/libs/imgui/include/imgui.h	/^    inline bool                 empty() const                   { return Size == 0; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::end	abstract-machine/libs/imgui/include/imgui.h	/^    inline const_iterator       end() const                     { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::end	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             end()                           { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::erase	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it)
ImVector::front	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::front	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::insert	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it, const value_type& v)
ImVector::iterator	abstract-machine/libs/imgui/include/imgui.h	/^    typedef value_type*         iterator;$/;"	t	class:ImVector	access:public
ImVector::operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i) const
ImVector::operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i)
ImVector::pop_back	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }$/;"	f	class:ImVector	access:public	signature:()
ImVector::push_back	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }$/;"	f	class:ImVector	access:public	signature:(const value_type& v)
ImVector::reserve	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 reserve(int new_capacity)$/;"	f	class:ImVector	access:public	signature:(int new_capacity)
ImVector::resize	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
ImVector::size	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  size() const                    { return Size; }$/;"	f	class:ImVector	access:public	signature:() const
ImVector::swap	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	class:ImVector	access:public	signature:(ImVector<T>& rhs)
ImVector::value_type	abstract-machine/libs/imgui/include/imgui.h	/^    typedef T                   value_type;$/;"	t	class:ImVector	access:public
ImVector::~ImVector	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImVector()                 { if (Data) ImGui::MemFree(Data); }$/;"	f	class:ImVector	access:public	signature:()
ImWchar	abstract-machine/libs/imgui/include/imgui.h	/^typedef unsigned short ImWchar;     \/\/ character for keyboard input\/display$/;"	t
Image	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0));$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), const ImVec4& tint_col = ImVec4(1,1,1,1), const ImVec4& border_col = ImVec4(0,0,0,0))
Image	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
ImageButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0),  const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1));    \/\/ <0 frame_padding uses default frame padding settings. 0 for no padding$/;"	p	namespace:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0,0), const ImVec2& uv1 = ImVec2(1,1), int frame_padding = -1, const ImVec4& bg_col = ImVec4(0,0,0,0), const ImVec4& tint_col = ImVec4(1,1,1,1))
ImageButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui	signature:(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
ImeSetInputScreenPosFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO	access:public
ImeSetInputScreenPosFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);$/;"	p	file:	signature:(int x, int y)
ImeSetInputScreenPosFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)$/;"	f	file:	signature:(int x, int y)
ImeSetInputScreenPosFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}$/;"	f	file:	signature:(int, int)
ImeWindowHandle	abstract-machine/libs/imgui/include/imgui.h	/^    void*       ImeWindowHandle;            \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO	access:public
Indent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Indent(float indent_w = 0.0f);                                      \/\/ move content position toward the right, by style.IndentSpacing or indent_w if >0$/;"	p	namespace:ImGui	signature:(float indent_w = 0.0f)
Indent	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Indent(float indent_w)$/;"	f	class:ImGui	signature:(float indent_w)
IndentSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).$/;"	m	struct:ImGuiStyle	access:public
IndentX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   IndentX;                \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiDrawContext	access:public
IndexLookup	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<unsigned short>    IndexLookup;        \/\/              \/\/ Sparse. Index glyphs by Unicode code-point.$/;"	m	struct:ImFont	access:public
IndexWithinParent	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     IndexWithinParent;                  \/\/ Order within immediate parent window, if we are a child window. Otherwise 0.$/;"	m	struct:ImGuiWindow	access:public
IndexXAdvance	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<float>             IndexXAdvance;      \/\/              \/\/ Sparse. Glyphs->XAdvance in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).$/;"	m	struct:ImFont	access:public
IniFilename	abstract-machine/libs/imgui/include/imgui.h	/^    const char*   IniFilename;              \/\/ = "imgui.ini"        \/\/ Path to .ini file. NULL to disable .ini saving.$/;"	m	struct:ImGuiIO	access:public
IniSavingRate	abstract-machine/libs/imgui/include/imgui.h	/^    float         IniSavingRate;            \/\/ = 5.0f               \/\/ Maximum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO	access:public
InitialText	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<char>      InitialText;                \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiTextEditState	access:public
Initialized	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    Initialized;$/;"	m	struct:ImGuiContext	access:public
InputBuf	abstract-machine/libs/imgui/include/imgui.h	/^    char                InputBuf[256];$/;"	m	struct:ImGuiTextFilter	access:public
InputBuf	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:	access:public
InputCharacters	abstract-machine/libs/imgui/include/imgui.h	/^    ImWchar     InputCharacters[16+1];      \/\/ List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO	access:public
InputFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0)
InputFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
InputFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
InputInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0)
InputInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
InputInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0)
InputInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
InputInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0)
InputInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
InputInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0)
InputInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
InputIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
InputIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
InputScalarAsWidgetReplacement	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision);$/;"	p	namespace:ImGui	signature:(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
InputScalarAsWidgetReplacement	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)$/;"	f	class:ImGui	signature:(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
InputScalarEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags);$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
InputScalarEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
InputText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputText	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextCalcTextLenAndLineCount	abstract-machine/libs/imgui/src/imgui.cpp	/^static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);$/;"	p	file:	signature:(const char* text_begin, const char** out_text_end)
InputTextCalcTextLenAndLineCount	abstract-machine/libs/imgui/src/imgui.cpp	/^static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)$/;"	f	file:	signature:(const char* text_begin, const char** out_text_end)
InputTextCalcTextSizeW	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);$/;"	p	file:	signature:(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false)
InputTextCalcTextSizeW	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)$/;"	f	file:	signature:(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
InputTextEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputTextEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextFilterCharacter	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data);$/;"	p	file:	signature:(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextFilterCharacter	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	file:	signature:(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextMultiline	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);$/;"	p	namespace:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0,0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL)
InputTextMultiline	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)$/;"	f	class:ImGui	signature:(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
InputTextPasswordFont	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImFont                  InputTextPasswordFont;$/;"	m	struct:ImGuiContext	access:public
InputTextState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextEditState      InputTextState;$/;"	m	struct:ImGuiContext	access:public
InsertChars	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);$/;"	p	struct:ImGuiTextEditCallbackData	access:public	signature:(int pos, const char* text, const char* text_end = NULL)
InsertChars	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiTextEditCallbackData	signature:(int pos, const char* new_text, const char* new_text_end)
Int_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  int         Int_Comp;$/;"	m	struct:record::__anon12::__anon13	file:	access:public
Int_Glob	abstract-machine/apps/dhrystone/dry.c	/^extern  int     Int_Glob;$/;"	x
Int_Glob	abstract-machine/apps/dhrystone/dry.c	/^int             Int_Glob;$/;"	v
InvisibleButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);$/;"	p	namespace:ImGui	signature:(const char* str_id, const ImVec2& size)
InvisibleButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* str_id, const ImVec2& size_arg)
IsActive	abstract-machine/libs/imgui/include/imgui.h	/^    bool                IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter	access:public	signature:() const
IsAnyItemActive	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsAnyItemActive();$/;"	p	namespace:ImGui	signature:()
IsAnyItemActive	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui	signature:()
IsAnyItemHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsAnyItemHovered();$/;"	p	namespace:ImGui	signature:()
IsAnyItemHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui	signature:()
IsClippedEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
IsClippedEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsClippedEx(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)$/;"	f	class:ImGui	signature:(const ImRect& bb, const ImGuiID* id, bool clip_even_when_logged)
IsHovered	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs = false);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, ImGuiID id, bool flatten_childs = false)
IsHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsHovered(const ImRect& bb, ImGuiID id, bool flatten_childs)$/;"	f	class:ImGui	signature:(const ImRect& bb, ImGuiID id, bool flatten_childs)
IsItemActive	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemActive();                                                     \/\/ was the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)$/;"	p	namespace:ImGui	signature:()
IsItemActive	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui	signature:()
IsItemClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                \/\/ was the last item clicked? (e.g. button\/node just clicked on)$/;"	p	namespace:ImGui	signature:(int mouse_button = 0)
IsItemClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemClicked(int mouse_button)$/;"	f	class:ImGui	signature:(int mouse_button)
IsItemHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemHovered();                                                    \/\/ was the last item hovered by mouse?$/;"	p	namespace:ImGui	signature:()
IsItemHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemHovered()$/;"	f	class:ImGui	signature:()
IsItemHoveredRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemHoveredRect();                                                \/\/ was the last item hovered by mouse? even if another item is active or window is blocked by popup while we are hovering this$/;"	p	namespace:ImGui	signature:()
IsItemHoveredRect	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemHoveredRect()$/;"	f	class:ImGui	signature:()
IsItemVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsItemVisible();                                                    \/\/ was the last item visible? (aka not out of sight due to clipping\/scrolling.)$/;"	p	namespace:ImGui	signature:()
IsItemVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui	signature:()
IsKeyDown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyDown(int user_key_index);                                      \/\/ is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices\/enums according to how your backend\/engine stored them into KeyDown[]!$/;"	p	namespace:ImGui	signature:(int user_key_index)
IsKeyDown	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyDown(int user_key_index)$/;"	f	class:ImGui	signature:(int user_key_index)
IsKeyPressed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               \/\/ was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay \/ KeyRepeatRate$/;"	p	namespace:ImGui	signature:(int user_key_index, bool repeat = true)
IsKeyPressed	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyPressed(int user_key_index, bool repeat)$/;"	f	class:ImGui	signature:(int user_key_index, bool repeat)
IsKeyPressedMap	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true);$/;"	p	file:	signature:(ImGuiKey key, bool repeat = true)
IsKeyPressedMap	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool IsKeyPressedMap(ImGuiKey key, bool repeat)$/;"	f	file:	signature:(ImGuiKey key, bool repeat)
IsKeyReleased	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsKeyReleased(int user_key_index);                                  \/\/ was key released (went from Down to !Down)..$/;"	p	namespace:ImGui	signature:(int user_key_index)
IsKeyReleased	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsKeyReleased(int user_key_index)$/;"	f	class:ImGui	signature:(int user_key_index)
IsLoaded	abstract-machine/libs/imgui/include/imgui.h	/^    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont	access:public	signature:() const
IsMouseClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    \/\/ did mouse button clicked (went from !Down to Down)$/;"	p	namespace:ImGui	signature:(int button, bool repeat = false)
IsMouseClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui	signature:(int button, bool repeat)
IsMouseDoubleClicked	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDoubleClicked(int button);                                   \/\/ did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.$/;"	p	namespace:ImGui	signature:(int button)
IsMouseDoubleClicked	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui	signature:(int button)
IsMouseDown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDown(int button);                                            \/\/ is mouse button held$/;"	p	namespace:ImGui	signature:(int button)
IsMouseDown	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui	signature:(int button)
IsMouseDragging	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      \/\/ is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold$/;"	p	namespace:ImGui	signature:(int button = 0, float lock_threshold = -1.0f)
IsMouseDragging	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui	signature:(int button, float lock_threshold)
IsMouseHoveringAnyWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringAnyWindow();                                         \/\/ is mouse hovering any visible window$/;"	p	namespace:ImGui	signature:()
IsMouseHoveringAnyWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringAnyWindow()$/;"	f	class:ImGui	signature:()
IsMouseHoveringRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  \/\/ is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus\/window ordering\/blocked by a popup.$/;"	p	namespace:ImGui	signature:(const ImVec2& r_min, const ImVec2& r_max, bool clip = true)
IsMouseHoveringRect	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)$/;"	f	class:ImGui	signature:(const ImVec2& r_min, const ImVec2& r_max, bool clip)
IsMouseHoveringWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseHoveringWindow();                                            \/\/ is mouse hovering current window ("window" in API names always refer to current window). disregarding of any consideration of being blocked by a popup. (unlike IsWindowHovered() this will return true even if the window is blocked because of a popup)$/;"	p	namespace:ImGui	signature:()
IsMouseHoveringWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseHoveringWindow()$/;"	f	class:ImGui	signature:()
IsMouseReleased	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsMouseReleased(int button);                                        \/\/ did mouse button released (went from Down to !Down)$/;"	p	namespace:ImGui	signature:(int button)
IsMouseReleased	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui	signature:(int button)
IsPopupOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool             IsPopupOpen(ImGuiID id);$/;"	p	file:	signature:(ImGuiID id)
IsPopupOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool IsPopupOpen(ImGuiID id)$/;"	f	file:	signature:(ImGuiID id)
IsPosHoveringAnyWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsPosHoveringAnyWindow(const ImVec2& pos);                          \/\/ is given position hovering any active imgui window$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
IsPosHoveringAnyWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsPosHoveringAnyWindow(const ImVec2& pos)$/;"	f	class:ImGui	signature:(const ImVec2& pos)
IsRectClipped	abstract-machine/libs/imgui/include/imgui.h	/^    static inline bool      IsRectClipped(const ImVec2& size) { return !IsRectVisible(size); } \/\/ OBSOLETE 1.39+$/;"	f	namespace:ImGui	signature:(const ImVec2& size)
IsRectVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      \/\/ test if rectangle (in screen space) is visible \/ not clipped. to perform coarse clipping on user's side.$/;"	p	namespace:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
IsRectVisible	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  \/\/ test if rectangle (of given size, starting from cursor position) is visible \/ not clipped.$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
IsRectVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui	signature:(const ImVec2& rect_min, const ImVec2& rect_max)
IsRectVisible	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
IsRootWindowFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowFocused();                                              \/\/ is current root window focused (root = top-most parent of a child, otherwise self)$/;"	p	namespace:ImGui	signature:()
IsRootWindowFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowFocused()$/;"	f	class:ImGui	signature:()
IsRootWindowOrAnyChildFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildFocused();                                    \/\/ is current root window or any of its child (including current window) focused$/;"	p	namespace:ImGui	signature:()
IsRootWindowOrAnyChildFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildFocused()$/;"	f	class:ImGui	signature:()
IsRootWindowOrAnyChildHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsRootWindowOrAnyChildHovered();                                    \/\/ is current root window or any of its child (including current window) hovered and hoverable (not blocked by a popup)$/;"	p	namespace:ImGui	signature:()
IsRootWindowOrAnyChildHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsRootWindowOrAnyChildHovered()$/;"	f	class:ImGui	signature:()
IsWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowCollapsed();$/;"	p	namespace:ImGui	signature:()
IsWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui	signature:()
IsWindowContentHoverable	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline bool      IsWindowContentHoverable(ImGuiWindow* window);$/;"	p	file:	signature:(ImGuiWindow* window)
IsWindowContentHoverable	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline bool IsWindowContentHoverable(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
IsWindowFocused	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowFocused();                                                  \/\/ is current window focused$/;"	p	namespace:ImGui	signature:()
IsWindowFocused	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowFocused()$/;"	f	class:ImGui	signature:()
IsWindowHovered	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          IsWindowHovered();                                                  \/\/ is current window hovered and hoverable (not blocked by a popup) (differentiate child windows from each others)$/;"	p	namespace:ImGui	signature:()
IsWindowHovered	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::IsWindowHovered()$/;"	f	class:ImGui	signature:()
ItemAdd	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          ItemAdd(const ImRect& bb, const ImGuiID* id);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, const ImGuiID* id)
ItemAdd	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ItemAdd(const ImRect& bb, const ImGuiID* id)$/;"	f	class:ImGui	signature:(const ImRect& bb, const ImGuiID* id)
ItemInnerSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)$/;"	m	struct:ImGuiStyle	access:public
ItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);$/;"	p	namespace:ImGui	signature:(const ImRect& bb, float text_offset_y = 0.0f)
ItemSize	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);$/;"	p	namespace:ImGui	signature:(const ImVec2& size, float text_offset_y = 0.0f)
ItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ItemSize(const ImRect& bb, float text_offset_y)$/;"	f	class:ImGui	signature:(const ImRect& bb, float text_offset_y)
ItemSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ItemSize(const ImVec2& size, float text_offset_y)$/;"	f	class:ImGui	signature:(const ImVec2& size, float text_offset_y)
ItemSpacing	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines$/;"	m	struct:ImGuiStyle	access:public
ItemWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiDrawContext	access:public
ItemWidthDefault	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow	access:public
ItemWidthStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiDrawContext	access:public
Items	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:	access:public
ItemsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
ItemsHeight	abstract-machine/libs/imgui/include/imgui.h	/^    float   ItemsHeight;$/;"	m	struct:ImGuiListClipper	access:public
Items_ArrayGetter	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool Items_ArrayGetter(void* data, int idx, const char** out_text)$/;"	f	file:	signature:(void* data, int idx, const char** out_text)
Items_SingleStringGetter	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)$/;"	f	file:	signature:(void* data, int idx, const char** out_text)
KB	abstract-machine/apps/microbench/include/benchmark.h	12;"	d
KEYDOWN_MASK	abstract-machine/am/src/native/devices/input.c	5;"	d	file:
KEYDOWN_MASK	abstract-machine/apps/typing/keyboard.c	39;"	d	file:
KEYNAME	amgame/src/game.c	20;"	d	file:
KEY_QUEUE_LEN	abstract-machine/am/src/native/devices/input.c	7;"	d	file:
KSEL	abstract-machine/am/include/x86.h	51;"	d
KeepAliveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          KeepAliveID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
KeepAliveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::KeepAliveID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
KeyAlt	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyAlt;                     \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO	access:public
KeyCtrl	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyCtrl;                    \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO	access:public
KeyMap	abstract-machine/libs/imgui/include/imgui.h	/^    int           KeyMap[ImGuiKey_COUNT];   \/\/ <unset>              \/\/ Map of indices into the KeysDown[512] entries array$/;"	m	struct:ImGuiIO	access:public
KeyRepeatDelay	abstract-machine/libs/imgui/include/imgui.h	/^    float         KeyRepeatDelay;           \/\/ = 0.250f             \/\/ When holding a key\/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).$/;"	m	struct:ImGuiIO	access:public
KeyRepeatRate	abstract-machine/libs/imgui/include/imgui.h	/^    float         KeyRepeatRate;            \/\/ = 0.020f             \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO	access:public
KeyShift	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeyShift;                   \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO	access:public
KeySuper	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeySuper;                   \/\/ Keyboard modifier pressed: Cmd\/Super\/Windows$/;"	m	struct:ImGuiIO	access:public
KeysDown	abstract-machine/libs/imgui/include/imgui.h	/^    bool        KeysDown[512];              \/\/ Keyboard keys that are pressed (in whatever storage order you naturally have access to keyboard data)$/;"	m	struct:ImGuiIO	access:public
KeysDownDuration	abstract-machine/libs/imgui/include/imgui.h	/^    float       KeysDownDuration[512];      \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO	access:public
KeysDownDurationPrev	abstract-machine/libs/imgui/include/imgui.h	/^    float       KeysDownDurationPrev[512];  \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO	access:public
LEFTROTATE	abstract-machine/apps/microbench/src/md5/md5.c	36;"	d	file:
LEVEL	abstract-machine/am/src/x86/qemu/devices/apic.c	23;"	d	file:
LIBS	abstract-machine/am/Makefile	/^LIBS := klib$/;"	m
LIBS	abstract-machine/apps/coremark/Makefile	/^LIBS = klib$/;"	m
LIBS	abstract-machine/apps/dhrystone/Makefile	/^LIBS = klib$/;"	m
LIBS	abstract-machine/apps/typing/Makefile	/^LIBS = klib$/;"	m
LIBS	abstract-machine/libs/imgui/Makefile	/^LIBS = klib$/;"	m
LINKLIST_DEF	abstract-machine/apps/typing/game.h	37;"	d
LINKLIST_DEF_FI	abstract-machine/apps/typing/game.h	41;"	d
LINKLIST_IMPL	abstract-machine/apps/typing/game.h	53;"	d
LINT0	abstract-machine/am/src/x86/qemu/devices/apic.c	32;"	d	file:
LINT1	abstract-machine/am/src/x86/qemu/devices/apic.c	33;"	d	file:
LOCKDECL	abstract-machine/am/src/x86/x86-qemu.h	47;"	d
LOCKDEF	abstract-machine/am/src/x86/x86-qemu.h	51;"	d
LZIP_LG	abstract-machine/apps/microbench/include/benchmark.h	48;"	d
LZIP_SM	abstract-machine/apps/microbench/include/benchmark.h	47;"	d
LabelText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, ...)
LabelTextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* label, const char* fmt, va_list args)
LabelTextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* label, const char* fmt, va_list args)
LastFrameActive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LastFrameActive;$/;"	m	struct:ImGuiWindow	access:public
LastItemHoveredAndUsable	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LastItemHoveredAndUsable;  \/\/ Item rectangle is hovered, and its window is currently interactable with (not blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext	access:public
LastItemHoveredRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LastItemHoveredRect;       \/\/ Item rectangle is hovered, but its window may or not be currently interactable with (might be blocked by a popup preventing access to the window)$/;"	m	struct:ImGuiDrawContext	access:public
LastItemId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 LastItemId;$/;"	m	struct:ImGuiDrawContext	access:public
LastItemRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiDrawContext	access:public
LayoutType	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiDrawContext	access:public
Lcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef long double _Complex Lcomplex;$/;"	t
Lcomplex	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { long double real, imaginary; } Lcomplex;$/;"	t	typeref:struct:__anon30
LineOffsets	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ImVector<int>       LineOffsets;        \/\/ Index to lines offset$/;"	m	struct:ExampleAppLog	file:	access:public
ListBox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1)
ListBox	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1);$/;"	p	namespace:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_in_items = -1)
ListBox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
ListBox	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char* const* items, int items_count, int height_items)$/;"	f	class:ImGui	signature:(const char* label, int* current_item, const char* const* items, int items_count, int height_items)
ListBoxFooter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ListBoxFooter();                                                    \/\/ terminate the scrolling region$/;"	p	namespace:ImGui	signature:()
ListBoxFooter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui	signature:()
ListBoxHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0,0)); \/\/ use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size = ImVec2(0,0))
ListBoxHeader	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); \/\/ "$/;"	p	namespace:ImGui	signature:(const char* label, int items_count, int height_in_items = -1)
ListBoxHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size_arg)
ListBoxHeader	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui	signature:(const char* label, int items_count, int height_in_items)
LoadIniSettingsFromDisk	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             LoadIniSettingsFromDisk(const char* ini_filename);$/;"	p	file:	signature:(const char* ini_filename)
LoadIniSettingsFromDisk	abstract-machine/libs/imgui/src/imgui.cpp	/^static void LoadIniSettingsFromDisk(const char* ini_filename)$/;"	f	file:	signature:(const char* ini_filename)
LogAutoExpandMaxDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LogAutoExpandMaxDepth;$/;"	m	struct:ImGuiContext	access:public
LogButtons	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogButtons();                                                       \/\/ helper to display buttons for logging to tty\/file\/clipboard$/;"	p	namespace:ImGui	signature:()
LogButtons	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui	signature:()
LogClipboard	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiTextBuffer*        LogClipboard;                       \/\/ Else log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiContext	access:public
LogEnabled	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiContext	access:public
LogFile	abstract-machine/libs/imgui/include/imgui_internal.h	/^    FILE*                   LogFile;                            \/\/ If != NULL log to stdout\/ file$/;"	m	struct:ImGuiContext	access:public
LogFilename	abstract-machine/libs/imgui/include/imgui.h	/^    const char*   LogFilename;              \/\/ = "imgui_log.txt"    \/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO	access:public
LogFinish	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogFinish();                                                        \/\/ stop logging (close file, etc.)$/;"	p	namespace:ImGui	signature:()
LogFinish	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui	signature:()
LogLinePosY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiDrawContext	access:public
LogRenderedText	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             LogRenderedText(const ImVec2& ref_pos, const char* text, const char* text_end = NULL);$/;"	p	file:	signature:(const ImVec2& ref_pos, const char* text, const char* text_end = NULL)
LogRenderedText	abstract-machine/libs/imgui/src/imgui.cpp	/^static void LogRenderedText(const ImVec2& ref_pos, const char* text, const char* text_end)$/;"	f	file:	signature:(const ImVec2& ref_pos, const char* text, const char* text_end)
LogStartDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     LogStartDepth;$/;"	m	struct:ImGuiContext	access:public
LogText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
LogToClipboard	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToClipboard(int max_depth = -1);                                 \/\/ start logging to OS clipboard$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
LogToClipboard	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToClipboard(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
LogToFile	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         \/\/ start logging to file$/;"	p	namespace:ImGui	signature:(int max_depth = -1, const char* filename = NULL)
LogToFile	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToFile(int max_depth, const char* filename)$/;"	f	class:ImGui	signature:(int max_depth, const char* filename)
LogToTTY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          LogToTTY(int max_depth = -1);                                       \/\/ start logging to tty$/;"	p	namespace:ImGui	signature:(int max_depth = -1)
LogToTTY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::LogToTTY(int max_depth)$/;"	f	class:ImGui	signature:(int max_depth)
LowerBound	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)$/;"	f	file:	signature:(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
M	abstract-machine/apps/microbench/src/fib/fib.c	/^static int M;$/;"	v	file:
MAGIC	abstract-machine/am/src/x86/qemu/devices/cpu.c	5;"	d	file:
MAGIC	abstract-machine/am/src/x86/qemu/trm.c	33;"	d	file:
MAIN_HAS_NOARGC	abstract-machine/apps/coremark/include/core_portme.h	148;"	d
MAIN_HAS_NORETURN	abstract-machine/apps/coremark/include/core_portme.h	159;"	d
MAIN_RETURN_TYPE	abstract-machine/apps/coremark/include/coremark.h	62;"	d
MAIN_RETURN_TYPE	abstract-machine/apps/coremark/include/coremark.h	65;"	d
MAIN_RETURN_VAL	abstract-machine/apps/coremark/include/coremark.h	61;"	d
MAIN_RETURN_VAL	abstract-machine/apps/coremark/include/coremark.h	64;"	d
MAP	abstract-machine/apps/litenes/src/psg.c	/^static int MAP[256] = {$/;"	v	file:
MASKED	abstract-machine/am/src/x86/qemu/devices/apic.c	35;"	d	file:
MATDAT	abstract-machine/apps/coremark/include/coremark.h	/^typedef ee_f16 MATDAT;$/;"	t
MATDAT	abstract-machine/apps/coremark/include/coremark.h	/^typedef ee_s16 MATDAT;$/;"	t
MATDAT_INT	abstract-machine/apps/coremark/include/coremark.h	103;"	d
MATRES	abstract-machine/apps/coremark/include/coremark.h	/^typedef ee_f32 MATRES;$/;"	t
MATRES	abstract-machine/apps/coremark/include/coremark.h	/^typedef ee_s32 MATRES;$/;"	t
MAT_PARAMS_S	abstract-machine/apps/coremark/include/coremark.h	/^typedef struct MAT_PARAMS_S {$/;"	s
MAT_PARAMS_S::A	abstract-machine/apps/coremark/include/coremark.h	/^	MATDAT *A;$/;"	m	struct:MAT_PARAMS_S	access:public
MAT_PARAMS_S::B	abstract-machine/apps/coremark/include/coremark.h	/^	MATDAT *B;$/;"	m	struct:MAT_PARAMS_S	access:public
MAT_PARAMS_S::C	abstract-machine/apps/coremark/include/coremark.h	/^	MATRES *C;$/;"	m	struct:MAT_PARAMS_S	access:public
MAT_PARAMS_S::N	abstract-machine/apps/coremark/include/coremark.h	/^	int N;$/;"	m	struct:MAT_PARAMS_S	access:public
MAXM	abstract-machine/apps/microbench/src/dinic/dinic.cpp	9;"	d	file:
MAXN	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^const int MAXN = 10;$/;"	v
MAXN	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^const int MAXN = 65536;$/;"	v
MAXN	abstract-machine/apps/microbench/src/dinic/dinic.cpp	5;"	d	file:
MAXN	abstract-machine/apps/microbench/src/dinic/dinic.cpp	7;"	d	file:
MAX_CPU	abstract-machine/am/src/x86/x86-qemu.h	10;"	d
MB	abstract-machine/apps/microbench/include/benchmark.h	11;"	d
MD5_LG	abstract-machine/apps/microbench/include/benchmark.h	52;"	d
MD5_SM	abstract-machine/apps/microbench/include/benchmark.h	51;"	d
MEM_H	abstract-machine/apps/litenes/include/memory.h	2;"	d
MEM_LOCATION	abstract-machine/apps/coremark/include/core_portme.h	69;"	d
MEM_MALLOC	abstract-machine/apps/coremark/include/coremark.h	35;"	d
MEM_METHOD	abstract-machine/apps/coremark/include/core_portme.h	112;"	d
MEM_METHOD	abstract-machine/apps/coremark/include/core_portme.h	12;"	d
MEM_STACK	abstract-machine/apps/coremark/include/coremark.h	36;"	d
MEM_STATIC	abstract-machine/apps/coremark/include/coremark.h	34;"	d
MINOFFSET	abstract-machine/apps/microbench/src/lzip/quicklz.c	18;"	d	file:
MMC_MAX_PAGE_COUNT	abstract-machine/apps/litenes/src/mmc.c	5;"	d	file:
MPConf	abstract-machine/am/include/x86.h	/^typedef struct MPConf {    \/\/ configuration table header$/;"	s
MPConf	abstract-machine/am/include/x86.h	/^} MPConf;$/;"	t	typeref:struct:MPConf
MPConf::checksum	abstract-machine/am/include/x86.h	/^  uint8_t  checksum;        \/\/ all bytes must add up to 0$/;"	m	struct:MPConf	access:public
MPConf::entry	abstract-machine/am/include/x86.h	/^  uint16_t entry;          \/\/ entry count$/;"	m	struct:MPConf	access:public
MPConf::lapicaddr	abstract-machine/am/include/x86.h	/^  uint32_t *lapicaddr;     \/\/ address of local APIC$/;"	m	struct:MPConf	access:public
MPConf::length	abstract-machine/am/include/x86.h	/^  uint16_t length;         \/\/ total table length$/;"	m	struct:MPConf	access:public
MPConf::oemlength	abstract-machine/am/include/x86.h	/^  uint16_t oemlength;      \/\/ OEM table length$/;"	m	struct:MPConf	access:public
MPConf::oemtable	abstract-machine/am/include/x86.h	/^  uint32_t *oemtable;      \/\/ OEM table pointer$/;"	m	struct:MPConf	access:public
MPConf::product	abstract-machine/am/include/x86.h	/^  uint8_t  product[20];     \/\/ product id$/;"	m	struct:MPConf	access:public
MPConf::reserved	abstract-machine/am/include/x86.h	/^  uint8_t  reserved;$/;"	m	struct:MPConf	access:public
MPConf::signature	abstract-machine/am/include/x86.h	/^  uint8_t  signature[4];    \/\/ "PCMP"$/;"	m	struct:MPConf	access:public
MPConf::version	abstract-machine/am/include/x86.h	/^  uint8_t  version;         \/\/ [14]$/;"	m	struct:MPConf	access:public
MPConf::xchecksum	abstract-machine/am/include/x86.h	/^  uint8_t  xchecksum;       \/\/ extended table checksum$/;"	m	struct:MPConf	access:public
MPConf::xlength	abstract-machine/am/include/x86.h	/^  uint16_t xlength;        \/\/ extended table length$/;"	m	struct:MPConf	access:public
MPDesc	abstract-machine/am/include/x86.h	/^typedef struct MPDesc {$/;"	s
MPDesc	abstract-machine/am/include/x86.h	/^} MPDesc;$/;"	t	typeref:struct:MPDesc
MPDesc::checksum	abstract-machine/am/include/x86.h	/^  uint8_t checksum; \/\/ all bytes add to 0$/;"	m	struct:MPDesc	access:public
MPDesc::conf	abstract-machine/am/include/x86.h	/^  MPConf  *conf;     \/\/ MP config table addr$/;"	m	struct:MPDesc	access:public
MPDesc::imcrp	abstract-machine/am/include/x86.h	/^  uint8_t imcrp;$/;"	m	struct:MPDesc	access:public
MPDesc::length	abstract-machine/am/include/x86.h	/^  uint8_t length;   \/\/ 1$/;"	m	struct:MPDesc	access:public
MPDesc::magic	abstract-machine/am/include/x86.h	/^  int     magic;$/;"	m	struct:MPDesc	access:public
MPDesc::reserved	abstract-machine/am/include/x86.h	/^  uint8_t reserved[3];$/;"	m	struct:MPDesc	access:public
MPDesc::specrev	abstract-machine/am/include/x86.h	/^  uint8_t specrev;  \/\/ [14]$/;"	m	struct:MPDesc	access:public
MPDesc::type	abstract-machine/am/include/x86.h	/^  uint8_t type;     \/\/ config type$/;"	m	struct:MPDesc	access:public
MSG	abstract-machine/am/src/x86/qemu/cte.c	67;"	d	file:
MULTITHREAD	abstract-machine/apps/coremark/include/core_portme.h	131;"	d
MYTIMEDIFF	abstract-machine/apps/coremark/src/core_portme.c	34;"	d	file:
M_common	abstract-machine/apps/litenes/src/common.c	6;"	d	file:
MarkIniSettingsDirty	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             MarkIniSettingsDirty();$/;"	p	file:	signature:()
MarkIniSettingsDirty	abstract-machine/libs/imgui/src/imgui.cpp	/^static void MarkIniSettingsDirty()$/;"	f	file:	signature:()
Max	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Max;    \/\/ Lower-right$/;"	m	struct:ImRect	access:public
Maxflow	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int Maxflow(int s, int t) {$/;"	f	struct:Dinic	access:public	signature:(int s, int t)
MemAlloc	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void*         MemAlloc(size_t sz);$/;"	p	namespace:ImGui	signature:(size_t sz)
MemAlloc	abstract-machine/libs/imgui/src/imgui.cpp	/^void* ImGui::MemAlloc(size_t sz)$/;"	f	class:ImGui	signature:(size_t sz)
MemAllocFn	abstract-machine/libs/imgui/include/imgui.h	/^    void*       (*MemAllocFn)(size_t sz);$/;"	m	struct:ImGuiIO	access:public
MemFree	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          MemFree(void* ptr);$/;"	p	namespace:ImGui	signature:(void* ptr)
MemFree	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui	signature:(void* ptr)
MemFreeFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*MemFreeFn)(void* ptr);$/;"	m	struct:ImGuiIO	access:public
MenuBarAppending	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    MenuBarAppending;$/;"	m	struct:ImGuiDrawContext	access:public
MenuBarHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       MenuBarHeight() const                   { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
MenuBarOffsetX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   MenuBarOffsetX;$/;"	m	struct:ImGuiDrawContext	access:public
MenuBarRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      MenuBarRect() const                     { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
MenuColumns	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSimpleColumns      MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow	access:public
MenuItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true);  \/\/ return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true)
MenuItem	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true);              \/\/ return true when activated + toggle (*p_selected) if p_selected != NULL$/;"	p	namespace:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled = true)
MenuItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool selected, bool enabled)
MenuItem	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui	signature:(const char* label, const char* shortcut, bool* p_selected, bool enabled)
MergeMode	abstract-machine/libs/imgui/include/imgui.h	/^    bool            MergeMode;                  \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.$/;"	m	struct:ImFontConfig	access:public
MetricsActiveWindows	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsActiveWindows;       \/\/ Number of visible root windows (exclude child windows)$/;"	m	struct:ImGuiIO	access:public
MetricsAllocs	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsAllocs;              \/\/ Number of active memory allocations$/;"	m	struct:ImGuiIO	access:public
MetricsRenderIndices	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsRenderIndices;       \/\/ Indices output during last call to Render() = number of triangles * 3$/;"	m	struct:ImGuiIO	access:public
MetricsRenderVertices	abstract-machine/libs/imgui/include/imgui.h	/^    int         MetricsRenderVertices;      \/\/ Vertices output during last call to Render()$/;"	m	struct:ImGuiIO	access:public
MetricsTotalSurface	abstract-machine/libs/imgui/include/imgui.h	/^    int                         MetricsTotalSurface;\/\/              \/\/ Total surface in pixels to get an idea of the font rasterization\/texture cost (not exact, we approximate the cost of padding between glyphs)$/;"	m	struct:ImFont	access:public
Microseconds	abstract-machine/apps/dhrystone/dry.c	/^float           Microseconds,$/;"	v
Min	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Min;    \/\/ Upper-left$/;"	m	struct:ImRect	access:public
ModalWindowDarkeningRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   ModalWindowDarkeningRatio;$/;"	m	struct:ImGuiContext	access:public
MouseClicked	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseClicked[5];            \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO	access:public
MouseClickedPos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MouseClickedPos[5];         \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO	access:public
MouseClickedTime	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseClickedTime[5];        \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO	access:public
MouseCursor	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiContext	access:public
MouseCursorData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursorData    MouseCursorData[ImGuiMouseCursor_Count_];$/;"	m	struct:ImGuiContext	access:public
MouseDelta	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MouseDelta;                 \/\/ Mouse delta. Note that this is zero if either current or previous position are negative, so a disappearing\/reappearing mouse won't have a huge delta for one frame.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClickMaxDist	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDoubleClickMaxDist;  \/\/ = 6.0f               \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClickTime	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDoubleClickTime;     \/\/ = 0.30f              \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO	access:public
MouseDoubleClicked	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDoubleClicked[5];      \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO	access:public
MouseDown	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDown[5];               \/\/ Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO	access:public
MouseDownDuration	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDownDuration[5];       \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO	access:public
MouseDownDurationPrev	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDownDurationPrev[5];   \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO	access:public
MouseDownOwned	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDownOwned[5];          \/\/ Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO	access:public
MouseDragMaxDistanceSqr	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseDragMaxDistanceSqr[5]; \/\/ Squared maximum distance of how much mouse has traveled from the click point$/;"	m	struct:ImGuiIO	access:public
MouseDragThreshold	abstract-machine/libs/imgui/include/imgui.h	/^    float         MouseDragThreshold;       \/\/ = 6.0f               \/\/ Distance threshold before considering we are dragging$/;"	m	struct:ImGuiIO	access:public
MouseDrawCursor	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseDrawCursor;            \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).$/;"	m	struct:ImGuiIO	access:public
MousePos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MousePos;                   \/\/ Mouse position, in pixels (set to -1,-1 if no mouse \/ on another screen, etc.)$/;"	m	struct:ImGuiIO	access:public
MousePosOnOpen	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2          MousePosOnOpen; \/\/ Copy of mouse position at the time of opening popup$/;"	m	struct:ImGuiPopupRef	access:public
MousePosPrev	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      MousePosPrev;               \/\/ Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())$/;"	m	struct:ImGuiIO	access:public
MouseReleased	abstract-machine/libs/imgui/include/imgui.h	/^    bool        MouseReleased[5];           \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO	access:public
MouseWheel	abstract-machine/libs/imgui/include/imgui.h	/^    float       MouseWheel;                 \/\/ Mouse wheel: 1 unit scrolls about 5 lines text.$/;"	m	struct:ImGuiIO	access:public
MoveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 MoveId;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow	access:public
MovedWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            MovedWindow;                        \/\/ Track the child window we clicked on to move a window.$/;"	m	struct:ImGuiContext	access:public
MovedWindowMoveId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 MovedWindowMoveId;                  \/\/ == MovedWindow->RootWindow->MoveId$/;"	m	struct:ImGuiContext	access:public
N	abstract-machine/apps/coremark/include/coremark.h	/^	int N;$/;"	m	struct:MAT_PARAMS_S	access:public
N	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^const int N = 4;$/;"	v
N	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^static int N;$/;"	v	file:
N	abstract-machine/apps/microbench/src/fib/fib.c	5;"	d	file:
N	abstract-machine/apps/microbench/src/md5/md5.c	/^static int N;$/;"	v	file:
N	abstract-machine/apps/microbench/src/qsort/qsort.c	/^static int N, *data;$/;"	v	file:
N	abstract-machine/apps/microbench/src/sieve/sieve.c	/^static int N;$/;"	v	file:
N	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^static int N;$/;"	v	file:
NAME	abstract-machine/am/Makefile	/^NAME := am$/;"	m
NAME	abstract-machine/apps/coremark/Makefile	/^NAME = coremark$/;"	m
NAME	abstract-machine/apps/dhrystone/Makefile	/^NAME = dhrystone$/;"	m
NAME	abstract-machine/apps/hello/Makefile	/^NAME = hello$/;"	m
NAME	abstract-machine/apps/litenes/Makefile	/^NAME = litenes$/;"	m
NAME	abstract-machine/apps/microbench/Makefile	/^NAME = microbench$/;"	m
NAME	abstract-machine/apps/slider/Makefile	/^NAME = slider$/;"	m
NAME	abstract-machine/apps/typing/Makefile	/^NAME = typing$/;"	m
NAME	abstract-machine/libs/compiler-rt/Makefile	/^NAME = compiler-rt$/;"	m
NAME	abstract-machine/libs/fixmath/Makefile	/^NAME = fixmath$/;"	m
NAME	abstract-machine/libs/imgui/Makefile	/^NAME = imgui$/;"	m
NAME	abstract-machine/libs/klib/Makefile	/^NAME = klib$/;"	m
NAME	amgame/Makefile	/^NAME := amgame$/;"	m
NAME	pstree/Makefile	/^NAME := $(shell basename $(PWD))$/;"	m
NELEM	abstract-machine/am/src/x86/x86-qemu.h	28;"	d
NOERR	abstract-machine/am/src/x86/qemu/cte_trap.S	/^#define NOERR     pushl $0$/;"	d
NOINLINE	abstract-machine/libs/compiler-rt/int_lib.h	48;"	d
NOINLINE	abstract-machine/libs/compiler-rt/int_lib.h	53;"	d
NORETURN	abstract-machine/libs/compiler-rt/int_lib.h	49;"	d
NORETURN	abstract-machine/libs/compiler-rt/int_lib.h	54;"	d
NR_IMG	abstract-machine/apps/slider/main.cpp	6;"	d	file:
NR_IRQ	abstract-machine/am/include/x86.h	55;"	d
NR_PDE	abstract-machine/am/include/x86.h	29;"	d
NR_PTE	abstract-machine/am/include/x86.h	30;"	d
NR_SEG	abstract-machine/am/include/x86.h	45;"	d
NSECS_PER_SEC	abstract-machine/apps/coremark/src/core_portme.c	31;"	d	file:
NULL	abstract-machine/apps/typing/game.h	8;"	d
NUMBER_OF_RUNS	abstract-machine/apps/dhrystone/dry.c	359;"	d	file:
NUM_ALGORITHMS	abstract-machine/apps/coremark/include/coremark.h	88;"	d
NUM_CORE_STATES	abstract-machine/apps/coremark/include/coremark.h	/^	NUM_CORE_STATES$/;"	e	enum:CORE_STATE
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle( N_puzzle const & );$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & )
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle( int array[N*N] );$/;"	p	class:N_puzzle	access:public	signature:( int array[N*N] )
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle();$/;"	p	class:N_puzzle	access:public	signature:()
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle( N_puzzle const &pz ):$/;"	f	class:N_puzzle	signature:( N_puzzle const &pz )
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle( int array[N*N] ):$/;"	f	class:N_puzzle	signature:( int array[N*N] )
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle():$/;"	f	class:N_puzzle	signature:()
N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^class N_puzzle {$/;"	c
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle( N_puzzle const & );$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & )
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle( int array[N*N] );$/;"	p	class:N_puzzle	access:public	signature:( int array[N*N] )
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle();$/;"	p	class:N_puzzle	access:public	signature:()
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle( N_puzzle const &pz ):$/;"	f	class:N_puzzle	signature:( N_puzzle const &pz )
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle( int array[N*N] ):$/;"	f	class:N_puzzle	signature:( int array[N*N] )
N_puzzle::N_puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N>::N_puzzle():$/;"	f	class:N_puzzle	signature:()
N_puzzle::abs	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    static int abs( int n ) { return ( n < 0 ) ? -n : n; }$/;"	f	class:N_puzzle	access:private	signature:( int n )
N_puzzle::determine_hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    void determine_hash();$/;"	p	class:N_puzzle	access:private	signature:()
N_puzzle::determine_hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^void N_puzzle<N>::determine_hash() {$/;"	f	class:N_puzzle	signature:()
N_puzzle::hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    unsigned int hash() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^unsigned int N_puzzle<N>::hash() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::hash_value	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int hash_value;$/;"	m	class:N_puzzle	access:private
N_puzzle::lower_bound	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int lower_bound() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::lower_bound	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^int N_puzzle<N>::lower_bound() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::manhattan_distance	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int8_t manhattan_distance;$/;"	m	class:N_puzzle	access:private
N_puzzle::operator !=	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool operator!=( N_puzzle const & ) const;$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & ) const
N_puzzle::operator !=	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::operator!=( N_puzzle const &rhs ) const {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs ) const
N_puzzle::operator =	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle &operator=( N_puzzle const & );$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & )
N_puzzle::operator =	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> &N_puzzle<N>::operator=( N_puzzle const &rhs ) {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs )
N_puzzle::operator ==	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool operator==( N_puzzle const & ) const;$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & ) const
N_puzzle::operator ==	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::operator==( N_puzzle const &rhs ) const {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs ) const
N_puzzle::puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int8_t puzzle[N][N];$/;"	m	class:N_puzzle	access:private
N_puzzle::puzzle_valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool puzzle_valid;$/;"	m	class:N_puzzle	access:private
N_puzzle::solution	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle static solution();$/;"	p	class:N_puzzle	access:public	signature:()
N_puzzle::solution	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::solution() {$/;"	f	class:N_puzzle	signature:()
N_puzzle::solvable	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool solvable() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::solvable	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::solvable() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_down	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_down() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_down	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_down() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_down_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_down_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_down_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_down_possible() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_left	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_left() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_left	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_left() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_left_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_left_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_left_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_left_possible() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_right	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_right() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_right	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_right() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_right_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_right_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_right_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_right_possible() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_up	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_up() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_up	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_up() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::tile_up_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_up_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::tile_up_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_up_possible() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool valid() const;$/;"	p	class:N_puzzle	access:public	signature:() const
N_puzzle::valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::valid() const {$/;"	f	class:N_puzzle	signature:() const
N_puzzle::zero_i	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    uint8_t zero_i, zero_j;$/;"	m	class:N_puzzle	access:private
N_puzzle::zero_j	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    uint8_t zero_i, zero_j;$/;"	m	class:N_puzzle	access:private
Name	abstract-machine/libs/imgui/include/imgui.h	/^    char            Name[32];                               \/\/ Name (strictly for debugging)$/;"	m	struct:ImFontConfig	access:public
Name	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*                   Name;$/;"	m	struct:ImGuiWindow	access:public
Name	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*       Name;$/;"	m	struct:ImGuiIniData	access:public
Name	pstree/pstree.c	/^    char Name[105];$/;"	m	struct:PROC	file:	access:public
NewFrame	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NewFrame();                                 \/\/ start a new ImGui frame, you can submit any command from this point until NewFrame()\/Render().$/;"	p	namespace:ImGui	signature:()
NewFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui	signature:()
NewLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NewLine();                                                          \/\/ undo a SameLine()$/;"	p	namespace:ImGui	signature:()
NewLine	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NewLine()$/;"	f	class:ImGui	signature:()
NextColumn	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          NextColumn();                                                       \/\/ next column$/;"	p	namespace:ImGui	signature:()
NextColumn	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui	signature:()
NextWidth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	access:public
NextWidths	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	access:public
Next_Ptr_Glob	abstract-machine/apps/dhrystone/dry.c	/^                Next_Ptr_Glob;$/;"	v
Null	abstract-machine/apps/dhrystone/dry.c	384;"	d	file:
OAMADDR	abstract-machine/apps/litenes/include/ppu.h	/^    byte OAMADDR;   \/\/ $2003 write only$/;"	m	struct:__anon2	access:public
OAMDATA	abstract-machine/apps/litenes/include/ppu.h	/^    byte OAMDATA;   \/\/ $2004$/;"	m	struct:__anon2	access:public
OFF	abstract-machine/am/include/x86.h	108;"	d
OFFSET_BASE	abstract-machine/apps/microbench/src/lzip/quicklz.c	24;"	d	file:
OFFSET_BASE	abstract-machine/apps/microbench/src/lzip/quicklz.c	27;"	d	file:
OP_DEC_DP	abstract-machine/apps/microbench/src/bf/bf.c	34;"	d	file:
OP_DEC_VAL	abstract-machine/apps/microbench/src/bf/bf.c	36;"	d	file:
OP_END	abstract-machine/apps/microbench/src/bf/bf.c	32;"	d	file:
OP_IN	abstract-machine/apps/microbench/src/bf/bf.c	38;"	d	file:
OP_INC_DP	abstract-machine/apps/microbench/src/bf/bf.c	33;"	d	file:
OP_INC_VAL	abstract-machine/apps/microbench/src/bf/bf.c	35;"	d	file:
OP_JMP_BCK	abstract-machine/apps/microbench/src/bf/bf.c	40;"	d	file:
OP_JMP_FWD	abstract-machine/apps/microbench/src/bf/bf.c	39;"	d	file:
OP_OUT	abstract-machine/apps/microbench/src/bf/bf.c	37;"	d	file:
OSXBehaviors	abstract-machine/libs/imgui/include/imgui.h	/^    bool          OSXBehaviors;             \/\/ = defined(__APPLE__) \/\/ OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd\/Super instead of Ctrl, Line\/Text Start and End using Cmd+Arrows instead of Home\/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd\/Super instead of Ctrl$/;"	m	struct:ImGuiIO	access:public
Offset	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImU32           Offset;$/;"	m	struct:ImGuiStyleVarInfo	file:	access:public
OffsetNorm	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       OffsetNorm;     \/\/ Column start offset, normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiColumnData	access:public
OnKeyPressed	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                OnKeyPressed(int key);$/;"	p	struct:ImGuiTextEditState	access:public	signature:(int key)
OnKeyPressed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextEditState::OnKeyPressed(int key)$/;"	f	class:ImGuiTextEditState	signature:(int key)
One_Fifty	abstract-machine/apps/dhrystone/dry.c	/^typedef int     One_Fifty;$/;"	t	file:
One_Thirty	abstract-machine/apps/dhrystone/dry.c	/^typedef int     One_Thirty;$/;"	t	file:
OpenPopup	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          OpenPopup(const char* str_id);                                      \/\/ mark popup as open. popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()\/EndPopup() block. popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).$/;"	p	namespace:ImGui	signature:(const char* str_id)
OpenPopup	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
OpenPopupEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          OpenPopupEx(const char* str_id, bool reopen_existing);$/;"	p	namespace:ImGui	signature:(const char* str_id, bool reopen_existing)
OpenPopupEx	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::OpenPopupEx(const char* str_id, bool reopen_existing)$/;"	f	class:ImGui	signature:(const char* str_id, bool reopen_existing)
OpenPopupStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiPopupRef> OpenPopupStack;                     \/\/ Which popups are open (persistent)$/;"	m	struct:ImGuiContext	access:public
OsImePosRequest	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext	access:public
OsImePosSet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  OsImePosRequest, OsImePosSet;       \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext	access:public
Overlaps	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool        Overlaps(const ImRect& r) const { return r.Min.y < Max.y  && r.Max.y > Min.y  && r.Min.x < Max.x && r.Max.x > Min.x; }$/;"	f	struct:ImRect	access:public	signature:(const ImRect& r) const
OverlayDrawList	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawList              OverlayDrawList;                    \/\/ Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays$/;"	m	struct:ImGuiContext	access:public
OversampleH	abstract-machine/libs/imgui/include/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
OversampleV	abstract-machine/libs/imgui/include/imgui.h	/^    int             OversampleH, OversampleV;   \/\/ 3, 1     \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig	access:public
P	abstract-machine/apps/litenes/include/cpu.h	/^    byte P; \/\/ Flag Register$/;"	m	struct:__anon5	access:public
PASS2	abstract-machine/apps/dhrystone/dry.c	360;"	d	file:
PC	abstract-machine/apps/litenes/include/cpu.h	/^    word PC; \/\/ Program Counter,$/;"	m	struct:__anon5	access:public
PCINT	abstract-machine/am/src/x86/qemu/devices/apic.c	31;"	d	file:
PDE	abstract-machine/am/include/x86.h	/^typedef uint32_t PDE;$/;"	t
PDX	abstract-machine/am/include/x86.h	106;"	d
PDXSHFT	abstract-machine/am/include/x86.h	33;"	d
PERFORMANCE_RUN	abstract-machine/apps/coremark/include/core_portme.h	179;"	d
PERIODIC	abstract-machine/am/src/x86/qemu/devices/apic.c	30;"	d	file:
PGADDR	abstract-machine/am/include/x86.h	112;"	d
PGMASK	abstract-machine/am/include/x86.h	28;"	d
PGSHFT	abstract-machine/am/include/x86.h	31;"	d
PGSHIFT	abstract-machine/am/src/native/vme.c	6;"	d	file:
PGSIZE	abstract-machine/am/include/x86.h	27;"	d
PGSIZE	abstract-machine/am/src/native/vme.c	5;"	d	file:
PI_DIV_4	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t PI_DIV_4 = 0x0000C90F;             \/*!< Fix16 value of PI\/4 *\/$/;"	v
PMEM_MAP_END	abstract-machine/am/src/native/platform.cpp	10;"	d	file:
PMEM_MAP_SIZE	abstract-machine/am/src/native/platform.cpp	11;"	d	file:
PMEM_MAP_START	abstract-machine/am/src/native/platform.cpp	9;"	d	file:
PMEM_SHM_FILE	abstract-machine/am/src/native/platform.cpp	7;"	d	file:
PMEM_SIZE	abstract-machine/am/src/native/platform.cpp	8;"	d	file:
PPUADDR	abstract-machine/apps/litenes/include/ppu.h	/^    word PPUADDR;   \/\/ $2006 write only x2$/;"	m	struct:__anon2	access:public
PPUCTRL	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUCTRL;   \/\/ $2000 write only$/;"	m	struct:__anon2	access:public
PPUDATA	abstract-machine/apps/litenes/include/ppu.h	/^    word PPUDATA;   \/\/ $2007$/;"	m	struct:__anon2	access:public
PPUMASK	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUMASK;   \/\/ $2001 write only$/;"	m	struct:__anon2	access:public
PPUSCROLL	abstract-machine/apps/litenes/include/ppu.h	/^	word PPUSCROLL;$/;"	m	struct:__anon2	access:public
PPUSCROLL_X	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSCROLL_X, PPUSCROLL_Y; \/\/ $2005 write only x2$/;"	m	struct:__anon2	access:public
PPUSCROLL_Y	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSCROLL_X, PPUSCROLL_Y; \/\/ $2005 write only x2$/;"	m	struct:__anon2	access:public
PPUSTATUS	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSTATUS; \/\/ $2002 read only$/;"	m	struct:__anon2	access:public
PPU_H	abstract-machine/apps/litenes/include/ppu.h	4;"	d
PPU_RAM	abstract-machine/apps/litenes/include/ppu.h	/^extern byte PPU_RAM[0x4000];$/;"	x
PPU_RAM	abstract-machine/apps/litenes/src/ppu.c	/^byte PPU_RAM[0x4000];$/;"	v
PPU_SPRRAM	abstract-machine/apps/litenes/include/ppu.h	/^extern byte PPU_SPRRAM[0x100];$/;"	x
PPU_SPRRAM	abstract-machine/apps/litenes/src/ppu.c	/^byte PPU_SPRRAM[0x100];$/;"	v
PPU_STATE	abstract-machine/apps/litenes/include/ppu.h	/^} PPU_STATE;$/;"	t	typeref:struct:__anon2
PPid	pstree/pstree.c	/^    int PPid;$/;"	m	struct:PROC	file:	access:public
PROC	pstree/pstree.c	/^struct PROC{$/;"	s	file:
PROC::Name	pstree/pstree.c	/^    char Name[105];$/;"	m	struct:PROC	file:	access:public
PROC::PPid	pstree/pstree.c	/^    int PPid;$/;"	m	struct:PROC	file:	access:public
PROC::num_of_son	pstree/pstree.c	/^    int num_of_son;$/;"	m	struct:PROC	file:	access:public
PROC::son	pstree/pstree.c	/^    int son[100];$/;"	m	struct:PROC	file:	access:public
PROFILE_RUN	abstract-machine/apps/coremark/include/core_portme.h	177;"	d
PROGRAM	abstract-machine/apps/microbench/src/bf/bf.c	/^static struct instruction_t *PROGRAM;$/;"	v	typeref:struct:instruction_t	file:
PROGRAM_SIZE	abstract-machine/apps/microbench/src/bf/bf.c	45;"	d	file:
PSG_H	abstract-machine/apps/litenes/include/psg.h	7;"	d
PTE	abstract-machine/am/include/x86.h	/^typedef uint32_t PTE;$/;"	t
PTE_A	abstract-machine/am/include/x86.h	41;"	d
PTE_ADDR	abstract-machine/am/include/x86.h	111;"	d
PTE_D	abstract-machine/am/include/x86.h	42;"	d
PTE_P	abstract-machine/am/include/x86.h	36;"	d
PTE_PCD	abstract-machine/am/include/x86.h	40;"	d
PTE_PWT	abstract-machine/am/include/x86.h	39;"	d
PTE_U	abstract-machine/am/include/x86.h	38;"	d
PTE_W	abstract-machine/am/include/x86.h	37;"	d
PTX	abstract-machine/am/include/x86.h	107;"	d
PTXSHFT	abstract-machine/am/include/x86.h	32;"	d
PUZZLE_LG	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^static int PUZZLE_LG[N*N] = {$/;"	v	file:
PUZZLE_SM	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^static int PUZZLE_SM[N*N] = {$/;"	v	file:
PZ15_LG	abstract-machine/apps/microbench/include/benchmark.h	44;"	d
PZ15_SM	abstract-machine/apps/microbench/include/benchmark.h	43;"	d
PageMap	abstract-machine/am/src/native/vme.c	/^typedef struct PageMap {$/;"	s	file:
PageMap	abstract-machine/am/src/native/vme.c	/^} PageMap;$/;"	t	typeref:struct:PageMap	file:
PageMap::is_mapped	abstract-machine/am/src/native/vme.c	/^  int is_mapped;$/;"	m	struct:PageMap	file:	access:public
PageMap::next	abstract-machine/am/src/native/vme.c	/^  struct PageMap *next;$/;"	m	struct:PageMap	typeref:struct:PageMap::PageMap	file:	access:public
PageMap::ppn	abstract-machine/am/src/native/vme.c	/^  uintptr_t ppn;$/;"	m	struct:PageMap	file:	access:public
PageMap::vpn	abstract-machine/am/src/native/vme.c	/^  uintptr_t vpn;$/;"	m	struct:PageMap	file:	access:public
Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, float _val_f)
Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, int _val_i)
Pair	abstract-machine/libs/imgui/include/imgui.h	/^        Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }$/;"	f	struct:ImGuiStorage::Pair	access:public	signature:(ImGuiID _key, void* _val_p)
Pair	abstract-machine/libs/imgui/include/imgui.h	/^    struct Pair$/;"	s	struct:ImGuiStorage	access:public
ParentMenuSet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID         ParentMenuSet;  \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            ParentWindow;                       \/\/ If we are a child window, this is pointing to our parent window. Else point to NULL.$/;"	m	struct:ImGuiWindow	access:public
ParentWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*    ParentWindow;   \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
ParseFormatPrecision	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API int           ParseFormatPrecision(const char* fmt, int default_value);$/;"	p	namespace:ImGui	signature:(const char* fmt, int default_value)
ParseFormatPrecision	abstract-machine/libs/imgui/src/imgui.cpp	/^int ImGui::ParseFormatPrecision(const char* fmt, int default_precision)$/;"	f	class:ImGui	signature:(const char* fmt, int default_precision)
PassFilter	abstract-machine/libs/imgui/include/imgui.h	/^    bool                PassFilter(const char* text, const char* text_end = NULL) const;$/;"	p	struct:ImGuiTextFilter	access:public	signature:(const char* text, const char* text_end = NULL) const
PassFilter	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const$/;"	f	class:ImGuiTextFilter	signature:(const char* text, const char* text_end) const
PathArcTo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10)
PathArcTo	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float amin, float amax, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, float amin, float amax, int num_segments)
PathArcToFast	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                \/\/ Use precomputed angles for a 12 steps circle$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
PathArcToFast	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int amin, int amax)$/;"	f	class:ImDrawList	signature:(const ImVec2& centre, float radius, int amin, int amax)
PathBezierCurveTo	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0)
PathBezierCurveTo	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)$/;"	f	class:ImDrawList	signature:(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
PathBezierToCasteljau	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)$/;"	f	file:	signature:(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
PathClear	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathClear()                                                 { _Path.resize(0); }$/;"	f	struct:ImDrawList	access:public	signature:()
PathFillConvex	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col)
PathLineTo	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos)
PathLineToMergeDuplicate	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos)
PathRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ~0);   \/\/ rounding_corners_flags: 4-bits corresponding to which corner to round$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ~0)
PathRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
PathStroke	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness, true); PathClear(); }$/;"	f	struct:ImDrawList	access:public	signature:(ImU32 col, bool closed, float thickness = 1.0f)
PixelSnapH	abstract-machine/libs/imgui/include/imgui.h	/^    bool            PixelSnapH;                 \/\/ false    \/\/ Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH\/V to 1.$/;"	m	struct:ImFontConfig	access:public
PlotEx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);$/;"	p	namespace:ImGui	signature:(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotEx	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotHistogram	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
PlotHistogram	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
PlotHistogram	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
PlotHistogram	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
PlotLines	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float));$/;"	p	namespace:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0), int stride = sizeof(float))
PlotLines	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0,0))
PlotLines	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui	signature:(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
PlotLines	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui	signature:(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
Plot_ArrayGetter	abstract-machine/libs/imgui/src/imgui.cpp	/^static float Plot_ArrayGetter(void* data, int idx)$/;"	f	file:	signature:(void* data, int idx)
PopAllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopAllowKeyboardFocus();$/;"	p	namespace:ImGui	signature:()
PopAllowKeyboardFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui	signature:()
PopButtonRepeat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopButtonRepeat();$/;"	p	namespace:ImGui	signature:()
PopButtonRepeat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui	signature:()
PopClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopClipRect();$/;"	p	namespace:ImGui	signature:()
PopClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PopClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
PopClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopClipRect()$/;"	f	class:ImGui	signature:()
PopClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList	signature:()
PopFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopFont();$/;"	p	namespace:ImGui	signature:()
PopFont	abstract-machine/libs/imgui/src/imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui	signature:()
PopID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopID();$/;"	p	namespace:ImGui	signature:()
PopID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui	signature:()
PopItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopItemWidth();$/;"	p	namespace:ImGui	signature:()
PopItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui	signature:()
PopStyleColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopStyleColor(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
PopStyleColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui	signature:(int count)
PopStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopStyleVar(int count = 1);$/;"	p	namespace:ImGui	signature:(int count = 1)
PopStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui	signature:(int count)
PopTextWrapPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PopTextWrapPos();$/;"	p	namespace:ImGui	signature:()
PopTextWrapPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui	signature:()
PopTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PopTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
PopTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList	signature:()
PopupId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 PopupId;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling)$/;"	m	struct:ImGuiWindow	access:public
PopupId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID         PopupId;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
Pos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  Pos;            \/\/ Read-only.	Window position, for reference.$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Pos;                                \/\/ Position rounded-up to nearest pixel$/;"	m	struct:ImGuiWindow	access:public
Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Pos;$/;"	m	struct:ImGuiIniData	access:public
Pos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Pos[8], NextWidths[8];$/;"	m	struct:ImGuiSimpleColumns	access:public
PosFloat	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  PosFloat;$/;"	m	struct:ImGuiWindow	access:public
PrevLineHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   PrevLineHeight;$/;"	m	struct:ImGuiDrawContext	access:public
PrevLineTextBaseOffset	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiDrawContext	access:public
PrimQuadUV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
PrimQuadUV	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
PrimRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      \/\/ Axis aligned rectangle (composed of two triangles)$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, ImU32 col)
PrimRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, ImU32 col)
PrimRectUV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);$/;"	p	struct:ImDrawList	access:public	signature:(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
PrimRectUV	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList	signature:(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
PrimReserve	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PrimReserve(int idx_count, int vtx_count);$/;"	p	struct:ImDrawList	access:public	signature:(int idx_count, int vtx_count)
PrimReserve	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList	signature:(int idx_count, int vtx_count)
PrimVtx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
PrimWriteIdx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList	access:public	signature:(ImDrawIdx idx)
PrimWriteVtx	abstract-machine/libs/imgui/include/imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList	access:public	signature:(const ImVec2& pos, const ImVec2& uv, ImU32 col)
PrivateClipboard	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char*                   PrivateClipboard;                   \/\/ If no custom clipboard handler is defined$/;"	m	struct:ImGuiContext	access:public
Proc_1	abstract-machine/apps/dhrystone/dry.c	/^void Proc_1 (Ptr_Val_Par)$/;"	f
Proc_2	abstract-machine/apps/dhrystone/dry.c	/^void Proc_2 (Int_Par_Ref)$/;"	f
Proc_3	abstract-machine/apps/dhrystone/dry.c	/^void Proc_3 (Ptr_Ref_Par)$/;"	f
Proc_3	abstract-machine/apps/dhrystone/dry.c	/^void Proc_3 (Rec_Pointer*);$/;"	p	file:	signature:(Rec_Pointer*)
Proc_4	abstract-machine/apps/dhrystone/dry.c	/^void Proc_4 () \/* without parameters *\/$/;"	f
Proc_5	abstract-machine/apps/dhrystone/dry.c	/^void Proc_5 () \/* without parameters *\/$/;"	f
Proc_6	abstract-machine/apps/dhrystone/dry.c	/^void Proc_6 (Enum_Val_Par, Enum_Ref_Par)$/;"	f
Proc_6	abstract-machine/apps/dhrystone/dry.c	/^void Proc_6 (Enumeration, Enumeration*);$/;"	p	file:	signature:(Enumeration, Enumeration*)
Proc_7	abstract-machine/apps/dhrystone/dry.c	/^void Proc_7 (One_Fifty Int_1_Par_Val, One_Fifty Int_2_Par_Val, One_Fifty *Int_Par_Ref)$/;"	f	signature:(One_Fifty Int_1_Par_Val, One_Fifty Int_2_Par_Val, One_Fifty *Int_Par_Ref)
Proc_7	abstract-machine/apps/dhrystone/dry.c	/^void Proc_7 (One_Fifty a, One_Fifty b, One_Fifty* c);$/;"	p	file:	signature:(One_Fifty a, One_Fifty b, One_Fifty* c)
Proc_8	abstract-machine/apps/dhrystone/dry.c	/^void Proc_8 (Arr_1_Par_Ref, Arr_2_Par_Ref, Int_1_Par_Val, Int_2_Par_Val)$/;"	f
Proc_8	abstract-machine/apps/dhrystone/dry.c	/^void Proc_8(Arr_1_Dim, Arr_2_Dim, int, int);$/;"	p	file:	signature:(Arr_1_Dim, Arr_2_Dim, int, int)
ProgramHeader	abstract-machine/am/src/x86/qemu/boot/main.c	/^struct ProgramHeader {$/;"	s	file:
ProgramHeader::align	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t align;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::filesz	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t filesz;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::flags	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t flags;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::memsz	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t memsz;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::off	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t off;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::paddr	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t paddr;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::type	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t type;$/;"	m	struct:ProgramHeader	file:	access:public
ProgramHeader::vaddr	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t vaddr;$/;"	m	struct:ProgramHeader	file:	access:public
ProgressBar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL);$/;"	p	namespace:ImGui	signature:(float fraction, const ImVec2& size_arg = ImVec2(-1,0), const char* overlay = NULL)
ProgressBar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)$/;"	f	class:ImGui	signature:(float fraction, const ImVec2& size_arg, const char* overlay)
Ptr_Comp	abstract-machine/apps/dhrystone/dry.c	/^    struct record *Ptr_Comp;$/;"	m	struct:record	typeref:struct:record::record	file:	access:public
Ptr_Glob	abstract-machine/apps/dhrystone/dry.c	/^Rec_Pointer     Ptr_Glob,$/;"	v
PushAllowKeyboardFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushAllowKeyboardFocus(bool v);                                     \/\/ allow focusing using TAB\/Shift-TAB, enabled by default but you can disable it for certain widgets$/;"	p	namespace:ImGui	signature:(bool v)
PushAllowKeyboardFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui	signature:(bool allow_keyboard_focus)
PushButtonRepeat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushButtonRepeat(bool repeat);                                      \/\/ in 'repeat' mode, Button*() functions return repeated true in a typematic manner (uses io.KeyRepeatDelay\/io.KeyRepeatRate for now). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.$/;"	p	namespace:ImGui	signature:(bool repeat)
PushButtonRepeat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui	signature:(bool repeat)
PushClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);$/;"	p	namespace:ImGui	signature:(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
PushClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  \/\/ Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)$/;"	p	struct:ImDrawList	access:public	signature:(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false)
PushClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImGui	signature:(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
PushClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImDrawList	signature:(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
PushClipRectFullScreen	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushClipRectFullScreen();$/;"	p	struct:ImDrawList	access:public	signature:()
PushClipRectFullScreen	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList	signature:()
PushColumnClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             PushColumnClipRect(int column_index = -1);$/;"	p	file:	signature:(int column_index = -1)
PushColumnClipRect	abstract-machine/libs/imgui/src/imgui.cpp	/^static void PushColumnClipRect(int column_index)$/;"	f	file:	signature:(int column_index)
PushFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushFont(ImFont* font);                                             \/\/ use NULL as a shortcut to push default font$/;"	p	namespace:ImGui	signature:(ImFont* font)
PushFont	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui	signature:(ImFont* font)
PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const char* str_id);                                         \/\/ push identifier into the ID stack. IDs are hash of the *entire* stack!$/;"	p	namespace:ImGui	signature:(const char* str_id)
PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);$/;"	p	namespace:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(const void* ptr_id);$/;"	p	namespace:ImGui	signature:(const void* ptr_id)
PushID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushID(int int_id);$/;"	p	namespace:ImGui	signature:(int int_id)
PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui	signature:(const char* str_id_begin, const char* str_id_end)
PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
PushID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui	signature:(int int_id)
PushItemWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushItemWidth(float item_width);                                    \/\/ width of items for the common item+label case, pixels. 0.0f = default to ~2\/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)$/;"	p	namespace:ImGui	signature:(float item_width)
PushItemWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui	signature:(float item_width)
PushMultiItemsWidths	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             PushMultiItemsWidths(int components, float w_full = 0.0f);$/;"	p	file:	signature:(int components, float w_full = 0.0f)
PushMultiItemsWidths	abstract-machine/libs/imgui/src/imgui.cpp	/^static void PushMultiItemsWidths(int components, float w_full)$/;"	f	file:	signature:(int components, float w_full)
PushStyleColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);$/;"	p	namespace:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
PushStyleColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui	signature:(ImGuiCol idx, const ImVec4& col)
PushStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
PushStyleVar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);$/;"	p	namespace:ImGui	signature:(ImGuiStyleVar idx, float val)
PushStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, const ImVec2& val)
PushStyleVar	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui	signature:(ImGuiStyleVar idx, float val)
PushTextWrapPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                           \/\/ word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space$/;"	p	namespace:ImGui	signature:(float wrap_pos_x = 0.0f)
PushTextWrapPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui	signature:(float wrap_pos_x)
PushTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  PushTextureID(const ImTextureID& texture_id);$/;"	p	struct:ImDrawList	access:public	signature:(const ImTextureID& texture_id)
PushTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::PushTextureID(const ImTextureID& texture_id)$/;"	f	class:ImDrawList	signature:(const ImTextureID& texture_id)
QLZ_COMPRESSION_LEVEL	abstract-machine/apps/microbench/src/lzip/quicklz.h	50;"	d
QLZ_COMPRESSION_LEVEL	abstract-machine/apps/microbench/src/lzip/quicklz.h	52;"	d
QLZ_HASH_VALUES	abstract-machine/apps/microbench/src/lzip/quicklz.h	81;"	d
QLZ_HASH_VALUES	abstract-machine/apps/microbench/src/lzip/quicklz.h	84;"	d
QLZ_HASH_VALUES	abstract-machine/apps/microbench/src/lzip/quicklz.h	87;"	d
QLZ_HEADER	abstract-machine/apps/microbench/src/lzip/quicklz.h	2;"	d
QLZ_POINTERS	abstract-machine/apps/microbench/src/lzip/quicklz.h	80;"	d
QLZ_POINTERS	abstract-machine/apps/microbench/src/lzip/quicklz.h	83;"	d
QLZ_POINTERS	abstract-machine/apps/microbench/src/lzip/quicklz.h	86;"	d
QLZ_STREAMING_BUFFER	abstract-machine/apps/microbench/src/lzip/quicklz.h	57;"	d
QLZ_VERSION_MAJOR	abstract-machine/apps/microbench/src/lzip/quicklz.h	66;"	d
QLZ_VERSION_MINOR	abstract-machine/apps/microbench/src/lzip/quicklz.h	67;"	d
QLZ_VERSION_REVISION	abstract-machine/apps/microbench/src/lzip/quicklz.h	68;"	d
QSORT_LG	abstract-machine/apps/microbench/include/benchmark.h	34;"	d
QSORT_SM	abstract-machine/apps/microbench/include/benchmark.h	33;"	d
QUEEN_LG	abstract-machine/apps/microbench/include/benchmark.h	36;"	d
QUEEN_SM	abstract-machine/apps/microbench/include/benchmark.h	35;"	d
R	abstract-machine/am/src/native/devices/video.c	/^static inline uint8_t R(uint32_t p) { return p >> 16; }$/;"	f	file:	signature:(uint32_t p)
R	abstract-machine/am/src/x86/qemu/devices/video.c	/^static uint8_t R(uint32_t p) { return p >> 16; }$/;"	f	file:	signature:(uint32_t p)
R	abstract-machine/apps/litenes/include/common.h	/^static inline uint8_t R(uint32_t p) { return p >> 16; }$/;"	f	signature:(uint32_t p)
RANGE	abstract-machine/am/src/x86/x86-qemu.h	67;"	d
REF_CPU	abstract-machine/apps/microbench/include/benchmark.h	17;"	d
REF_SCORE	abstract-machine/apps/microbench/include/benchmark.h	18;"	d
REG	abstract-machine/apps/dhrystone/dry.c	434;"	d	file:
REG	abstract-machine/apps/dhrystone/dry.c	439;"	d	file:
REG	abstract-machine/apps/dhrystone/dry.c	440;"	d	file:
REG	abstract-machine/apps/dhrystone/dry.c	577;"	d	file:
REG	abstract-machine/apps/dhrystone/dry.c	581;"	d	file:
REG	abstract-machine/apps/dhrystone/dry.c	582;"	d	file:
REGS_KERNEL	abstract-machine/am/src/x86/qemu/cte.c	158;"	d	file:
REGS_USER	abstract-machine/am/src/x86/qemu/cte.c	161;"	d	file:
REG_ID	abstract-machine/am/src/x86/qemu/devices/apic.c	165;"	d	file:
REG_TABLE	abstract-machine/am/src/x86/qemu/devices/apic.c	167;"	d	file:
REG_VER	abstract-machine/am/src/x86/qemu/devices/apic.c	166;"	d	file:
REPEAT	abstract-machine/apps/microbench/include/benchmark.h	30;"	d
RESULTS_S	abstract-machine/apps/coremark/include/coremark.h	/^typedef struct RESULTS_S {$/;"	s
RESULTS_S::crc	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crc;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::crclist	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crclist;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::crcmatrix	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crcmatrix;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::crcstate	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crcstate;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::err	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	err;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::execs	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32	execs;		\/* Bitmask of operations to execute *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::iterations	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32 iterations;		\/* Number of iterations to execute *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::list	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_head_s *list;$/;"	m	struct:RESULTS_S	typeref:struct:RESULTS_S::list_head_s	access:public
RESULTS_S::mat	abstract-machine/apps/coremark/include/coremark.h	/^	mat_params mat;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::memblock	abstract-machine/apps/coremark/include/coremark.h	/^	void	*memblock[4];	\/* Pointer to safe memory location *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::port	abstract-machine/apps/coremark/include/coremark.h	/^	core_portable port;$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::seed1	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed1;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::seed2	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed2;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::seed3	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed3;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
RESULTS_S::size	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32	size;		\/* Size of the data *\/$/;"	m	struct:RESULTS_S	access:public
ROUNDDOWN	abstract-machine/am/include/x86.h	110;"	d
ROUNDUP	abstract-machine/am/include/x86.h	109;"	d
ROUNDUP	abstract-machine/apps/microbench/src/bench.c	11;"	d	file:
RadioButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, bool active);$/;"	p	namespace:ImGui	signature:(const char* label, bool active)
RadioButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_button)
RadioButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui	signature:(const char* label, bool active)
RadioButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_button)
ReadOnly	abstract-machine/libs/imgui/include/imgui.h	/^    bool                ReadOnly;       \/\/ Read-only mode                       \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Rec_Pointer	abstract-machine/apps/dhrystone/dry.c	/^      } Rec_Type, *Rec_Pointer;$/;"	t	typeref:struct:record	file:
Rec_Type	abstract-machine/apps/dhrystone/dry.c	/^      } Rec_Type, *Rec_Pointer;$/;"	t	typeref:struct:record	file:
Rect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      Rect() const                            { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
Reduce	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Reduce(const ImVec2& amount)    { Min.x += amount.x; Min.y += amount.y; Max.x -= amount.x; Max.y -= amount.y; }$/;"	f	struct:ImRect	access:public	signature:(const ImVec2& amount)
RefFrame	abstract-machine/libs/imgui/include/imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame	access:public
Reg	abstract-machine/apps/dhrystone/dry.c	/^        Boolean Reg = false;$/;"	v
Reg	abstract-machine/apps/dhrystone/dry.c	/^        Boolean Reg = true;$/;"	v
Render	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Render();                                   \/\/ ends the ImGui frame, finalize rendering data, then call your io.RenderDrawListsFn() function if set.$/;"	p	namespace:ImGui	signature:()
Render	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui	signature:()
RenderBullet	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderBullet(ImVec2 pos);$/;"	p	namespace:ImGui	signature:(ImVec2 pos)
RenderBullet	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderBullet(ImVec2 pos)$/;"	f	class:ImGui	signature:(ImVec2 pos)
RenderChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;$/;"	p	struct:ImFont	access:public	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const
RenderChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const$/;"	f	class:ImFont	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const
RenderCheckMark	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, ImU32 col)
RenderCheckMark	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col)$/;"	f	class:ImGui	signature:(ImVec2 pos, ImU32 col)
RenderCollapseTriangle	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderCollapseTriangle(ImVec2 pos, bool is_open, float scale = 1.0f);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, bool is_open, float scale = 1.0f)
RenderCollapseTriangle	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderCollapseTriangle(ImVec2 p_min, bool is_open, float scale)$/;"	f	class:ImGui	signature:(ImVec2 p_min, bool is_open, float scale)
RenderCustomTexData	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderCustomTexData(int pass, void* rects);$/;"	p	struct:ImFontAtlas	access:public	signature:(int pass, void* rects)
RenderCustomTexData	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFontAtlas::RenderCustomTexData(int pass, void* p_rects)$/;"	f	class:ImFontAtlas	signature:(int pass, void* p_rects)
RenderDrawData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImDrawData              RenderDrawData;                     \/\/ Main ImDrawData instance to pass render information to the user$/;"	m	struct:ImGuiContext	access:public
RenderDrawLists	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImDrawList*>   RenderDrawLists[3];$/;"	m	struct:ImGuiContext	access:public
RenderDrawListsFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);$/;"	m	struct:ImGuiIO	access:public
RenderFrame	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);$/;"	p	namespace:ImGui	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f)
RenderFrame	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	class:ImGui	signature:(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
RenderText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;$/;"	p	struct:ImFont	access:public	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const
RenderText	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true)
RenderText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	class:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
RenderText	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont	signature:(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
RenderTextClipped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL);$/;"	p	namespace:ImGui	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0,0), const ImRect* clip_rect = NULL)
RenderTextClipped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui	signature:(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
RenderTextWrapped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);$/;"	p	namespace:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
RenderTextWrapped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	class:ImGui	signature:(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
ResetMouseDragDelta	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ResetMouseDragDelta(int button = 0);                                \/\/$/;"	p	namespace:ImGui	signature:(int button = 0)
ResetMouseDragDelta	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui	signature:(int button)
Result	abstract-machine/apps/microbench/include/benchmark.h	/^typedef struct Result {$/;"	s
Result	abstract-machine/apps/microbench/include/benchmark.h	/^} Result;$/;"	t	typeref:struct:Result
Result::msec	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long tsc, msec;$/;"	m	struct:Result	access:public
Result::pass	abstract-machine/apps/microbench/include/benchmark.h	/^  int pass;$/;"	m	struct:Result	access:public
Result::tsc	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long tsc, msec;$/;"	m	struct:Result	access:public
RootNonPopupWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            RootNonPopupWindow;                 \/\/ If we are a child window, this is pointing to the first non-child non-popup parent window. Else point to ourself.$/;"	m	struct:ImGuiWindow	access:public
RootWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*            RootWindow;                         \/\/ If we are a child window, this is pointing to the first non-child parent window. Else point to ourself.$/;"	m	struct:ImGuiWindow	access:public
RoundScalar	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API float         RoundScalar(float value, int decimal_precision);$/;"	p	namespace:ImGui	signature:(float value, int decimal_precision)
RoundScalar	abstract-machine/libs/imgui/src/imgui.cpp	/^float ImGui::RoundScalar(float value, int decimal_precision)$/;"	f	class:ImGui	signature:(float value, int decimal_precision)
SAMPLE_TIME_IMPLEMENTATION	abstract-machine/apps/coremark/src/core_portme.c	36;"	d	file:
SECTSIZE	abstract-machine/am/src/x86/qemu/boot/main.c	52;"	d	file:
SEED_ARG	abstract-machine/apps/coremark/include/coremark.h	30;"	d
SEED_FUNC	abstract-machine/apps/coremark/include/coremark.h	31;"	d
SEED_METHOD	abstract-machine/apps/coremark/include/core_portme.h	100;"	d
SEED_VOLATILE	abstract-machine/apps/coremark/include/coremark.h	32;"	d
SEG	abstract-machine/am/include/x86.h	131;"	d
SEG16	abstract-machine/am/include/x86.h	136;"	d
SEG_ASM	abstract-machine/am/src/x86/qemu/boot/start.S	/^#define SEG_ASM(type, base, lim)                          \\$/;"	d
SEG_KCODE	abstract-machine/am/include/x86.h	46;"	d
SEG_KDATA	abstract-machine/am/include/x86.h	47;"	d
SEG_NULLASM	abstract-machine/am/src/x86/qemu/boot/start.S	/^#define SEG_NULLASM   \\$/;"	d
SEG_TSS	abstract-machine/am/include/x86.h	50;"	d
SEG_UCODE	abstract-machine/am/include/x86.h	48;"	d
SEG_UDATA	abstract-machine/am/include/x86.h	49;"	d
SETTING	abstract-machine/apps/microbench/include/benchmark.h	21;"	d
SETTING	abstract-machine/apps/microbench/include/benchmark.h	24;"	d
SHOULD_TRACE	abstract-machine/am/src/x86/qemu/trace.c	61;"	d	file:
SIDE	amgame/include/game.h	4;"	d
SIEVE_LG	abstract-machine/apps/microbench/include/benchmark.h	42;"	d
SIEVE_SM	abstract-machine/apps/microbench/include/benchmark.h	41;"	d
SIZE	abstract-machine/apps/microbench/src/lzip/lzip.c	/^static int SIZE;$/;"	v	file:
SP	abstract-machine/apps/litenes/include/cpu.h	/^    byte SP; \/\/ Stack Pointer,$/;"	m	struct:__anon5	access:public
SP	abstract-machine/apps/microbench/src/bf/bf.c	/^static unsigned int SP;$/;"	v	file:
SRCS	Makefile	/^SRCS   := $(shell find . -maxdepth 1 -name "*.c")$/;"	m
SRCS	abstract-machine/am/Makefile	/^SRCS := $(addprefix src\/, $(AM_SRCS))$/;"	m
SRCS	abstract-machine/apps/coremark/Makefile	/^SRCS = $(shell find -L .\/src\/ -name "*.c")$/;"	m
SRCS	abstract-machine/apps/dhrystone/Makefile	/^SRCS = dry.c$/;"	m
SRCS	abstract-machine/apps/hello/Makefile	/^SRCS = hello.c$/;"	m
SRCS	abstract-machine/apps/litenes/Makefile	/^SRCS = $(shell find -L .\/src\/ -name "*.c" -o -name "*.cpp" -o -name "*.S")$/;"	m
SRCS	abstract-machine/apps/microbench/Makefile	/^SRCS = $(shell find -L .\/src\/ -name "*.c" -o -name "*.cpp")$/;"	m
SRCS	abstract-machine/apps/slider/Makefile	/^SRCS = main.c image.S$/;"	m
SRCS	abstract-machine/apps/typing/Makefile	/^SRCS = game.c draw.c font.c keyboard.c$/;"	m
SRCS	abstract-machine/libs/compiler-rt/Makefile	/^SRCS = $(shell find . -name "*.c")$/;"	m
SRCS	abstract-machine/libs/fixmath/Makefile	/^SRCS = $(shell find -L .\/src\/ -name "*.c")$/;"	m
SRCS	abstract-machine/libs/imgui/Makefile	/^SRCS = src\/imgui.cpp src\/imgui_draw.cpp src\/imgui_demo.cpp$/;"	m
SRCS	abstract-machine/libs/klib/Makefile	/^SRCS = src\/stdio.c \\$/;"	m
SRCS	amgame/Makefile	/^SRCS := $(shell find -L .\/src\/ -name "*.c")$/;"	m
SSORT_LG	abstract-machine/apps/microbench/include/benchmark.h	50;"	d
SSORT_SM	abstract-machine/apps/microbench/include/benchmark.h	49;"	d
STACK	abstract-machine/apps/microbench/src/bf/bf.c	/^static unsigned short *STACK;$/;"	v	file:
STACK_EMPTY	abstract-machine/apps/microbench/src/bf/bf.c	51;"	d	file:
STACK_FULL	abstract-machine/apps/microbench/src/bf/bf.c	52;"	d	file:
STACK_POP	abstract-machine/apps/microbench/src/bf/bf.c	50;"	d	file:
STACK_PUSH	abstract-machine/apps/microbench/src/bf/bf.c	49;"	d	file:
STACK_SIZE	abstract-machine/apps/microbench/src/bf/bf.c	46;"	d	file:
STARTUP	abstract-machine/am/src/x86/qemu/devices/apic.c	19;"	d	file:
STA_R	abstract-machine/am/include/x86.h	11;"	d
STA_W	abstract-machine/am/include/x86.h	10;"	d
STA_X	abstract-machine/am/include/x86.h	9;"	d
STBRP_ASSERT	abstract-machine/libs/imgui/include/stb_rect_pack.h	198;"	d
STBRP_ASSERT	abstract-machine/libs/imgui/src/imgui_draw.cpp	71;"	d	file:
STBRP_DEF	abstract-machine/libs/imgui/include/stb_rect_pack.h	61;"	d
STBRP_DEF	abstract-machine/libs/imgui/include/stb_rect_pack.h	63;"	d
STBRP_HEURISTIC_Skyline_BF_sortHeight	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BF_sortHeight$/;"	e	enum:__anon37
STBRP_HEURISTIC_Skyline_BL_sortHeight	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,$/;"	e	enum:__anon37
STBRP_HEURISTIC_Skyline_default	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   STBRP_HEURISTIC_Skyline_default=0,$/;"	e	enum:__anon37
STBRP_SORT	abstract-machine/libs/imgui/include/stb_rect_pack.h	194;"	d
STBRP_STATIC	abstract-machine/libs/imgui/src/imgui_draw.cpp	73;"	d	file:
STBRP__INIT_skyline	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   STBRP__INIT_skyline = 1$/;"	e	enum:__anon38
STBRP__MAXVAL	abstract-machine/libs/imgui/include/stb_rect_pack.h	540;"	d
STBRP__MAXVAL	abstract-machine/libs/imgui/include/stb_rect_pack.h	542;"	d
STBRP__NOTUSED	abstract-machine/libs/imgui/include/stb_rect_pack.h	202;"	d
STBRP__NOTUSED	abstract-machine/libs/imgui/include/stb_rect_pack.h	204;"	d
STBTT_DEF	abstract-machine/libs/imgui/include/stb_truetype.h	443;"	d
STBTT_DEF	abstract-machine/libs/imgui/include/stb_truetype.h	445;"	d
STBTT_FIX	abstract-machine/libs/imgui/include/stb_truetype.h	2336;"	d
STBTT_FIXMASK	abstract-machine/libs/imgui/include/stb_truetype.h	2337;"	d
STBTT_FIXSHIFT	abstract-machine/libs/imgui/include/stb_truetype.h	2335;"	d
STBTT_MACSTYLE_BOLD	abstract-machine/libs/imgui/include/stb_truetype.h	870;"	d
STBTT_MACSTYLE_DONTCARE	abstract-machine/libs/imgui/include/stb_truetype.h	869;"	d
STBTT_MACSTYLE_ITALIC	abstract-machine/libs/imgui/include/stb_truetype.h	871;"	d
STBTT_MACSTYLE_NONE	abstract-machine/libs/imgui/include/stb_truetype.h	873;"	d
STBTT_MACSTYLE_UNDERSCORE	abstract-machine/libs/imgui/include/stb_truetype.h	872;"	d
STBTT_MAC_EID_ARABIC	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon52
STBTT_MAC_EID_CHINESE_TRAD	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon52
STBTT_MAC_EID_GREEK	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon52
STBTT_MAC_EID_HEBREW	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon52
STBTT_MAC_EID_JAPANESE	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon52
STBTT_MAC_EID_KOREAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon52
STBTT_MAC_EID_ROMAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon52
STBTT_MAC_EID_RUSSIAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon52
STBTT_MAC_LANG_ARABIC	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon54
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon54
STBTT_MAC_LANG_CHINESE_TRAD	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon54
STBTT_MAC_LANG_DUTCH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon54
STBTT_MAC_LANG_ENGLISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon54
STBTT_MAC_LANG_FRENCH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon54
STBTT_MAC_LANG_GERMAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon54
STBTT_MAC_LANG_HEBREW	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon54
STBTT_MAC_LANG_ITALIAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon54
STBTT_MAC_LANG_JAPANESE	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon54
STBTT_MAC_LANG_KOREAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon54
STBTT_MAC_LANG_RUSSIAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon54
STBTT_MAC_LANG_SPANISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon54
STBTT_MAC_LANG_SWEDISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon54
STBTT_MAX_OVERSAMPLE	abstract-machine/libs/imgui/include/stb_truetype.h	952;"	d
STBTT_MS_EID_SHIFTJIS	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon51
STBTT_MS_EID_SYMBOL	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon51
STBTT_MS_EID_UNICODE_BMP	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon51
STBTT_MS_EID_UNICODE_FULL	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon51
STBTT_MS_LANG_CHINESE	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon53
STBTT_MS_LANG_DUTCH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon53
STBTT_MS_LANG_ENGLISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon53
STBTT_MS_LANG_FRENCH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon53
STBTT_MS_LANG_GERMAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon53
STBTT_MS_LANG_HEBREW	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon53
STBTT_MS_LANG_ITALIAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon53
STBTT_MS_LANG_JAPANESE	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon53
STBTT_MS_LANG_KOREAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon53
STBTT_MS_LANG_RUSSIAN	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon53
STBTT_MS_LANG_SPANISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon53
STBTT_MS_LANG_SWEDISH	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon53
STBTT_PLATFORM_ID_ISO	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon49
STBTT_PLATFORM_ID_MAC	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon49
STBTT_PLATFORM_ID_MICROSOFT	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon49
STBTT_PLATFORM_ID_UNICODE	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon49
STBTT_POINT_SIZE	abstract-machine/libs/imgui/include/stb_truetype.h	540;"	d
STBTT_RASTERIZER_VERSION	abstract-machine/libs/imgui/include/stb_truetype.h	962;"	d
STBTT_STATIC	abstract-machine/libs/imgui/src/imgui_draw.cpp	82;"	d	file:
STBTT_UNICODE_EID_ISO_10646	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon50
STBTT_UNICODE_EID_UNICODE_1_0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon50
STBTT_UNICODE_EID_UNICODE_1_1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon50
STBTT_UNICODE_EID_UNICODE_2_0_BMP	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon50
STBTT_UNICODE_EID_UNICODE_2_0_FULL	abstract-machine/libs/imgui/include/stb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon50
STBTT__COMPARE	abstract-machine/libs/imgui/include/stb_truetype.h	2826;"	d
STBTT__CSCTX_INIT	abstract-machine/libs/imgui/include/stb_truetype.h	1736;"	d
STBTT__CSERR	abstract-machine/libs/imgui/include/stb_truetype.h	1845;"	d
STBTT__CSERR	abstract-machine/libs/imgui/include/stb_truetype.h	2093;"	d
STBTT__NOTUSED	abstract-machine/libs/imgui/include/stb_truetype.h	966;"	d
STBTT__NOTUSED	abstract-machine/libs/imgui/include/stb_truetype.h	968;"	d
STBTT__OVER_MASK	abstract-machine/libs/imgui/include/stb_truetype.h	3427;"	d
STBTT_assert	abstract-machine/libs/imgui/include/stb_truetype.h	419;"	d
STBTT_assert	abstract-machine/libs/imgui/src/imgui_draw.cpp	80;"	d	file:
STBTT_fabs	abstract-machine/libs/imgui/include/stb_truetype.h	409;"	d
STBTT_free	abstract-machine/libs/imgui/include/stb_truetype.h	415;"	d
STBTT_free	abstract-machine/libs/imgui/src/imgui_draw.cpp	79;"	d	file:
STBTT_iceil	abstract-machine/libs/imgui/include/stb_truetype.h	401;"	d
STBTT_ifloor	abstract-machine/libs/imgui/include/stb_truetype.h	400;"	d
STBTT_malloc	abstract-machine/libs/imgui/include/stb_truetype.h	414;"	d
STBTT_malloc	abstract-machine/libs/imgui/src/imgui_draw.cpp	78;"	d	file:
STBTT_memcpy	abstract-machine/libs/imgui/include/stb_truetype.h	427;"	d
STBTT_memset	abstract-machine/libs/imgui/include/stb_truetype.h	428;"	d
STBTT_sqrt	abstract-machine/libs/imgui/include/stb_truetype.h	405;"	d
STBTT_strlen	abstract-machine/libs/imgui/include/stb_truetype.h	423;"	d
STBTT_vcubic	abstract-machine/libs/imgui/include/stb_truetype.h	/^      STBTT_vcubic$/;"	e	enum:__anon46
STBTT_vcurve	abstract-machine/libs/imgui/include/stb_truetype.h	/^      STBTT_vcurve,$/;"	e	enum:__anon46
STBTT_vline	abstract-machine/libs/imgui/include/stb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon46
STBTT_vmove	abstract-machine/libs/imgui/include/stb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon46
STB_INCLUDE_STB_RECT_PACK_H	abstract-machine/libs/imgui/include/stb_rect_pack.h	56;"	d
STB_RECT_PACK_IMPLEMENTATION	abstract-machine/libs/imgui/src/imgui_draw.cpp	74;"	d	file:
STB_RECT_PACK_VERSION	abstract-machine/libs/imgui/include/stb_rect_pack.h	58;"	d
STB_TEXTEDIT_CHARTYPE	abstract-machine/libs/imgui/include/imgui_internal.h	56;"	d
STB_TEXTEDIT_CHARTYPE	abstract-machine/libs/imgui/include/imgui_internal.h	58;"	d
STB_TEXTEDIT_CHARTYPE	abstract-machine/libs/imgui/include/stb_textedit.h	290;"	d
STB_TEXTEDIT_DELETECHARS	abstract-machine/libs/imgui/src/imgui.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int pos, int n)
STB_TEXTEDIT_GETCHAR	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->Text[idx]; }$/;"	f	namespace:ImGuiStb	signature:(const STB_TEXTEDIT_STRING* obj, int idx)
STB_TEXTEDIT_GETWIDTH	abstract-machine/libs/imgui/src/imgui.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->Text[line_start_idx+char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize \/ GImGui->Font->FontSize); }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)
STB_TEXTEDIT_GETWIDTH_NEWLINE	abstract-machine/libs/imgui/include/imgui_internal.h	59;"	d
STB_TEXTEDIT_IMPLEMENTATION	abstract-machine/libs/imgui/src/imgui.cpp	7376;"	d	file:
STB_TEXTEDIT_INSERTCHARS	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
STB_TEXTEDIT_KEYTOTEXT	abstract-machine/libs/imgui/src/imgui.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }$/;"	f	namespace:ImGuiStb	signature:(int key)
STB_TEXTEDIT_K_BACKSPACE	abstract-machine/libs/imgui/src/imgui.cpp	7369;"	d	file:
STB_TEXTEDIT_K_DELETE	abstract-machine/libs/imgui/src/imgui.cpp	7368;"	d	file:
STB_TEXTEDIT_K_DOWN	abstract-machine/libs/imgui/src/imgui.cpp	7363;"	d	file:
STB_TEXTEDIT_K_LEFT	abstract-machine/libs/imgui/src/imgui.cpp	7360;"	d	file:
STB_TEXTEDIT_K_LINEEND	abstract-machine/libs/imgui/src/imgui.cpp	7365;"	d	file:
STB_TEXTEDIT_K_LINESTART	abstract-machine/libs/imgui/src/imgui.cpp	7364;"	d	file:
STB_TEXTEDIT_K_REDO	abstract-machine/libs/imgui/src/imgui.cpp	7371;"	d	file:
STB_TEXTEDIT_K_RIGHT	abstract-machine/libs/imgui/src/imgui.cpp	7361;"	d	file:
STB_TEXTEDIT_K_SHIFT	abstract-machine/libs/imgui/src/imgui.cpp	7374;"	d	file:
STB_TEXTEDIT_K_TEXTEND	abstract-machine/libs/imgui/src/imgui.cpp	7367;"	d	file:
STB_TEXTEDIT_K_TEXTSTART	abstract-machine/libs/imgui/src/imgui.cpp	7366;"	d	file:
STB_TEXTEDIT_K_UNDO	abstract-machine/libs/imgui/src/imgui.cpp	7370;"	d	file:
STB_TEXTEDIT_K_UP	abstract-machine/libs/imgui/src/imgui.cpp	7362;"	d	file:
STB_TEXTEDIT_K_WORDLEFT	abstract-machine/libs/imgui/src/imgui.cpp	7372;"	d	file:
STB_TEXTEDIT_K_WORDRIGHT	abstract-machine/libs/imgui/src/imgui.cpp	7373;"	d	file:
STB_TEXTEDIT_LAYOUTROW	abstract-machine/libs/imgui/src/imgui.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	namespace:ImGuiStb	signature:(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
STB_TEXTEDIT_MOVEWORDLEFT	abstract-machine/libs/imgui/include/stb_textedit.h	637;"	d
STB_TEXTEDIT_MOVEWORDLEFT	abstract-machine/libs/imgui/src/imgui.cpp	7318;"	d	file:
STB_TEXTEDIT_MOVEWORDLEFT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
STB_TEXTEDIT_MOVEWORDRIGHT	abstract-machine/libs/imgui/include/stb_textedit.h	653;"	d
STB_TEXTEDIT_MOVEWORDRIGHT	abstract-machine/libs/imgui/src/imgui.cpp	7319;"	d	file:
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
STB_TEXTEDIT_NEWLINE	abstract-machine/libs/imgui/src/imgui.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	m	namespace:ImGuiStb	file:
STB_TEXTEDIT_POSITIONTYPE	abstract-machine/libs/imgui/include/stb_textedit.h	293;"	d
STB_TEXTEDIT_STRING	abstract-machine/libs/imgui/include/imgui_internal.h	55;"	d
STB_TEXTEDIT_STRING	abstract-machine/libs/imgui/include/imgui_internal.h	57;"	d
STB_TEXTEDIT_STRINGLEN	abstract-machine/libs/imgui/src/imgui.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	namespace:ImGuiStb	signature:(const STB_TEXTEDIT_STRING* obj)
STB_TEXTEDIT_UNDOCHARCOUNT	abstract-machine/libs/imgui/include/stb_textedit.h	287;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	abstract-machine/libs/imgui/include/stb_textedit.h	284;"	d
STB_TEXTEDIT_memmove	abstract-machine/libs/imgui/include/stb_textedit.h	380;"	d
STB_TEXT_HAS_SELECTION	abstract-machine/libs/imgui/include/stb_textedit.h	546;"	d
STB_TRUETYPE_IMPLEMENTATION	abstract-machine/libs/imgui/src/imgui_draw.cpp	83;"	d	file:
STB_TexteditState	abstract-machine/libs/imgui/include/stb_textedit.h	/^} STB_TexteditState;$/;"	t	typeref:struct:__anon34
STEP	abstract-machine/am/src/x86/qemu/trm.c	34;"	d	file:
STRINGIFY	abstract-machine/am/src/x86/x86-qemu.h	77;"	d
STS_IG32	abstract-machine/am/include/x86.h	15;"	d
STS_T32A	abstract-machine/am/include/x86.h	14;"	d
STS_TG32	abstract-machine/am/include/x86.h	16;"	d
SUCCESS	abstract-machine/apps/microbench/src/bf/bf.c	42;"	d	file:
SVR	abstract-machine/am/src/x86/qemu/devices/apic.c	14;"	d	file:
SameLine	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);              \/\/ call between widgets or groups to layout them horizontally$/;"	p	namespace:ImGui	signature:(float pos_x = 0.0f, float spacing_w = -1.0f)
SameLine	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SameLine(float pos_x, float spacing_w)$/;"	f	class:ImGui	signature:(float pos_x, float spacing_w)
SaveIniSettingsToDisk	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SaveIniSettingsToDisk(const char* ini_filename);$/;"	p	file:	signature:(const char* ini_filename)
SaveIniSettingsToDisk	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SaveIniSettingsToDisk(const char* ini_filename)$/;"	f	file:	signature:(const char* ini_filename)
ScalarAsInputTextId	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiID                 ScalarAsInputTextId;                \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiContext	access:public
Scale	abstract-machine/libs/imgui/include/imgui.h	/^    float                       Scale;              \/\/ = 1.f        \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()$/;"	m	struct:ImFont	access:public
ScaleClipRects	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void ScaleClipRects(const ImVec2& sc);  \/\/ Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.$/;"	p	struct:ImDrawData	access:public	signature:(const ImVec2& sc)
ScaleClipRects	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawData::ScaleClipRects(const ImVec2& scale)$/;"	f	class:ImDrawData	signature:(const ImVec2& scale)
Scroll	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Scroll;$/;"	m	struct:ImGuiWindow	access:public
ScrollTarget	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollTarget;                       \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow	access:public
ScrollTargetCenterRatio	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollTargetCenterRatio;            \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow	access:public
ScrollToBottom	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:	access:public
ScrollToBottom	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    bool                ScrollToBottom;$/;"	m	struct:ExampleAppLog	file:	access:public
ScrollX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float               ScrollX;$/;"	m	struct:ImGuiTextEditState	access:public
Scrollbar	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             Scrollbar(ImGuiWindow* window, bool horizontal);$/;"	p	file:	signature:(ImGuiWindow* window, bool horizontal)
Scrollbar	abstract-machine/libs/imgui/src/imgui.cpp	/^static void Scrollbar(ImGuiWindow* window, bool horizontal)$/;"	f	file:	signature:(ImGuiWindow* window, bool horizontal)
ScrollbarClickDeltaToGrabCenter	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollbarClickDeltaToGrabCenter;    \/\/ Distance between mouse and center of grab box, normalized in parent space. Use storage?$/;"	m	struct:ImGuiContext	access:public
ScrollbarRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar$/;"	m	struct:ImGuiStyle	access:public
ScrollbarSize	abstract-machine/libs/imgui/include/imgui.h	/^    float       ScrollbarSize;              \/\/ Width of the vertical scrollbar, Height of the horizontal scrollbar$/;"	m	struct:ImGuiStyle	access:public
ScrollbarSizes	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  ScrollbarSizes;$/;"	m	struct:ImGuiWindow	access:public
ScrollbarX	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow	access:public
ScrollbarY	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow	access:public
SegDesc	abstract-machine/am/include/x86.h	/^typedef struct SegDesc {$/;"	s
SegDesc	abstract-machine/am/include/x86.h	/^} SegDesc;$/;"	t	typeref:struct:SegDesc
SegDesc::avl	abstract-machine/am/include/x86.h	/^  uint32_t avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:SegDesc	access:public
SegDesc::base_15_0	abstract-machine/am/include/x86.h	/^  uint32_t base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:SegDesc	access:public
SegDesc::base_23_16	abstract-machine/am/include/x86.h	/^  uint32_t base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:SegDesc	access:public
SegDesc::base_31_24	abstract-machine/am/include/x86.h	/^  uint32_t base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:SegDesc	access:public
SegDesc::db	abstract-machine/am/include/x86.h	/^  uint32_t db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:SegDesc	access:public
SegDesc::dpl	abstract-machine/am/include/x86.h	/^  uint32_t dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:SegDesc	access:public
SegDesc::g	abstract-machine/am/include/x86.h	/^  uint32_t g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:SegDesc	access:public
SegDesc::lim_15_0	abstract-machine/am/include/x86.h	/^  uint32_t lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:SegDesc	access:public
SegDesc::lim_19_16	abstract-machine/am/include/x86.h	/^  uint32_t lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:SegDesc	access:public
SegDesc::p	abstract-machine/am/include/x86.h	/^  uint32_t p : 1;          \/\/ Present$/;"	m	struct:SegDesc	access:public
SegDesc::rsv1	abstract-machine/am/include/x86.h	/^  uint32_t rsv1 : 1;       \/\/ Reserved$/;"	m	struct:SegDesc	access:public
SegDesc::s	abstract-machine/am/include/x86.h	/^  uint32_t s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:SegDesc	access:public
SegDesc::type	abstract-machine/am/include/x86.h	/^  uint32_t type : 4  ;     \/\/ Segment type (see STS_ constants)$/;"	m	struct:SegDesc	access:public
SelectAll	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void                SelectAll()                 { StbState.select_start = 0; StbState.select_end = CurLenW; StbState.cursor = StbState.select_end; StbState.has_preferred_x = false; }$/;"	f	struct:ImGuiTextEditState	access:public	signature:()
Selectable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));  \/\/ size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height$/;"	p	namespace:ImGui	signature:(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
Selectable	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0));$/;"	p	namespace:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2& size = ImVec2(0,0))
Selectable	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
Selectable	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui	signature:(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
SelectedAllMouseLock	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                SelectedAllMouseLock;$/;"	m	struct:ImGuiTextEditState	access:public
SelectionEnd	abstract-machine/libs/imgui/include/imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write$/;"	m	struct:ImGuiTextEditCallbackData	access:public
SelectionStart	abstract-machine/libs/imgui/include/imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write (== to SelectionEnd when no selection)$/;"	m	struct:ImGuiTextEditCallbackData	access:public
Separator	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Separator();                                                        \/\/ horizontal line$/;"	p	namespace:ImGui	signature:()
Separator	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui	signature:()
SetActiveID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiWindow* window)
SetActiveID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiWindow* window)
SetAllInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetAllInt(int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(int val)
SetAllInt	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage	signature:(int v)
SetBool	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetBool(ImGuiID key, bool val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, bool val)
SetBool	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetBool(ImGuiID key, bool val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, bool val)
SetClipboardText	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetClipboardText(const char* text);$/;"	p	namespace:ImGui	signature:(const char* text)
SetClipboardText	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetClipboardText(const char* text)$/;"	f	class:ImGui	signature:(const char* text)
SetClipboardTextFn	abstract-machine/libs/imgui/include/imgui.h	/^    void        (*SetClipboardTextFn)(void* user_data, const char* text);$/;"	m	struct:ImGuiIO	access:public
SetClipboardTextFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);$/;"	p	file:	signature:(void* user_data, const char* text)
SetClipboardTextFn_DefaultImpl	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetClipboardTextFn_DefaultImpl(void*, const char* text)$/;"	f	file:	signature:(void*, const char* text)
SetColumnOffset	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  \/\/ set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column$/;"	p	namespace:ImGui	signature:(int column_index, float offset_x)
SetColumnOffset	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui	signature:(int column_index, float offset)
SetCurrentContext	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);$/;"	p	namespace:ImGui	signature:(ImGuiContext* ctx)
SetCurrentContext	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCurrentContext(ImGuiContext* ctx)$/;"	f	class:ImGui	signature:(ImGuiContext* ctx)
SetCurrentFont	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetCurrentFont(ImFont* font);$/;"	p	file:	signature:(ImFont* font)
SetCurrentFont	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetCurrentFont(ImFont* font)$/;"	f	file:	signature:(ImFont* font)
SetCurrentWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetCurrentWindow(ImGuiWindow* window);$/;"	p	file:	signature:(ImGuiWindow* window)
SetCurrentWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetCurrentWindow(ImGuiWindow* window)$/;"	f	file:	signature:(ImGuiWindow* window)
SetCursorPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                              \/\/ "$/;"	p	namespace:ImGui	signature:(const ImVec2& local_pos)
SetCursorPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& local_pos)$/;"	f	class:ImGui	signature:(const ImVec2& local_pos)
SetCursorPosX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPosX(float x);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float x)
SetCursorPosX	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui	signature:(float x)
SetCursorPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorPosY(float y);                                             \/\/ "$/;"	p	namespace:ImGui	signature:(float y)
SetCursorPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui	signature:(float y)
SetCursorPosYAndSetupDummyPrevLine	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)$/;"	f	file:	signature:(float pos_y, float line_height)
SetCursorScreenPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetCursorScreenPos(const ImVec2& pos);                              \/\/ cursor position in absolute screen coordinates [0..io.DisplaySize]$/;"	p	namespace:ImGui	signature:(const ImVec2& pos)
SetCursorScreenPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)$/;"	f	class:ImGui	signature:(const ImVec2& screen_pos)
SetFallbackChar	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void              SetFallbackChar(ImWchar c);$/;"	p	struct:ImFont	access:public	signature:(ImWchar c)
SetFallbackChar	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont	signature:(ImWchar c)
SetFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetFloat(ImGuiID key, float val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, float val)
SetFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetFloat(ImGuiID key, float val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, float val)
SetHSV	abstract-machine/libs/imgui/include/imgui.h	/^    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }$/;"	f	struct:ImColor	access:public	signature:(float h, float s, float v, float a = 1.0f)
SetHoveredID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          SetHoveredID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
SetHoveredID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetHoveredID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
SetInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetInt(ImGuiID key, int val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, int val)
SetInt	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetInt(ImGuiID key, int val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, int val)
SetItemAllowOverlap	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetItemAllowOverlap();                                              \/\/ allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.$/;"	p	namespace:ImGui	signature:()
SetItemAllowOverlap	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetItemAllowOverlap()$/;"	f	class:ImGui	signature:()
SetKeyboardFocusHere	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               \/\/ focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use negative 'offset' to access previous widgets.$/;"	p	namespace:ImGui	signature:(int offset = 0)
SetKeyboardFocusHere	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui	signature:(int offset)
SetMouseCursor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              \/\/ set desired cursor type$/;"	p	namespace:ImGui	signature:(ImGuiMouseCursor type)
SetMouseCursor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui	signature:(ImGuiMouseCursor cursor_type)
SetNextTreeNodeOpen	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond = 0);               \/\/ set next TreeNode\/CollapsingHeader open state.$/;"	p	namespace:ImGui	signature:(bool is_open, ImGuiSetCond cond = 0)
SetNextTreeNodeOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool is_open, ImGuiSetCond cond)
SetNextTreeNodeOpenCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextTreeNodeOpenCond;$/;"	m	struct:ImGuiContext	access:public
SetNextTreeNodeOpenVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextTreeNodeOpenVal;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);      \/\/ set next window collapsed state. call before Begin()$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
SetNextWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
SetNextWindowCollapsedCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowCollapsedCond;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowCollapsedVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowCollapsedVal;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowContentSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                       \/\/ set next window content size (enforce the range of scrollbars). set axis to 0.0f to leave it automatic. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size)
SetNextWindowContentSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowContentSize(const ImVec2& size)$/;"	f	class:ImGui	signature:(const ImVec2& size)
SetNextWindowContentSizeCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowContentSizeCond;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowContentSizeVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowContentSizeVal;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowContentWidth	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowContentWidth(float width);                             \/\/ set next window content width (enforce the range of horizontal scrollbar). call before Begin()$/;"	p	namespace:ImGui	signature:(float width)
SetNextWindowContentWidth	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowContentWidth(float width)$/;"	f	class:ImGui	signature:(float width)
SetNextWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowFocus();                                               \/\/ set next window to be focused \/ front-most. call before Begin()$/;"	p	namespace:ImGui	signature:()
SetNextWindowFocus	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowFocus;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui	signature:()
SetNextWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);         \/\/ set next window position. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
SetNextWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
SetNextWindowPosCenter	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowPosCenter(ImGuiSetCond cond = 0);                      \/\/ set next window position to be centered on screen. call before Begin()$/;"	p	namespace:ImGui	signature:(ImGuiSetCond cond = 0)
SetNextWindowPosCenter	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowPosCenter(ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(ImGuiSetCond cond)
SetNextWindowPosCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowPosCond;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowPosVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowPosVal;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);       \/\/ set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()$/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
SetNextWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
SetNextWindowSizeCond	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSetCond            SetNextWindowSizeCond;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSizeConstraint	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetNextWindowSizeConstraint;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSizeConstraintCallback	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiSizeConstraintCallback SetNextWindowSizeConstraintCallback;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSizeConstraintCallbackUserData	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void*                       SetNextWindowSizeConstraintCallbackUserData;$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSizeConstraintRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  SetNextWindowSizeConstraintRect;           \/\/ Valid if 'SetNextWindowSizeConstraint' is true$/;"	m	struct:ImGuiContext	access:public
SetNextWindowSizeConstraints	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL); \/\/ set next window size limits. use -1,-1 on either X\/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.$/;"	p	namespace:ImGui	signature:(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback = NULL, void* custom_callback_data = NULL)
SetNextWindowSizeConstraints	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)$/;"	f	class:ImGui	signature:(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeConstraintCallback custom_callback, void* custom_callback_user_data)
SetNextWindowSizeVal	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SetNextWindowSizeVal;$/;"	m	struct:ImGuiContext	access:public
SetScrollFromPosY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);        \/\/ adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.$/;"	p	namespace:ImGui	signature:(float pos_y, float center_y_ratio = 0.5f)
SetScrollFromPosY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)$/;"	f	class:ImGui	signature:(float pos_y, float center_y_ratio)
SetScrollHere	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                         \/\/ adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom.$/;"	p	namespace:ImGui	signature:(float center_y_ratio = 0.5f)
SetScrollHere	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollHere(float center_y_ratio)$/;"	f	class:ImGui	signature:(float center_y_ratio)
SetScrollPosHere	abstract-machine/libs/imgui/include/imgui.h	/^    static inline void      SetScrollPosHere() { SetScrollHere(); }                            \/\/ OBSOLETE 1.42+$/;"	f	namespace:ImGui	signature:()
SetScrollX	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollX(float scroll_x);                                         \/\/ set scrolling amount [0..GetScrollMaxX()]$/;"	p	namespace:ImGui	signature:(float scroll_x)
SetScrollX	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollX(float scroll_x)$/;"	f	class:ImGui	signature:(float scroll_x)
SetScrollY	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetScrollY(float scroll_y);                                         \/\/ set scrolling amount [0..GetScrollMaxY()]$/;"	p	namespace:ImGui	signature:(float scroll_y)
SetScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui	signature:(float scroll_y)
SetStateStorage	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetStateStorage(ImGuiStorage* tree);                                \/\/ replace tree state storage with our own (if you want to manipulate it yourself, typically clear subsection of it)$/;"	p	namespace:ImGui	signature:(ImGuiStorage* tree)
SetStateStorage	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui	signature:(ImGuiStorage* tree)
SetTexID	abstract-machine/libs/imgui/include/imgui.h	/^    void                        SetTexID(void* id)  { TexID = id; }$/;"	f	struct:ImFontAtlas	access:public	signature:(void* id)
SetTooltip	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
SetTooltipV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetTooltipV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
SetTooltipV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
SetVoidPtr	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);$/;"	p	struct:ImGuiStorage	access:public	signature:(ImGuiID key, void* val)
SetVoidPtr	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)$/;"	f	class:ImGuiStorage	signature:(ImGuiID key, void* val)
SetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiSetCond cond = 0);          \/\/ (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().$/;"	p	namespace:ImGui	signature:(bool collapsed, ImGuiSetCond cond = 0)
SetWindowCollapsed	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond = 0);   \/\/ set named window collapsed state$/;"	p	namespace:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond = 0)
SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond);$/;"	p	file:	signature:(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(bool collapsed, ImGuiSetCond cond)
SetWindowCollapsed	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, bool collapsed, ImGuiSetCond cond)
SetWindowCollapsedAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowCollapsedAllowFlags;       \/\/ bit ImGuiSetCond_*** specify if SetWindowCollapsed() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
SetWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFocus();                                                   \/\/ (not recommended) set current window to be focused \/ front-most. prefer using SetNextWindowFocus().$/;"	p	namespace:ImGui	signature:()
SetWindowFocus	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFocus(const char* name);                                              \/\/ set named window to be focused \/ front-most. use NULL to remove focus.$/;"	p	namespace:ImGui	signature:(const char* name)
SetWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui	signature:()
SetWindowFocus	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui	signature:(const char* name)
SetWindowFontScale	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowFontScale(float scale);                                    \/\/ per-window font scale. Adjust IO.FontGlobalScale if you want to scale all windows$/;"	p	namespace:ImGui	signature:(float scale)
SetWindowFontScale	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui	signature:(float scale)
SetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiSetCond cond = 0);             \/\/ (not recommended) set current window position - call within Begin()\/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.$/;"	p	namespace:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond = 0)
SetWindowPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0);      \/\/ set named window position.$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond = 0)
SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond);$/;"	p	file:	signature:(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& pos, ImGuiSetCond cond)
SetWindowPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& pos, ImGuiSetCond cond)
SetWindowPosAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowPosAllowFlags;             \/\/ bit ImGuiSetCond_*** specify if SetWindowPos() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
SetWindowPosCenterWanted	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SetWindowPosCenterWanted;$/;"	m	struct:ImGuiWindow	access:public
SetWindowScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);$/;"	p	file:	signature:(ImGuiWindow* window, float new_scroll_y)
SetWindowScrollY	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)$/;"	f	file:	signature:(ImGuiWindow* window, float new_scroll_y)
SetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiSetCond cond = 0);           \/\/ (not recommended) set current window size - call within Begin()\/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.    $/;"	p	namespace:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond = 0)
SetWindowSize	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond = 0);    \/\/ set named window size. set axis to 0.0f to force an auto-fit on this axis.$/;"	p	namespace:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond = 0)
SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^static void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond);$/;"	p	file:	signature:(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)$/;"	f	file:	signature:(ImGuiWindow* window, const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const ImVec2& size, ImGuiSetCond cond)
SetWindowSize	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiSetCond cond)$/;"	f	class:ImGui	signature:(const char* name, const ImVec2& size, ImGuiSetCond cond)
SetWindowSizeAllowFlags	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     SetWindowSizeAllowFlags;            \/\/ bit ImGuiSetCond_*** specify if SetWindowSize() call will succeed with this particular flag.$/;"	m	struct:ImGuiWindow	access:public
Setting	abstract-machine/apps/microbench/include/benchmark.h	/^typedef struct Setting {$/;"	s
Setting	abstract-machine/apps/microbench/include/benchmark.h	/^} Setting;$/;"	t	typeref:struct:Setting
Setting::checksum	abstract-machine/apps/microbench/include/benchmark.h	/^  uint32_t checksum;$/;"	m	struct:Setting	access:public
Setting::mlim	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long mlim, ref;$/;"	m	struct:Setting	access:public
Setting::ref	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long mlim, ref;$/;"	m	struct:Setting	access:public
Setting::size	abstract-machine/apps/microbench/include/benchmark.h	/^  int size;$/;"	m	struct:Setting	access:public
Settings	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiIniData>  Settings;                           \/\/ .ini Settings$/;"	m	struct:ImGuiContext	access:public
SettingsDirtyTimer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   SettingsDirtyTimer;                 \/\/ Save .ini Settings on disk when time reaches zero$/;"	m	struct:ImGuiContext	access:public
ShowExampleAppAutoResize	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppAutoResize(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppAutoResize	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppAutoResize(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppConsole(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppConsole(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppConstrainedResize	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppConstrainedResize(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppConstrainedResize	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppConstrainedResize(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppCustomRendering	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppCustomRendering(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppCustomRendering	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppCustomRendering(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppFixedOverlay	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppFixedOverlay(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppFixedOverlay	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppFixedOverlay(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppLayout	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLayout(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppLayout	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLayout(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppLog	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLog(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppLog	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLog(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppLongText	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLongText(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppLongText	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppLongText(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppMainMenuBar	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppMainMenuBar()$/;"	f	file:	signature:()
ShowExampleAppMainMenuBar	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppMainMenuBar();$/;"	p	file:	signature:()
ShowExampleAppManipulatingWindowTitle	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppManipulatingWindowTitle(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleAppManipulatingWindowTitle	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppManipulatingWindowTitle(bool*)$/;"	f	file:	signature:(bool*)
ShowExampleAppPropertyEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppPropertyEditor(bool* p_open)$/;"	f	file:	signature:(bool* p_open)
ShowExampleAppPropertyEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleAppPropertyEditor(bool* p_open);$/;"	p	file:	signature:(bool* p_open)
ShowExampleMenuFile	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleMenuFile()$/;"	f	file:	signature:()
ShowExampleMenuFile	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowExampleMenuFile();$/;"	p	file:	signature:()
ShowHelpMarker	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^static void ShowHelpMarker(const char* desc)$/;"	f	file:	signature:(const char* desc)
ShowMetricsWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     \/\/ metrics window for debugging ImGui (browse draw commands, individual vertices, window list, etc.)$/;"	p	namespace:ImGui	signature:(bool* p_open = NULL)
ShowMetricsWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* p_open)$/;"	f	class:ImGui	signature:(bool* p_open)
ShowStyleEditor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    \/\/ style editor block. you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)$/;"	p	namespace:ImGui	signature:(ImGuiStyle* ref = NULL)
ShowStyleEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui	signature:(ImGuiStyle* ref)
ShowStyleEditor	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle*) {}$/;"	f	class:ImGui	signature:(ImGuiStyle*)
ShowTestWindow	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowTestWindow(bool* p_open = NULL);        \/\/ test window demonstrating ImGui features$/;"	p	namespace:ImGui	signature:(bool* p_open = NULL)
ShowTestWindow	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool* p_open)$/;"	f	class:ImGui	signature:(bool* p_open)
ShowTestWindow	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowTestWindow(bool*) {}$/;"	f	class:ImGui	signature:(bool*)
ShowUserGuide	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ShowUserGuide();                            \/\/ help block$/;"	p	namespace:ImGui	signature:()
ShowUserGuide	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowUserGuide() {}$/;"	f	class:ImGui	signature:()
ShowUserGuide	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui	signature:()
Shutdown	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Shutdown();$/;"	p	namespace:ImGui	signature:()
Shutdown	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Shutdown()$/;"	f	class:ImGui	signature:()
Size	abstract-machine/libs/imgui/include/imgui.h	/^    int                         Size;$/;"	m	class:ImVector	access:public
Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow	access:public
Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              Size;$/;"	m	struct:ImGuiMouseCursorData	access:public
Size	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2      Size;$/;"	m	struct:ImGuiIniData	access:public
SizeContents	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeContents;                       \/\/ Size of contents (== extents reach of the drawing cursor) from previous frame$/;"	m	struct:ImGuiWindow	access:public
SizeContentsExplicit	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeContentsExplicit;               \/\/ Size of contents explicitly set by the user via SetNextWindowContentSize()$/;"	m	struct:ImGuiWindow	access:public
SizeFull	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow	access:public
SizePixels	abstract-machine/libs/imgui/include/imgui.h	/^    float           SizePixels;                 \/\/          \/\/ Size in pixels for rasterizer$/;"	m	struct:ImFontConfig	access:public
SkipItems	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    SkipItems;                          \/\/ == Visible && !Collapsed$/;"	m	struct:ImGuiWindow	access:public
SliderAngle	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f)
SliderAngle	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)$/;"	f	class:ImGui	signature:(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
SliderBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0)
SliderBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)$/;"	f	class:ImGui	signature:(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)
SliderBehaviorCalcRatioFromValue	abstract-machine/libs/imgui/src/imgui.cpp	/^static inline float SliderBehaviorCalcRatioFromValue(float v, float v_min, float v_max, float power, float linear_zero_pos)$/;"	f	file:	signature:(float v, float v_min, float v_max, float power, float linear_zero_pos)
SliderFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     \/\/ adjust display_format to decorate the value with a prefix or a suffix. Use power!=1.0 for logarithmic sliders$/;"	p	namespace:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format = , float power = 1.0f)
SliderFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
SliderFloat2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format = , float power = 1.0f)
SliderFloat2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
SliderFloat3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format = , float power = 1.0f)
SliderFloat3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
SliderFloat4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format = , float power = 1.0f)
SliderFloat4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
SliderFloatN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power);$/;"	p	namespace:ImGui	signature:(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
SliderFloatN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
SliderInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format = )
SliderInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int v_min, int v_max, const char* display_format)
SliderInt2	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format = )
SliderInt2	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[2], int v_min, int v_max, const char* display_format)
SliderInt3	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format = )
SliderInt3	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[3], int v_min, int v_max, const char* display_format)
SliderInt4	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format = )
SliderInt4	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int v[4], int v_min, int v_max, const char* display_format)
SliderIntN	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format);$/;"	p	namespace:ImGui	signature:(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
SliderIntN	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
SmallButton	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          SmallButton(const char* label);                                         \/\/ button with FramePadding=(0,0)$/;"	p	namespace:ImGui	signature:(const char* label)
SmallButton	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
Spacing	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Spacing();                                                          \/\/ add vertical spacing$/;"	p	namespace:ImGui	signature:()
Spacing	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Spacing;$/;"	m	struct:ImGuiSimpleColumns	access:public
Spacing	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui	signature:()
StackSizesBackup	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiDrawContext	access:public
StartPosY	abstract-machine/libs/imgui/include/imgui.h	/^    float   StartPosY;$/;"	m	struct:ImGuiListClipper	access:public
Start_Timer	abstract-machine/apps/dhrystone/dry.c	356;"	d	file:
StateStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow	access:public
StateStorage	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiDrawContext	access:public
StbFindState	abstract-machine/libs/imgui/include/stb_textedit.h	/^} StbFindState;$/;"	t	typeref:struct:__anon36
StbState	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStb::STB_TexteditState   StbState;$/;"	m	struct:ImGuiTextEditState	access:public
StbTexteditRow	abstract-machine/libs/imgui/include/stb_textedit.h	/^} StbTexteditRow;$/;"	t	typeref:struct:__anon35
StbUndoRecord	abstract-machine/libs/imgui/include/stb_textedit.h	/^} StbUndoRecord;$/;"	t	typeref:struct:__anon32
StbUndoState	abstract-machine/libs/imgui/include/stb_textedit.h	/^} StbUndoState;$/;"	t	typeref:struct:__anon33
Step	abstract-machine/apps/microbench/src/15pz/heap.h	/^    class Step;$/;"	x
Step	abstract-machine/apps/microbench/src/15pz/heap.h	/^class Updatable_heap<T, M>::Step {$/;"	c	class:Updatable_heap
Step	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool Step();                                              \/\/ Call until it returns false. The DisplayStart\/DisplayEnd fields will be set and you can process\/draw those items.$/;"	p	struct:ImGuiListClipper	access:public	signature:()
Step	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGuiListClipper::Step()$/;"	f	class:ImGuiListClipper	signature:()
StepNo	abstract-machine/libs/imgui/include/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper	access:public
Stop_Timer	abstract-machine/apps/dhrystone/dry.c	357;"	d	file:
Str_2_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Str_2_Comp [31];$/;"	m	struct:record::__anon12::__anon14	file:	access:public
Str_30	abstract-machine/apps/dhrystone/dry.c	/^typedef char    Str_30 [31];$/;"	t	file:
Str_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Str_Comp [31];$/;"	m	struct:record::__anon12::__anon13	file:	access:public
Strdup	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buff = kalloc(len); return (char*)memcpy(buff, (const void*)str, len); }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char *str)
Stricmp	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* str1, const char* str2)
Stride	abstract-machine/libs/imgui/src/imgui.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
Strnicmp	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }$/;"	f	struct:ExampleAppConsole	access:public	signature:(const char* str1, const char* str2, int n)
Style	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiContext	access:public
StyleModifiers	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiStyleMod> StyleModifiers;                     \/\/ Stack for PushStyleVar()\/PopStyleVar()$/;"	m	struct:ImGuiContext	access:public
T	abstract-machine/apps/microbench/src/fib/fib.c	/^static uint32_t *A, *ans, *T, *tmp;$/;"	v	file:
TASK	amgame/Makefile	/^export TASK    := L0$/;"	m
TASK	pstree/Makefile	/^export TASK := M1$/;"	m
TCCR	abstract-machine/am/src/x86/qemu/devices/apic.c	37;"	d	file:
TDCR	abstract-machine/am/src/x86/qemu/devices/apic.c	38;"	d	file:
THREE_PI_DIV_4	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t THREE_PI_DIV_4 = 0x00025B2F;       \/*!< Fix16 value of 3PI\/4 *\/$/;"	v
TICR	abstract-machine/am/src/x86/qemu/devices/apic.c	36;"	d	file:
TIMER	abstract-machine/am/src/x86/qemu/devices/apic.c	28;"	d	file:
TIMER_RES_DIVIDER	abstract-machine/apps/coremark/src/core_portme.c	35;"	d	file:
TOSTRING	abstract-machine/am/src/x86/x86-qemu.h	78;"	d
TOTAL_DATA_SIZE	abstract-machine/apps/coremark/include/coremark.h	27;"	d
TPR	abstract-machine/am/src/x86/qemu/devices/apic.c	12;"	d	file:
TRACE_ARGS	abstract-machine/am/src/x86/qemu/trace.c	64;"	d	file:
TRACE_CALL	abstract-machine/am/src/x86/qemu/trace.c	42;"	d	file:
TRACE_FUNC	abstract-machine/am/src/x86/qemu/trace.c	79;"	d	file:
TRACE_FUNC	abstract-machine/am/src/x86/qemu/trace.c	91;"	d	file:
TRACE_RET	abstract-machine/am/src/x86/qemu/trace.c	50;"	d	file:
TRACE_THIS	abstract-machine/am/src/x86/qemu/trace.c	139;"	d	file:
TRACE_THIS	abstract-machine/am/src/x86/qemu/trace.c	141;"	d	file:
TRACE_THIS	abstract-machine/am/src/x86/qemu/trace.c	143;"	d	file:
TRACE_THIS	abstract-machine/am/src/x86/qemu/trace.c	145;"	d	file:
TRACE_VOID	abstract-machine/am/src/x86/qemu/trace.c	72;"	d	file:
TRACE_VOID	abstract-machine/am/src/x86/qemu/trace.c	88;"	d	file:
TSS	abstract-machine/am/include/x86.h	/^typedef struct TSS {$/;"	s
TSS	abstract-machine/am/include/x86.h	/^} TSS;$/;"	t	typeref:struct:TSS
TSS::esp0	abstract-machine/am/include/x86.h	/^  uint32_t esp0;     \/\/ Stack pointers and segment selectors$/;"	m	struct:TSS	access:public
TSS::link	abstract-machine/am/include/x86.h	/^  uint32_t link;     \/\/ Unused$/;"	m	struct:TSS	access:public
TSS::padding	abstract-machine/am/include/x86.h	/^  char     padding[88];$/;"	m	struct:TSS	access:public
TSS::ss0	abstract-machine/am/include/x86.h	/^  uint32_t ss0;      \/\/   after an increase in privilege level$/;"	m	struct:TSS	access:public
T_IRQ0	abstract-machine/am/include/x86.h	58;"	d
TempBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char                    TempBuffer[1024*3+1];               \/\/ temporary text buffer$/;"	m	struct:ImGuiContext	access:public
TempTextBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<char>      TempTextBuffer;$/;"	m	struct:ImGuiTextEditState	access:public
TexDesiredWidth	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexDesiredWidth;    \/\/ Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.$/;"	m	struct:ImFontAtlas	access:public
TexHeight	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexHeight;          \/\/ Texture height calculated during Build().$/;"	m	struct:ImFontAtlas	access:public
TexID	abstract-machine/libs/imgui/include/imgui.h	/^    void*                       TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It ia passed back to you during rendering.$/;"	m	struct:ImFontAtlas	access:public
TexPixelsAlpha8	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas	access:public
TexPixelsRGBA32	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas	access:public
TexUvMax	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              TexUvMax[2];$/;"	m	struct:ImGuiMouseCursorData	access:public
TexUvMin	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2              TexUvMin[2];$/;"	m	struct:ImGuiMouseCursorData	access:public
TexUvWhitePixel	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel$/;"	m	struct:ImFontAtlas	access:public
TexWidth	abstract-machine/libs/imgui/include/imgui.h	/^    int                         TexWidth;           \/\/ Texture width calculated during Build().$/;"	m	struct:ImFontAtlas	access:public
Text	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImWchar>   Text;                       \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiTextEditState	access:public
Text	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
TextColored	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, ...)
TextColoredV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
TextColoredV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const ImVec4& col, const char* fmt, va_list args)
TextDisabled	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
TextDisabledV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextDisabledV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
TextDisabledV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextEditCallback	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    int     TextEditCallback(ImGuiTextEditCallbackData* data)$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
TextEditCallbackStub	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    static int TextEditCallbackStub(ImGuiTextEditCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole	access:public	signature:(ImGuiTextEditCallbackData* data)
TextRange	abstract-machine/libs/imgui/include/imgui.h	/^        TextRange() { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
TextRange	abstract-machine/libs/imgui/include/imgui.h	/^        TextRange(const char* _b, const char* _e) { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(const char* _b, const char* _e)
TextRange	abstract-machine/libs/imgui/include/imgui.h	/^    struct TextRange$/;"	s	struct:ImGuiTextFilter	access:public
TextUnformatted	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);         \/\/ doesn't require null terminated string if 'text_end' is specified. no copy done to any bounded stack buffer, recommended for long chunks of text$/;"	p	namespace:ImGui	signature:(const char* text, const char* text_end = NULL)
TextUnformatted	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui	signature:(const char* text, const char* text_end)
TextV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
TextV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextWrapPos	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiDrawContext	access:public
TextWrapPosStack	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiDrawContext	access:public
TextWrapped	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* fmt, ...)
TextWrappedV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TextWrappedV(const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* fmt, va_list args)
TextWrappedV	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* fmt, va_list args)
TextureId	abstract-machine/libs/imgui/include/imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd	access:public
Time	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float                   Time;$/;"	m	struct:ImGuiContext	access:public
TitleBarHeight	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       TitleBarHeight() const                  { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
TitleBarRect	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect      TitleBarRect() const                    { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }$/;"	f	struct:ImGuiWindow	access:public	signature:() const
Tooltip	abstract-machine/libs/imgui/include/imgui_internal.h	/^    char                    Tooltip[1024];$/;"	m	struct:ImGuiContext	access:public
TotalIdxCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all cmd_lists idx_buffer.Size$/;"	m	struct:ImDrawData	access:public
TotalVtxCount	abstract-machine/libs/imgui/include/imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all cmd_lists vtx_buffer.Size$/;"	m	struct:ImDrawData	access:public
TouchExtraPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle	access:public
TrapFrame	abstract-machine/am/include/x86.h	/^typedef struct TrapFrame {$/;"	s
TrapFrame	abstract-machine/am/include/x86.h	/^} TrapFrame;$/;"	t	typeref:struct:TrapFrame
TrapFrame::cs	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
TrapFrame::ds	abstract-machine/am/include/x86.h	/^  uint32_t es, ds;               \/\/ Segment register$/;"	m	struct:TrapFrame	access:public
TrapFrame::eax	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
TrapFrame::ebp	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
TrapFrame::ebx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
TrapFrame::ecx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
TrapFrame::edi	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
TrapFrame::edx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
TrapFrame::eflags	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
TrapFrame::eip	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
TrapFrame::err	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
TrapFrame::es	abstract-machine/am/include/x86.h	/^  uint32_t es, ds;               \/\/ Segment register$/;"	m	struct:TrapFrame	access:public
TrapFrame::esi	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
TrapFrame::esp	abstract-machine/am/include/x86.h	/^  uint32_t esp, ss;              \/\/ Used only when returning to DPL=3$/;"	m	struct:TrapFrame	access:public
TrapFrame::esp_	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
TrapFrame::irq	abstract-machine/am/include/x86.h	/^  int32_t  irq;                  \/\/ # of irq$/;"	m	struct:TrapFrame	access:public
TrapFrame::ss	abstract-machine/am/include/x86.h	/^  uint32_t esp, ss;              \/\/ Used only when returning to DPL=3$/;"	m	struct:TrapFrame	access:public
TreeAdvanceToLabelPos	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreeAdvanceToLabelPos();                                                \/\/ advance cursor x position by GetTreeNodeToLabelSpacing()$/;"	p	namespace:ImGui	signature:()
TreeAdvanceToLabelPos	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreeAdvanceToLabelPos()$/;"	f	class:ImGui	signature:()
TreeDepth	abstract-machine/libs/imgui/include/imgui_internal.h	/^    int                     TreeDepth;$/;"	m	struct:ImGuiDrawContext	access:public
TreeNode	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNode(const char* label);                                            \/\/ if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().$/;"	p	namespace:ImGui	signature:(const char* label)
TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const char* label)$/;"	f	class:ImGui	signature:(const char* label)
TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, ...)
TreeNode	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, ...)
TreeNodeBehavior	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL)
TreeNodeBehavior	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
TreeNodeBehaviorIsOpen	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     \/\/ Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging$/;"	p	namespace:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags = 0)
TreeNodeBehaviorIsOpen	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(ImGuiID id, ImGuiTreeNodeFlags flags)
TreeNodeEx	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);$/;"	p	namespace:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags = 0)
TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui	signature:(const char* label, ImGuiTreeNodeFlags flags)
TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
TreeNodeEx	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
TreeNodeExV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
TreeNodeExV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args);$/;"	p	namespace:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
TreeNodeExV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
TreeNodeExV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
TreeNodeV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args);           \/\/ "$/;"	p	namespace:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
TreeNodeV	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args);           \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
TreeNodeV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const char* str_id, const char* fmt, va_list args)
TreeNodeV	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui	signature:(const void* ptr_id, const char* fmt, va_list args)
TreePop	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePop();                                                              \/\/ ~ Unindent()+PopId()$/;"	p	namespace:ImGui	signature:()
TreePop	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui	signature:()
TreePush	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePush(const char* str_id = NULL);                                    \/\/ ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push\/Pop yourself for layout purpose$/;"	p	namespace:ImGui	signature:(const char* str_id = NULL)
TreePush	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          TreePush(const void* ptr_id = NULL);                                    \/\/ "$/;"	p	namespace:ImGui	signature:(const void* ptr_id = NULL)
TreePush	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui	signature:(const char* str_id)
TreePush	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui	signature:(const void* ptr_id)
TreePushRawID	abstract-machine/libs/imgui/include/imgui_internal.h	/^    IMGUI_API void          TreePushRawID(ImGuiID id);$/;"	p	namespace:ImGui	signature:(ImGuiID id)
TreePushRawID	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::TreePushRawID(ImGuiID id)$/;"	f	class:ImGui	signature:(ImGuiID id)
Type	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiMouseCursor    Type;$/;"	m	struct:ImGuiMouseCursorData	access:public
Type	abstract-machine/libs/imgui/src/imgui.cpp	/^    ImGuiDataType   Type;$/;"	m	struct:ImGuiStyleVarInfo	file:	access:public
U0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
U1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
UNCOMPRESSED_END	abstract-machine/apps/microbench/src/lzip/quicklz.c	20;"	d	file:
UNCONDITIONAL_MATCHLEN	abstract-machine/apps/microbench/src/lzip/quicklz.c	19;"	d	file:
UNUSED	abstract-machine/libs/compiler-rt/int_lib.h	50;"	d
UNUSED	abstract-machine/libs/compiler-rt/int_lib.h	55;"	d
UPDATE_PER_SECOND	abstract-machine/apps/typing/game.h	7;"	d
USEL	abstract-machine/am/include/x86.h	52;"	d
USE_CLOCK	abstract-machine/apps/coremark/include/core_portme.h	35;"	d
USE_FORK	abstract-machine/apps/coremark/include/core_portme.h	133;"	d
USE_PTHREAD	abstract-machine/apps/coremark/include/core_portme.h	132;"	d
USE_SOCKET	abstract-machine/apps/coremark/include/core_portme.h	134;"	d
Unindent	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Unindent(float indent_w = 0.0f);                                    \/\/ move content position back to the left, by style.IndentSpacing or indent_w if >0$/;"	p	namespace:ImGui	signature:(float indent_w = 0.0f)
Unindent	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Unindent(float indent_w)$/;"	f	class:ImGui	signature:(float indent_w)
Updatable_heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^class Updatable_heap {$/;"	c
Updatable_heap::Step	abstract-machine/apps/microbench/src/15pz/heap.h	/^    class Step;$/;"	x
Updatable_heap::Step	abstract-machine/apps/microbench/src/15pz/heap.h	/^class Updatable_heap<T, M>::Step {$/;"	c	class:Updatable_heap
Updatable_heap::Step::element	abstract-machine/apps/microbench/src/15pz/heap.h	/^    T element;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::heap_index	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int heap_index;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::init	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void init( T const &, Step *, int, int );$/;"	p	class:Updatable_heap::Step	access:public	signature:( T const &, Step *, int, int )
Updatable_heap::Step::init	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::Step::init( T const &pz, Step *n, int hi, int dist ) {$/;"	f	class:Updatable_heap::Step	signature:( T const &pz, Step *n, int hi, int dist )
Updatable_heap::Step::length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int length() const;$/;"	p	class:Updatable_heap::Step	access:public	signature:() const
Updatable_heap::Step::length	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::Step::length() const {$/;"	f	class:Updatable_heap::Step	signature:() const
Updatable_heap::Step::next	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *next;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::path_length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int path_length;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::path_weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int path_weight;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::previous_step	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *previous_step;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::visited	abstract-machine/apps/microbench/src/15pz/heap.h	/^    bool visited;$/;"	m	class:Updatable_heap::Step	access:public
Updatable_heap::Step::weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int weight() const;$/;"	p	class:Updatable_heap::Step	access:public	signature:() const
Updatable_heap::Step::weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::Step::weight() const {$/;"	f	class:Updatable_heap::Step	signature:() const
Updatable_heap::hash_table	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *hash_table[M];$/;"	m	class:Updatable_heap	access:private
Updatable_heap::heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *heap[M + 1];$/;"	m	class:Updatable_heap	access:private
Updatable_heap::heap_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int heap_size;$/;"	m	class:Updatable_heap	access:private
Updatable_heap::init	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void init(); $/;"	p	class:Updatable_heap	access:public	signature:()
Updatable_heap::init	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::init() {$/;"	f	class:Updatable_heap	signature:()
Updatable_heap::length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int length( T const & ) const;$/;"	p	class:Updatable_heap	access:public	signature:( T const & ) const
Updatable_heap::length	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::length( T const &pz ) const {$/;"	f	class:Updatable_heap	signature:( T const &pz ) const
Updatable_heap::maximum_heap_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int maximum_heap_size;$/;"	m	class:Updatable_heap	access:private
Updatable_heap::maximum_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int maximum_size() const;$/;"	p	class:Updatable_heap	access:public	signature:() const
Updatable_heap::maximum_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::maximum_size() const {$/;"	f	class:Updatable_heap	signature:() const
Updatable_heap::percolate_down	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void percolate_down();$/;"	p	class:Updatable_heap	access:private	signature:()
Updatable_heap::percolate_down	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::percolate_down() {$/;"	f	class:Updatable_heap	signature:()
Updatable_heap::percolate_up	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void percolate_up( int );$/;"	p	class:Updatable_heap	access:private	signature:( int )
Updatable_heap::percolate_up	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::percolate_up( int n ) {$/;"	f	class:Updatable_heap	signature:( int n )
Updatable_heap::pointer	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *pointer( T const & ) const;$/;"	p	class:Updatable_heap	access:private	signature:( T const & ) const
Updatable_heap::pointer	abstract-machine/apps/microbench/src/15pz/heap.h	/^typename Updatable_heap<T, M>::Step *Updatable_heap<T, M>::pointer( T const &pz ) const {$/;"	f	class:Updatable_heap	signature:( T const &pz ) const
Updatable_heap::pop	abstract-machine/apps/microbench/src/15pz/heap.h	/^    T pop();$/;"	p	class:Updatable_heap	access:public	signature:()
Updatable_heap::pop	abstract-machine/apps/microbench/src/15pz/heap.h	/^T Updatable_heap<T, M>::pop() {$/;"	f	class:Updatable_heap	signature:()
Updatable_heap::push	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void push( T const &, int );$/;"	p	class:Updatable_heap	access:public	signature:( T const &, int )
Updatable_heap::push	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::push( T const &pz, int path_length ) {$/;"	f	class:Updatable_heap	signature:( T const &pz, int path_length )
Updatable_heap::size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int size() const;$/;"	p	class:Updatable_heap	access:public	signature:() const
Updatable_heap::size	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::size() const {$/;"	f	class:Updatable_heap	signature:() const
Updatable_heap::swap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void inline swap( int, int );$/;"	p	class:Updatable_heap	access:private	signature:( int, int )
Updatable_heap::swap	abstract-machine/apps/microbench/src/15pz/heap.h	/^void inline Updatable_heap<T, M>::swap( int i, int j ) {$/;"	f	class:Updatable_heap	signature:( int i, int j )
Updatable_heap::~Updatable_heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    ~Updatable_heap();$/;"	p	class:Updatable_heap	access:public	signature:()
Updatable_heap::~Updatable_heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^Updatable_heap<T, M>::~Updatable_heap() {$/;"	f	class:Updatable_heap	signature:()
Update	abstract-machine/libs/imgui/include/imgui_internal.h	/^    void        Update(int count, float spacing, bool clear);$/;"	p	struct:ImGuiSimpleColumns	access:public	signature:(int count, float spacing, bool clear)
Update	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiSimpleColumns::Update(int count, float spacing, bool clear)$/;"	f	class:ImGuiSimpleColumns	signature:(int count, float spacing, bool clear)
UpdateClipRect	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  UpdateClipRect();$/;"	p	struct:ImDrawList	access:public	signature:()
UpdateClipRect	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList	signature:()
UpdateTextureID	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void  UpdateTextureID();$/;"	p	struct:ImDrawList	access:public	signature:()
UpdateTextureID	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList	signature:()
UserCallback	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd	access:public
UserCallbackData	abstract-machine/libs/imgui/include/imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd	access:public
UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiTextEditCallbackData	access:public
UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*         UserData;                 \/\/ = NULL               \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO	access:public
UserData	abstract-machine/libs/imgui/include/imgui.h	/^    void*   UserData;       \/\/ Read-only.   What user passed to SetNextWindowSizeConstraints()$/;"	m	struct:ImGuiSizeConstraintCallbackData	access:public
User_Time	abstract-machine/apps/dhrystone/dry.c	/^                User_Time;$/;"	v
V0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
V1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFont::Glyph	access:public
VALIDATION_RUN	abstract-machine/apps/coremark/include/core_portme.h	181;"	d
VBEInfo	abstract-machine/am/src/x86/qemu/devices/video.c	/^struct VBEInfo {$/;"	s	file:
VBEInfo	abstract-machine/am/src/x86/qemu/devices/video.c	/^typedef struct VBEInfo VBEInfo;$/;"	t	typeref:struct:VBEInfo	file:
VBEInfo::attributes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t attributes;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::bank_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t bank_size;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::banks	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t banks;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::blue_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t blue_mask;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::blue_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t blue_position;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::bpp	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t bpp;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::direct_color_attributes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t direct_color_attributes;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::framebuffer	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t framebuffer;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::granularity	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t granularity;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::green_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t green_mask;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::green_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t green_position;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::height	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t height;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::image_pages	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t image_pages;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::memory_model	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t memory_model;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::off_screen_mem_off	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t off_screen_mem_off;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::off_screen_mem_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t off_screen_mem_size;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::pitch	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t pitch;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::planes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t planes;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::red_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t red_mask;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::red_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t red_position;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::reserved0	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved0;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::reserved1	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved1[206];$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::reserved_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved_mask;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::reserved_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved_position;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::segment_a	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t segment_a;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::segment_b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t segment_b;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::w_char	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t w_char;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::width	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t width;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::win_func_ptr	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t win_func_ptr;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::window_a	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t window_a;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::window_b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t window_b;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::window_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t window_size;$/;"	m	struct:VBEInfo	file:	access:public
VBEInfo::y_char	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t y_char;$/;"	m	struct:VBEInfo	file:	access:public
VER	abstract-machine/am/src/x86/qemu/devices/apic.c	11;"	d	file:
VME_TRACE_FUNCS	abstract-machine/am/src/x86/qemu/trace.c	120;"	d	file:
VSliderFloat	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = , float power = 1.0f)
VSliderFloat	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
VSliderInt	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");$/;"	p	namespace:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = )
VSliderInt	abstract-machine/libs/imgui/src/imgui.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)$/;"	f	class:ImGui	signature:(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
Valid	abstract-machine/libs/imgui/include/imgui.h	/^    bool            Valid;                  \/\/ Only valid after Render() is called and before the next NewFrame() is called.$/;"	m	struct:ImDrawData	access:public
Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, bool b);$/;"	p	namespace:ImGui	signature:(const char* prefix, bool b)
Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);$/;"	p	namespace:ImGui	signature:(const char* prefix, float v, const char* float_format = NULL)
Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, int v)
Value	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          Value(const char* prefix, unsigned int v);$/;"	p	namespace:ImGui	signature:(const char* prefix, unsigned int v)
Value	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor	access:public
Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui	signature:(const char* prefix, bool b)
Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui	signature:(const char* prefix, float v, const char* float_format)
Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui	signature:(const char* prefix, int v)
Value	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui	signature:(const char* prefix, unsigned int v)
ValueColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ValueColor(const char* prefix, ImU32 v);$/;"	p	namespace:ImGui	signature:(const char* prefix, ImU32 v)
ValueColor	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void          ValueColor(const char* prefix, const ImVec4& v);$/;"	p	namespace:ImGui	signature:(const char* prefix, const ImVec4& v)
ValueColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ValueColor(const char* prefix, ImU32 v)$/;"	f	class:ImGui	signature:(const char* prefix, ImU32 v)
ValueColor	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGui::ValueColor(const char* prefix, const ImVec4& v)$/;"	f	class:ImGui	signature:(const char* prefix, const ImVec4& v)
Values	abstract-machine/libs/imgui/src/imgui.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:	access:public
VarIdx	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiStyleVar   VarIdx;$/;"	m	struct:ImGuiStyleMod	access:public
Version	abstract-machine/apps/dhrystone/dry.c	2;"	d	file:
VtxBuffer	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList	access:public
W	abstract-machine/am/src/native/devices/video.c	5;"	d	file:
W	abstract-machine/am/src/x86/qemu/devices/video.c	/^static int W, H;$/;"	v	file:
W	abstract-machine/apps/litenes/include/fce.h	8;"	d
W	abstract-machine/apps/typing/game.h	10;"	d
WIN32_LEAN_AND_MEAN	abstract-machine/libs/imgui/src/imgui.cpp	9437;"	d	file:
WIN32_LEAN_AND_MEAN	abstract-machine/libs/imgui/src/imgui.cpp	9438;"	d	file:
WantCaptureKeyboard	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantCaptureKeyboard;        \/\/ Widget is active (= ImGui will use your keyboard input). Use to hide keyboard from the rest of your application$/;"	m	struct:ImGuiIO	access:public
WantCaptureMouse	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantCaptureMouse;           \/\/ Mouse is hovering a window or widget is active (= ImGui will use your mouse input). Use to hide mouse from the rest of your application$/;"	m	struct:ImGuiIO	access:public
WantTextInput	abstract-machine/libs/imgui/include/imgui.h	/^    bool        WantTextInput;              \/\/ Some text input widget is active, which will read input characters from the InputCharacters array. Use to activate on screen keyboard if your system needs one$/;"	m	struct:ImGuiIO	access:public
WasActive	abstract-machine/libs/imgui/include/imgui_internal.h	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow	access:public
Width	abstract-machine/libs/imgui/include/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiSimpleColumns	access:public
Window	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImGuiWindow*    Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupRef	access:public
WindowMinSize	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size$/;"	m	struct:ImGuiStyle	access:public
WindowPadding	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window$/;"	m	struct:ImGuiStyle	access:public
WindowPadding	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin. We need to lock it, in particular manipulation of the ShowBorder would have an effect$/;"	m	struct:ImGuiWindow	access:public
WindowRectClipped	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImRect                  WindowRectClipped;                  \/\/ = WindowRect just after setup in Begin(). == window->Rect() for root window.$/;"	m	struct:ImGuiWindow	access:public
WindowRounding	abstract-machine/libs/imgui/include/imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows$/;"	m	struct:ImGuiStyle	access:public
WindowTitleAlign	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2      WindowTitleAlign;           \/\/ Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.$/;"	m	struct:ImGuiStyle	access:public
Windows	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  Windows;$/;"	m	struct:ImGuiContext	access:public
WindowsSortBuffer	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiContext	access:public
X	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
X0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
X1	abstract-machine/am/src/x86/qemu/devices/apic.c	29;"	d	file:
X1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
X4_CORRECTION_COMPONENT	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t X4_CORRECTION_COMPONENT = 0x399A; 	\/*!< Fix16 value of 0.225 *\/$/;"	v
XAdvance	abstract-machine/libs/imgui/include/imgui.h	/^        float                   XAdvance;$/;"	m	struct:ImFont::Glyph	access:public
XHL	abstract-machine/apps/litenes/src/ppu.c	/^static byte XHL[8][256][256];$/;"	v	file:
XHL64	abstract-machine/apps/litenes/src/ppu.c	/^static uint64_t XHL64[256][256];$/;"	v	file:
XHLmask	abstract-machine/apps/litenes/src/ppu.c	/^static uint64_t XHLmask[256][256];$/;"	v	file:
XX	abstract-machine/am/src/native/devices/input.c	12;"	d	file:
Y	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
Y0	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
Y1	abstract-machine/libs/imgui/include/imgui.h	/^        float                   X0, Y0, X1, Y1;$/;"	m	struct:ImFont::Glyph	access:public
_AM_DEVREG	abstract-machine/am/amdev.h	19;"	d
_AddressSpace	abstract-machine/am/am.h	/^typedef struct _AddressSpace {$/;"	s
_AddressSpace	abstract-machine/am/am.h	/^} _AddressSpace;$/;"	t	typeref:struct:_AddressSpace
_AddressSpace::area	abstract-machine/am/am.h	/^  _Area area;$/;"	m	struct:_AddressSpace	access:public
_AddressSpace::pgsize	abstract-machine/am/am.h	/^  size_t pgsize;$/;"	m	struct:_AddressSpace	access:public
_AddressSpace::ptr	abstract-machine/am/am.h	/^  void *ptr;$/;"	m	struct:_AddressSpace	access:public
_Area	abstract-machine/am/am.h	/^typedef struct _Area {$/;"	s
_Area	abstract-machine/am/am.h	/^} _Area; $/;"	t	typeref:struct:_Area
_Area::end	abstract-machine/am/am.h	/^  void *start, *end;$/;"	m	struct:_Area	access:public
_Area::start	abstract-machine/am/am.h	/^  void *start, *end;$/;"	m	struct:_Area	access:public
_CRT_SECURE_NO_WARNINGS	abstract-machine/libs/imgui/src/imgui.cpp	616;"	d	file:
_CRT_SECURE_NO_WARNINGS	abstract-machine/libs/imgui/src/imgui_demo.cpp	11;"	d	file:
_CRT_SECURE_NO_WARNINGS	abstract-machine/libs/imgui/src/imgui_draw.cpp	12;"	d	file:
_CallArgs	abstract-machine/am/amtrace.h	/^typedef struct _CallArgs {$/;"	s
_CallArgs	abstract-machine/am/amtrace.h	/^} _CallArgs;$/;"	t	typeref:struct:_CallArgs
_CallArgs::a0	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
_CallArgs::a1	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
_CallArgs::a2	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
_CallArgs::a3	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
_CallPayload	abstract-machine/am/amtrace.h	/^} _CallPayload;$/;"	t	typeref:union:_Payload
_Channels	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImDrawChannel> _Channels;          \/\/ [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)$/;"	m	struct:ImDrawList	access:public
_ChannelsCount	abstract-machine/libs/imgui/include/imgui.h	/^    int                     _ChannelsCount;     \/\/ [Internal] number of active channels (1+)$/;"	m	struct:ImDrawList	access:public
_ChannelsCurrent	abstract-machine/libs/imgui/include/imgui.h	/^    int                     _ChannelsCurrent;   \/\/ [Internal] current channel number (0)$/;"	m	struct:ImDrawList	access:public
_ClipRectStack	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
_Context	abstract-machine/am/am.h	/^typedef struct _Context _Context;$/;"	t	typeref:struct:_Context
_Context	abstract-machine/am/include/arch/native.h	/^struct _Context {$/;"	s
_Context	abstract-machine/am/include/arch/x86-qemu.h	/^struct _Context {$/;"	s
_Context::__anon63::__anon64::prot	abstract-machine/am/include/arch/native.h	/^      void *prot;$/;"	m	struct:_Context::__anon63::__anon64	access:public
_Context::__anon63::__anon64::uc	abstract-machine/am/include/arch/native.h	/^      ucontext_t uc;$/;"	m	struct:_Context::__anon63::__anon64	access:public
_Context::__anon63::pad	abstract-machine/am/include/arch/native.h	/^    uint8_t pad[1024];$/;"	m	union:_Context::__anon63	access:public
_Context::cs	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
_Context::ds	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
_Context::eax	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
_Context::ebp	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
_Context::ebx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
_Context::ecx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
_Context::edi	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
_Context::edx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
_Context::eflags	abstract-machine/am/include/arch/x86-qemu.h	/^           eip, eflags,$/;"	m	struct:_Context	access:public
_Context::eip	abstract-machine/am/include/arch/x86-qemu.h	/^           eip, eflags,$/;"	m	struct:_Context	access:public
_Context::es	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
_Context::esi	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
_Context::esp0	abstract-machine/am/include/arch/x86-qemu.h	/^           ss0, esp0;$/;"	m	struct:_Context	access:public
_Context::esp3	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
_Context::prot	abstract-machine/am/include/arch/x86-qemu.h	/^  struct _AddressSpace *prot;$/;"	m	struct:_Context	typeref:struct:_Context::_AddressSpace	access:public
_Context::rax	abstract-machine/am/include/arch/native.h	/^  uintptr_t rax;$/;"	m	struct:_Context	access:public
_Context::rdi	abstract-machine/am/include/arch/native.h	/^  uintptr_t rdi;$/;"	m	struct:_Context	access:public
_Context::rip	abstract-machine/am/include/arch/native.h	/^  uintptr_t rip;$/;"	m	struct:_Context	access:public
_Context::ss	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
_Context::ss0	abstract-machine/am/include/arch/x86-qemu.h	/^           ss0, esp0;$/;"	m	struct:_Context	access:public
_DEVREG_PCICONF	abstract-machine/am/amdev.h	35;"	d
_DEV_INPUT	abstract-machine/am/amdev.h	13;"	d
_DEV_PCICONF	abstract-machine/am/amdev.h	17;"	d
_DEV_PERFCNT	abstract-machine/am/amdev.h	12;"	d
_DEV_SERIAL	abstract-machine/am/amdev.h	16;"	d
_DEV_TIMER	abstract-machine/am/amdev.h	14;"	d
_DEV_VIDEO	abstract-machine/am/amdev.h	15;"	d
_EVENT_ERROR	abstract-machine/am/am.h	/^  _EVENT_ERROR,$/;"	e	enum:__anon60
_EVENT_IRQ_IODEV	abstract-machine/am/am.h	/^  _EVENT_IRQ_IODEV,$/;"	e	enum:__anon60
_EVENT_IRQ_TIMER	abstract-machine/am/am.h	/^  _EVENT_IRQ_TIMER,$/;"	e	enum:__anon60
_EVENT_NULL	abstract-machine/am/am.h	/^  _EVENT_NULL = 0,$/;"	e	enum:__anon60
_EVENT_PAGEFAULT	abstract-machine/am/am.h	/^  _EVENT_PAGEFAULT,$/;"	e	enum:__anon60
_EVENT_SYSCALL	abstract-machine/am/am.h	/^  _EVENT_SYSCALL,$/;"	e	enum:__anon60
_EVENT_YIELD	abstract-machine/am/am.h	/^  _EVENT_YIELD,$/;"	e	enum:__anon60
_Event	abstract-machine/am/am.h	/^typedef struct _Event {$/;"	s
_Event	abstract-machine/am/am.h	/^} _Event;$/;"	t	typeref:struct:_Event
_Event::cause	abstract-machine/am/am.h	/^  uintptr_t cause, ref;$/;"	m	struct:_Event	access:public
_Event::event	abstract-machine/am/am.h	/^  int event;$/;"	m	struct:_Event	access:public
_Event::msg	abstract-machine/am/am.h	/^  const char *msg;$/;"	m	struct:_Event	access:public
_Event::ref	abstract-machine/am/am.h	/^  uintptr_t cause, ref;$/;"	m	struct:_Event	access:public
_FOUR_DIV_PI2	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t _FOUR_DIV_PI2 = 0xFFFF9840;        \/*!< Fix16 value of -4\/PI *\/$/;"	v
_IdxWritePtr	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
_Init	abstract-machine/am/src/native/platform.cpp	/^  public : _Init() {$/;"	f	class:_Init	access:public	signature:()
_Init	abstract-machine/am/src/native/platform.cpp	/^class _Init {$/;"	c	file:
_Init::_Init	abstract-machine/am/src/native/platform.cpp	/^  public : _Init() {$/;"	f	class:_Init	access:public	signature:()
_Init::~_Init	abstract-machine/am/src/native/platform.cpp	/^  public : ~_Init() {$/;"	f	class:_Init	access:public	signature:()
_KEYS	abstract-machine/am/amdev.h	/^  _KEYS(_KEY_NAME)$/;"	e	enum:__anon62
_KEYS	abstract-machine/am/amdev.h	41;"	d
_KEY_NAME	abstract-machine/am/amdev.h	55;"	d
_KEY_NONE	abstract-machine/am/amdev.h	/^  _KEY_NONE = 0,$/;"	e	enum:__anon62
_OwnerName	abstract-machine/libs/imgui/include/imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name for debugging$/;"	m	struct:ImDrawList	access:public
_PROT_EXEC	abstract-machine/am/am.h	/^  _PROT_EXEC  = 8, \/\/ can execute$/;"	e	enum:__anon61
_PROT_NONE	abstract-machine/am/am.h	/^  _PROT_NONE  = 1, \/\/ no access$/;"	e	enum:__anon61
_PROT_READ	abstract-machine/am/am.h	/^  _PROT_READ  = 2, \/\/ can read$/;"	e	enum:__anon61
_PROT_WRITE	abstract-machine/am/am.h	/^  _PROT_WRITE = 4, \/\/ can write$/;"	e	enum:__anon61
_Path	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImVec2>        _Path;              \/\/ [Internal] current path building$/;"	m	struct:ImDrawList	access:public
_Payload	abstract-machine/am/amtrace.h	/^typedef union _Payload {$/;"	u
_Payload::args	abstract-machine/am/amtrace.h	/^  _CallArgs args;$/;"	m	union:_Payload	access:public
_Payload::retval	abstract-machine/am/amtrace.h	/^  uintptr_t retval;$/;"	m	union:_Payload	access:public
_TRACE_ALL	abstract-machine/am/amtrace.h	40;"	d
_TRACE_CALL	abstract-machine/am/amtrace.h	36;"	d
_TRACE_CTE	abstract-machine/am/amtrace.h	31;"	d
_TRACE_FUNC	abstract-machine/am/amtrace.h	38;"	d
_TRACE_IOE	abstract-machine/am/amtrace.h	30;"	d
_TRACE_RET	abstract-machine/am/amtrace.h	37;"	d
_TRACE_VME	abstract-machine/am/amtrace.h	32;"	d
_TextureIdStack	abstract-machine/libs/imgui/include/imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal]$/;"	m	struct:ImDrawList	access:public
_TraceEvent	abstract-machine/am/amtrace.h	/^struct _TraceEvent {$/;"	s
_TraceEvent	abstract-machine/am/amtrace.h	/^typedef struct _TraceEvent _TraceEvent;$/;"	t	typeref:struct:_TraceEvent
_TraceEvent::cpu	abstract-machine/am/amtrace.h	/^  uint16_t cpu;   \/\/ cpu id (0 based)$/;"	m	struct:_TraceEvent	access:public
_TraceEvent::payload	abstract-machine/am/amtrace.h	/^  char payload[]; \/\/ _Payload: CALL -> .args$/;"	m	struct:_TraceEvent	access:public
_TraceEvent::ref	abstract-machine/am/amtrace.h	/^  uintptr_t ref;  \/\/ a pointer$/;"	m	struct:_TraceEvent	access:public
_TraceEvent::time	abstract-machine/am/amtrace.h	/^  uint32_t time;  \/\/ time stamp$/;"	m	struct:_TraceEvent	access:public
_TraceEvent::type	abstract-machine/am/amtrace.h	/^  uint16_t type;  \/\/ _TRACE_ ## { CALL | RET }$/;"	m	struct:_TraceEvent	access:public
_VtxCurrentIdx	abstract-machine/libs/imgui/include/imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] == VtxBuffer.Size$/;"	m	struct:ImDrawList	access:public
_VtxWritePtr	abstract-machine/libs/imgui/include/imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList	access:public
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	104;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	25;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	28;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	38;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	41;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	56;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	59;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	69;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	72;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	86;"	d
_YUGA_BIG_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	93;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	103;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	24;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	27;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	37;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	40;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	55;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	58;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	68;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	71;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	85;"	d
_YUGA_LITTLE_ENDIAN	abstract-machine/libs/compiler-rt/int_endianness.h	92;"	d
__AMDEV_H__	abstract-machine/am/amdev.h	2;"	d
__AMTRACE_H__	abstract-machine/am/amtrace.h	2;"	d
__AM_H__	abstract-machine/am/am.h	7;"	d
__AM_X86_H__	abstract-machine/am/src/x86/x86-qemu.h	2;"	d
__ARCH_H__	abstract-machine/am/include/arch/native.h	2;"	d
__ARCH_H__	abstract-machine/am/include/arch/x86-qemu.h	2;"	d
__BENCHMARK_H__	abstract-machine/apps/microbench/include/benchmark.h	2;"	d
__KLIB_H__	abstract-machine/libs/klib/include/klib.h	6;"	d
__STB_INCLUDE_STB_TRUETYPE_H__	abstract-machine/libs/imgui/include/stb_truetype.h	440;"	d
__STR	abstract-machine/am/am.h	10;"	d
__USE_GNU	abstract-machine/am/include/arch/native.h	34;"	d
__USE_GNU	abstract-machine/am/include/arch/native.h	5;"	d
__X86_H__	abstract-machine/am/include/x86.h	2;"	d
__XSTR	abstract-machine/am/am.h	9;"	d
____FE____	abstract-machine/apps/litenes/src/cpu.c	/^void ____FE____() { \/* Instruction for future Extension *\/ }$/;"	f
__anon10::hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		qlz_hash_decompress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon10	access:public
__anon10::stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon10	access:public
__anon10::stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		size_t stream_counter;$/;"	m	struct:__anon10	access:public
__anon16::__anon17::high	abstract-machine/libs/compiler-rt/int_types.h	/^        si_int high;$/;"	m	struct:__anon16::__anon17	access:public
__anon16::__anon17::low	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int low;$/;"	m	struct:__anon16::__anon17	access:public
__anon16::all	abstract-machine/libs/compiler-rt/int_types.h	/^    di_int all;$/;"	m	union:__anon16	access:public
__anon16::s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon16	typeref:struct:__anon16::__anon17	access:public
__anon18::__anon19::high	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int high;$/;"	m	struct:__anon18::__anon19	access:public
__anon18::__anon19::low	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int low;$/;"	m	struct:__anon18::__anon19	access:public
__anon18::all	abstract-machine/libs/compiler-rt/int_types.h	/^    du_int all;$/;"	m	union:__anon18	access:public
__anon18::s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon18	typeref:struct:__anon18::__anon19	access:public
__anon1::chr_block_count	abstract-machine/apps/litenes/src/fce.c	/^    byte chr_block_count;$/;"	m	struct:__anon1	file:	access:public
__anon1::prg_block_count	abstract-machine/apps/litenes/src/fce.c	/^    byte prg_block_count;$/;"	m	struct:__anon1	file:	access:public
__anon1::reserved	abstract-machine/apps/litenes/src/fce.c	/^    byte reserved[8];$/;"	m	struct:__anon1	file:	access:public
__anon1::rom_type	abstract-machine/apps/litenes/src/fce.c	/^    word rom_type;$/;"	m	struct:__anon1	file:	access:public
__anon1::signature	abstract-machine/apps/litenes/src/fce.c	/^    char signature[4];$/;"	m	struct:__anon1	file:	access:public
__anon20::__anon21::high	abstract-machine/libs/compiler-rt/int_types.h	/^        di_int high;$/;"	m	struct:__anon20::__anon21	access:public
__anon20::__anon21::low	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int low;$/;"	m	struct:__anon20::__anon21	access:public
__anon20::all	abstract-machine/libs/compiler-rt/int_types.h	/^    ti_int all;$/;"	m	union:__anon20	access:public
__anon20::s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon20	typeref:struct:__anon20::__anon21	access:public
__anon22::__anon23::high	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int high;$/;"	m	struct:__anon22::__anon23	access:public
__anon22::__anon23::low	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int low;$/;"	m	struct:__anon22::__anon23	access:public
__anon22::all	abstract-machine/libs/compiler-rt/int_types.h	/^    tu_int all;$/;"	m	union:__anon22	access:public
__anon22::s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon22	typeref:struct:__anon22::__anon23	access:public
__anon24::f	abstract-machine/libs/compiler-rt/int_types.h	/^    float f;$/;"	m	union:__anon24	access:public
__anon24::u	abstract-machine/libs/compiler-rt/int_types.h	/^    su_int u;$/;"	m	union:__anon24	access:public
__anon25::f	abstract-machine/libs/compiler-rt/int_types.h	/^    double  f;$/;"	m	union:__anon25	access:public
__anon25::u	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords u;$/;"	m	union:__anon25	access:public
__anon26::high	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords high;$/;"	m	struct:__anon26	access:public
__anon26::low	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords low;$/;"	m	struct:__anon26	access:public
__anon27::f	abstract-machine/libs/compiler-rt/int_types.h	/^    long double f;$/;"	m	union:__anon27	access:public
__anon27::u	abstract-machine/libs/compiler-rt/int_types.h	/^    uqwords     u;$/;"	m	union:__anon27	access:public
__anon28::imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { float real, imaginary; } Fcomplex;$/;"	m	struct:__anon28	access:public
__anon28::real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { float real, imaginary; } Fcomplex;$/;"	m	struct:__anon28	access:public
__anon29::imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { double real, imaginary; } Dcomplex;$/;"	m	struct:__anon29	access:public
__anon29::real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { double real, imaginary; } Dcomplex;$/;"	m	struct:__anon29	access:public
__anon2::OAMADDR	abstract-machine/apps/litenes/include/ppu.h	/^    byte OAMADDR;   \/\/ $2003 write only$/;"	m	struct:__anon2	access:public
__anon2::OAMDATA	abstract-machine/apps/litenes/include/ppu.h	/^    byte OAMDATA;   \/\/ $2004$/;"	m	struct:__anon2	access:public
__anon2::PPUADDR	abstract-machine/apps/litenes/include/ppu.h	/^    word PPUADDR;   \/\/ $2006 write only x2$/;"	m	struct:__anon2	access:public
__anon2::PPUCTRL	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUCTRL;   \/\/ $2000 write only$/;"	m	struct:__anon2	access:public
__anon2::PPUDATA	abstract-machine/apps/litenes/include/ppu.h	/^    word PPUDATA;   \/\/ $2007$/;"	m	struct:__anon2	access:public
__anon2::PPUMASK	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUMASK;   \/\/ $2001 write only$/;"	m	struct:__anon2	access:public
__anon2::PPUSCROLL	abstract-machine/apps/litenes/include/ppu.h	/^	word PPUSCROLL;$/;"	m	struct:__anon2	access:public
__anon2::PPUSCROLL_X	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSCROLL_X, PPUSCROLL_Y; \/\/ $2005 write only x2$/;"	m	struct:__anon2	access:public
__anon2::PPUSCROLL_Y	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSCROLL_X, PPUSCROLL_Y; \/\/ $2005 write only x2$/;"	m	struct:__anon2	access:public
__anon2::PPUSTATUS	abstract-machine/apps/litenes/include/ppu.h	/^    byte PPUSTATUS; \/\/ $2002 read only$/;"	m	struct:__anon2	access:public
__anon2::addr_received_high_byte	abstract-machine/apps/litenes/include/ppu.h	/^    bool addr_received_high_byte;$/;"	m	struct:__anon2	access:public
__anon2::mirroring	abstract-machine/apps/litenes/include/ppu.h	/^    int mirroring, mirroring_xor;$/;"	m	struct:__anon2	access:public
__anon2::mirroring_xor	abstract-machine/apps/litenes/include/ppu.h	/^    int mirroring, mirroring_xor;$/;"	m	struct:__anon2	access:public
__anon2::ready	abstract-machine/apps/litenes/include/ppu.h	/^    bool ready;$/;"	m	struct:__anon2	access:public
__anon2::scanline	abstract-machine/apps/litenes/include/ppu.h	/^    int x, scanline;$/;"	m	struct:__anon2	access:public
__anon2::scroll_received_x	abstract-machine/apps/litenes/include/ppu.h	/^    bool scroll_received_x;$/;"	m	struct:__anon2	access:public
__anon2::x	abstract-machine/apps/litenes/include/ppu.h	/^    int x, scanline;$/;"	m	struct:__anon2	access:public
__anon30::imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { long double real, imaginary; } Lcomplex;$/;"	m	struct:__anon30	access:public
__anon30::real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { long double real, imaginary; } Lcomplex;$/;"	m	struct:__anon30	access:public
__anon31::hi	abstract-machine/libs/fixmath/include/int64.h	/^	 int32_t hi;$/;"	m	struct:__anon31	access:public
__anon31::lo	abstract-machine/libs/fixmath/include/int64.h	/^	uint32_t lo;$/;"	m	struct:__anon31	access:public
__anon32::char_storage	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           char_storage;$/;"	m	struct:__anon32	access:public
__anon32::delete_length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           delete_length;$/;"	m	struct:__anon32	access:public
__anon32::insert_length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           insert_length;$/;"	m	struct:__anon32	access:public
__anon32::where	abstract-machine/libs/imgui/include/stb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon32	access:public
__anon33::redo_char_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon33	access:public
__anon33::redo_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon33	access:public
__anon33::undo_char	abstract-machine/libs/imgui/include/stb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon33	access:public
__anon33::undo_char_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon33	access:public
__anon33::undo_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon33	access:public
__anon33::undo_rec	abstract-machine/libs/imgui/include/stb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon33	access:public
__anon34::cursor	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int cursor;$/;"	m	struct:__anon34	access:public
__anon34::cursor_at_end_of_line	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon34	access:public
__anon34::has_preferred_x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon34	access:public
__anon34::initialized	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon34	access:public
__anon34::insert_mode	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon34	access:public
__anon34::padding1	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
__anon34::padding2	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
__anon34::padding3	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
__anon34::preferred_x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon34	access:public
__anon34::select_end	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int select_end;$/;"	m	struct:__anon34	access:public
__anon34::select_start	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon34	access:public
__anon34::single_line	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon34	access:public
__anon34::undostate	abstract-machine/libs/imgui/include/stb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon34	access:public
__anon35::baseline_y_delta	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon35	access:public
__anon35::num_chars	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon35	access:public
__anon35::x0	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon35	access:public
__anon35::x1	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon35	access:public
__anon35::ymax	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon35	access:public
__anon35::ymin	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon35	access:public
__anon36::first_char	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon36	access:public
__anon36::height	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon36	access:public
__anon36::length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon36	access:public
__anon36::prev_first	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon36	access:public
__anon36::x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon36	access:public
__anon36::y	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon36	access:public
__anon39::prev_link	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon39	access:public
__anon39::x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon39	access:public
__anon39::y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon39	access:public
__anon41::cursor	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int cursor;$/;"	m	struct:__anon41	access:public
__anon41::data	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *data;$/;"	m	struct:__anon41	access:public
__anon41::size	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int size;$/;"	m	struct:__anon41	access:public
__anon42::x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
__anon42::x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
__anon42::xadvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
__anon42::xoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
__anon42::y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
__anon42::y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
__anon42::yoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
__anon43::s0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
__anon43::s1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
__anon43::t0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
__anon43::t1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
__anon43::x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
__anon43::x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
__anon43::y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
__anon43::y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
__anon44::x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
__anon44::x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
__anon44::xadvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
__anon44::xoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
__anon44::xoff2	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon44	access:public
__anon44::y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
__anon44::y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
__anon44::yoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
__anon44::yoff2	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon44	access:public
__anon45::array_of_unicode_codepoints	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon45	access:public
__anon45::chardata_for_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon45	access:public
__anon45::first_unicode_codepoint_in_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon45	access:public
__anon45::font_size	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float font_size;$/;"	m	struct:__anon45	access:public
__anon45::h_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon45	access:public
__anon45::num_chars	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon45	access:public
__anon45::v_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon45	access:public
__anon47::cx	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon47::cx1	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon47::cy	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon47::cy1	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon47::padding	abstract-machine/libs/imgui/include/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon47	access:public
__anon47::type	abstract-machine/libs/imgui/include/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon47	access:public
__anon47::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon47::y	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
__anon48::h	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
__anon48::pixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon48	access:public
__anon48::stride	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
__anon48::w	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
__anon55::bounds	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int bounds;$/;"	m	struct:__anon55	access:public
__anon55::first_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon55	access:public
__anon55::first_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon55	access:public
__anon55::max_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
__anon55::max_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
__anon55::min_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
__anon55::min_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
__anon55::num_vertices	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int num_vertices;$/;"	m	struct:__anon55	access:public
__anon55::pvertices	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_vertex *pvertices;$/;"	m	struct:__anon55	access:public
__anon55::started	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int started;$/;"	m	struct:__anon55	access:public
__anon55::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x, y;$/;"	m	struct:__anon55	access:public
__anon55::y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x, y;$/;"	m	struct:__anon55	access:public
__anon56::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon56	access:public
__anon56::y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon56	access:public
__anon57::bottom_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
__anon57::height	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon57	access:public
__anon57::width	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon57	access:public
__anon57::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
__anon57::y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
__anon58::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon58	access:public
__anon5::A	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
__anon5::P	abstract-machine/apps/litenes/include/cpu.h	/^    byte P; \/\/ Flag Register$/;"	m	struct:__anon5	access:public
__anon5::PC	abstract-machine/apps/litenes/include/cpu.h	/^    word PC; \/\/ Program Counter,$/;"	m	struct:__anon5	access:public
__anon5::SP	abstract-machine/apps/litenes/include/cpu.h	/^    byte SP; \/\/ Stack Pointer,$/;"	m	struct:__anon5	access:public
__anon5::X	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
__anon5::Y	abstract-machine/apps/litenes/include/cpu.h	/^    byte A, X, Y; \/\/ Registers$/;"	m	struct:__anon5	access:public
__anon6::cache	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	ui32 cache;$/;"	m	struct:__anon6	access:public
__anon6::offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	const unsigned char *offset;$/;"	m	struct:__anon6	access:public
__anon6::offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	unsigned int offset;$/;"	m	struct:__anon6	access:public
__anon7::offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	const unsigned char *offset;$/;"	m	struct:__anon7	access:public
__anon8::hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	qlz_hash_compress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon8	access:public
__anon8::hash_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	unsigned char hash_counter[QLZ_HASH_VALUES];$/;"	m	struct:__anon8	access:public
__anon8::stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon8	access:public
__anon8::stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	size_t stream_counter;$/;"	m	struct:__anon8	access:public
__anon9::hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		qlz_hash_decompress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon9	access:public
__anon9::hash_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char hash_counter[QLZ_HASH_VALUES];$/;"	m	struct:__anon9	access:public
__anon9::stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon9	access:public
__anon9::stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		size_t stream_counter;$/;"	m	struct:__anon9	access:public
__builtin_clz	abstract-machine/libs/compiler-rt/int_lib.h	/^uint32_t __inline __builtin_clz(uint32_t value) {$/;"	f	signature:(uint32_t value)
__builtin_clzl	abstract-machine/libs/compiler-rt/int_lib.h	131;"	d
__builtin_clzll	abstract-machine/libs/compiler-rt/int_lib.h	/^uint32_t __inline __builtin_clzll(uint64_t value) {$/;"	f	signature:(uint64_t value)
__builtin_ctz	abstract-machine/libs/compiler-rt/int_lib.h	/^uint32_t __inline __builtin_ctz(uint32_t value) {$/;"	f	signature:(uint32_t value)
__cb_alloc	abstract-machine/am/src/x86/qemu/vme.c	/^void *__cb_alloc(size_t size);$/;"	p	file:	signature:(size_t size)
__cb_free	abstract-machine/am/src/x86/qemu/vme.c	/^void __cb_free(void *ptr);$/;"	p	file:	signature:(void *ptr)
__cb_irq	abstract-machine/am/src/x86/qemu/cte.c	/^_Context *__cb_irq(_Event ev, _Context *ctx);$/;"	p	file:	signature:(_Event ev, _Context *ctx)
__clzti2	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI si_int __clzti2(ti_int a);$/;"	p	signature:(ti_int a)
__cxa_atexit	abstract-machine/libs/klib/src/cpp.c	/^void __cxa_atexit() {$/;"	f
__cxa_guard_acquire	abstract-machine/libs/klib/src/cpp.c	/^void __cxa_guard_acquire() {$/;"	f
__cxa_guard_release	abstract-machine/libs/klib/src/cpp.c	/^void __cxa_guard_release() {$/;"	f
__divdi3	abstract-machine/libs/compiler-rt/divdi3.c	/^__divdi3(di_int a, di_int b)$/;"	f	signature:(di_int a, di_int b)
__divdi3	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI di_int __divdi3(di_int a, di_int b);$/;"	p	signature:(di_int a, di_int b)
__divmoddi4	abstract-machine/libs/compiler-rt/divmoddi4.c	/^__divmoddi4(di_int a, di_int b, di_int* rem)$/;"	f	signature:(di_int a, di_int b, di_int* rem)
__divsi3	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI si_int __divsi3(si_int a, si_int b);$/;"	p	signature:(si_int a, si_int b)
__dso_handle	abstract-machine/libs/klib/src/cpp.c	/^void __dso_handle() {$/;"	f
__fix16_trig_sin_lut_h__	abstract-machine/libs/fixmath/include/fix16_trig_sin_lut.h	2;"	d
__int64_t	abstract-machine/libs/fixmath/include/int64.h	/^} __int64_t;$/;"	t	typeref:struct:__anon31
__libfixmath_fix16_h__	abstract-machine/libs/fixmath/include/fix16.h	2;"	d
__libfixmath_fix16_hpp__	abstract-machine/libs/fixmath/include/fix16.hpp	2;"	d
__libfixmath_fixmath_h__	abstract-machine/libs/fixmath/include/fixmath.h	2;"	d
__libfixmath_fract32_h__	abstract-machine/libs/fixmath/include/fract32.h	2;"	d
__libfixmath_int64_h__	abstract-machine/libs/fixmath/include/int64.h	2;"	d
__libfixmath_uint32_h__	abstract-machine/libs/fixmath/include/uint32.h	2;"	d
__moddi3	abstract-machine/libs/compiler-rt/moddi3.c	/^__moddi3(di_int a, di_int b)$/;"	f	signature:(di_int a, di_int b)
__paritydi2	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI si_int __paritydi2(di_int a);$/;"	p	signature:(di_int a)
__paritysi2	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI si_int __paritysi2(si_int a);$/;"	p	signature:(si_int a)
__udivdi3	abstract-machine/libs/compiler-rt/udivdi3.c	/^__udivdi3(du_int a, du_int b)$/;"	f	signature:(du_int a, du_int b)
__udivmoddi4	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI du_int __udivmoddi4(du_int a, du_int b, du_int* rem);$/;"	p	signature:(du_int a, du_int b, du_int* rem)
__udivmoddi4	abstract-machine/libs/compiler-rt/udivmoddi4.c	/^__udivmoddi4(du_int a, du_int b, du_int* rem)$/;"	f	signature:(du_int a, du_int b, du_int* rem)
__udivmodsi4	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI su_int __udivmodsi4(su_int a, su_int b, su_int* rem);$/;"	p	signature:(su_int a, su_int b, su_int* rem)
__udivmodti4	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI tu_int __udivmodti4(tu_int a, tu_int b, tu_int* rem);$/;"	p	signature:(tu_int a, tu_int b, tu_int* rem)
__udivsi3	abstract-machine/libs/compiler-rt/int_lib.h	/^COMPILER_RT_ABI su_int __udivsi3(su_int n, su_int d);$/;"	p	signature:(su_int n, su_int d)
__umoddi3	abstract-machine/libs/compiler-rt/umoddi3.c	/^__umoddi3(du_int a, du_int b)$/;"	f	signature:(du_int a, du_int b)
_atomic_xchg	abstract-machine/am/am.h	/^intptr_t _atomic_xchg(volatile intptr_t *addr, intptr_t newval);$/;"	p	signature:(volatile intptr_t *addr, intptr_t newval)
_atomic_xchg	abstract-machine/am/src/native/mpe.c	/^intptr_t _atomic_xchg(volatile intptr_t *addr, intptr_t newval) {$/;"	f	signature:(volatile intptr_t *addr, intptr_t newval)
_atomic_xchg	abstract-machine/am/src/x86/qemu/mpe.c	/^intptr_t _atomic_xchg(volatile intptr_t *addr, intptr_t newval) {$/;"	f	signature:(volatile intptr_t *addr, intptr_t newval)
_cb_alloc	abstract-machine/am/src/x86/qemu/vme.c	/^void *_cb_alloc(size_t size) { return pgalloc_usr(PGSIZE); }$/;"	f	signature:(size_t size)
_cb_free	abstract-machine/am/src/x86/qemu/vme.c	/^void _cb_free(void *ptr) { pgfree_usr(ptr); }$/;"	f	signature:(void *ptr)
_cb_irq	abstract-machine/am/src/x86/qemu/cte.c	/^_Context *_cb_irq(_Event ev, _Context *ctx) {$/;"	f	signature:(_Event ev, _Context *ctx)
_cpu	abstract-machine/am/am.h	/^int _cpu();$/;"	p	signature:()
_cpu	abstract-machine/am/src/native/mpe.c	/^int _cpu() {$/;"	f
_cpu	abstract-machine/am/src/x86/qemu/mpe.c	/^int _cpu(void) {$/;"	f	signature:(void)
_fix16_atan_cache_index	abstract-machine/libs/fixmath/src/fix16_trig.c	/^static fix16_t _fix16_atan_cache_index[2][4096] = { { 0 }, { 0 } };$/;"	v	file:
_fix16_atan_cache_value	abstract-machine/libs/fixmath/src/fix16_trig.c	/^static fix16_t _fix16_atan_cache_value[4096] = { 0 };$/;"	v	file:
_fix16_exp_cache_index	abstract-machine/libs/fixmath/src/fix16_exp.c	/^static fix16_t _fix16_exp_cache_index[4096]  = { 0 };$/;"	v	file:
_fix16_exp_cache_value	abstract-machine/libs/fixmath/src/fix16_exp.c	/^static fix16_t _fix16_exp_cache_value[4096]  = { 0 };$/;"	v	file:
_fix16_sin_cache_index	abstract-machine/libs/fixmath/src/fix16_trig.c	/^static fix16_t _fix16_sin_cache_index[4096]  = { 0 };$/;"	v	file:
_fix16_sin_cache_value	abstract-machine/libs/fixmath/src/fix16_trig.c	/^static fix16_t _fix16_sin_cache_value[4096]  = { 0 };$/;"	v	file:
_fix16_sin_lut	abstract-machine/libs/fixmath/include/fix16_trig_sin_lut.h	/^static uint16_t _fix16_sin_lut[102688] = {$/;"	v
_fix16_sin_lut_count	abstract-machine/libs/fixmath/include/fix16_trig_sin_lut.h	/^static const uint32_t _fix16_sin_lut_count = 102688;$/;"	v
_grow_capacity	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  _grow_capacity(int new_size)    { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > new_size ? new_capacity : new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
_halt	abstract-machine/am/am.h	/^void _halt(int code) __attribute__((__noreturn__));$/;"	p	signature:(int code)
_halt	abstract-machine/am/src/native/trm.c	/^void _halt(int code) {$/;"	f	signature:(int code)
_halt	abstract-machine/am/src/x86/qemu/trm.c	/^void _halt(int code) {$/;"	f	signature:(int code)
_heap	abstract-machine/am/am.h	/^extern _Area _heap;$/;"	x
_heap	abstract-machine/am/src/native/trm.c	/^_Area _heap;$/;"	v
_heap	abstract-machine/am/src/x86/qemu/trm.c	/^_Area _heap; \/\/ the heap memory defined in AM spec$/;"	v
_init_platform	abstract-machine/am/src/native/platform.cpp	/^static _Init _init_platform;$/;"	v	file:
_intr_read	abstract-machine/am/am.h	/^int _intr_read();$/;"	p	signature:()
_intr_read	abstract-machine/am/src/native/cte.c	/^int _intr_read() {$/;"	f
_intr_write	abstract-machine/am/am.h	/^void _intr_write(int enable);$/;"	p	signature:(int enable)
_intr_write	abstract-machine/am/src/native/cte.c	/^void _intr_write(int enable) {$/;"	f	signature:(int enable)
_io_read	abstract-machine/am/am.h	/^size_t _io_read(uint32_t dev, uintptr_t reg, void *buf, size_t size);$/;"	p	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_io_read	abstract-machine/am/src/native/ioe.c	/^size_t _io_read(uint32_t dev, uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_io_read	abstract-machine/am/src/x86/qemu/ioe.c	/^size_t _io_read(uint32_t dev, uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_io_write	abstract-machine/am/am.h	/^size_t _io_write(uint32_t dev, uintptr_t reg, void *buf, size_t size);$/;"	p	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_io_write	abstract-machine/am/src/native/ioe.c	/^size_t _io_write(uint32_t dev, uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_io_write	abstract-machine/am/src/x86/qemu/ioe.c	/^size_t _io_write(uint32_t dev, uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uint32_t dev, uintptr_t reg, void *buf, size_t size)
_ioe_init	abstract-machine/am/am.h	/^int _ioe_init();$/;"	p	signature:()
_ioe_init	abstract-machine/am/src/native/ioe.c	/^int _ioe_init() {$/;"	f
_ioe_init	abstract-machine/am/src/x86/qemu/ioe.c	/^int _ioe_init() {$/;"	f
_kcontext	abstract-machine/am/am.h	/^_Context *_kcontext(_Area kstack, void (*entry)(void *), void *arg);$/;"	p	signature:(_Area kstack, void (*entry)(void *), void *arg)
_kcontext	abstract-machine/am/src/native/cte.c	/^_Context *_kcontext(_Area stack, void (*entry)(void *), void *arg) {$/;"	f	signature:(_Area stack, void (*entry)(void *), void *arg)
_map	abstract-machine/am/am.h	/^int _map(_AddressSpace *as, void *va, void *pa, int prot);$/;"	p	signature:(_AddressSpace *as, void *va, void *pa, int prot)
_map	abstract-machine/am/src/native/vme.c	/^int _map(_AddressSpace *p, void *va, void *pa, int prot) {$/;"	f	signature:(_AddressSpace *p, void *va, void *pa, int prot)
_mpe_init	abstract-machine/am/am.h	/^int _mpe_init(void (*entry)());$/;"	p	signature:(void (*entry)())
_mpe_init	abstract-machine/am/src/native/mpe.c	/^int _mpe_init(void (*entry)()) {$/;"	f	signature:(void (*entry)())
_mpe_init	abstract-machine/am/src/x86/qemu/mpe.c	/^int _mpe_init(void (*entry)()) {$/;"	f	signature:(void (*entry)())
_ncpu	abstract-machine/am/am.h	/^int _ncpu();$/;"	p	signature:()
_ncpu	abstract-machine/am/src/native/mpe.c	/^int _ncpu() {$/;"	f
_ncpu	abstract-machine/am/src/x86/qemu/mpe.c	/^int _ncpu() {$/;"	f
_protect	abstract-machine/am/am.h	/^int _protect(_AddressSpace *as);$/;"	p	signature:(_AddressSpace *as)
_protect	abstract-machine/am/src/native/vme.c	/^int _protect(_AddressSpace *p) {$/;"	f	signature:(_AddressSpace *p)
_putc	abstract-machine/am/am.h	/^void _putc(char ch);$/;"	p	signature:(char ch)
_putc	abstract-machine/am/src/native/trm.c	/^void _putc(char ch) {$/;"	f	signature:(char ch)
_putc	abstract-machine/am/src/x86/qemu/trm.c	/^void _putc(char ch) { \/\/ only works for x86-qemu$/;"	f	signature:(char ch)
_start	abstract-machine/am/src/x86/qemu/boot/start.S	/^_start:$/;"	l
_start	abstract-machine/am/src/x86/qemu/trm.c	/^void _start() { \/\/ the bootloader jumps here$/;"	f
_switch	abstract-machine/am/src/native/cte.c	/^extern void _switch(_Context *c);$/;"	p	file:	signature:(_Context *c)
_switch	abstract-machine/am/src/native/vme.c	/^void _switch(_Context *c) {$/;"	f	signature:(_Context *c)
_trace_off	abstract-machine/am/amtrace.h	/^void _trace_off(uint32_t flags);$/;"	p	signature:(uint32_t flags)
_trace_off	abstract-machine/am/src/x86/qemu/trace.c	/^void _trace_off(uint32_t flags) {$/;"	f	signature:(uint32_t flags)
_trace_on	abstract-machine/am/amtrace.h	/^void _trace_on(uint32_t flags);$/;"	p	signature:(uint32_t flags)
_trace_on	abstract-machine/am/src/x86/qemu/trace.c	/^void _trace_on(uint32_t flags) {$/;"	f	signature:(uint32_t flags)
_trm_init	abstract-machine/am/src/native/trm.c	/^void _trm_init() {$/;"	f
_ucontext	abstract-machine/am/am.h	/^_Context *_ucontext(_AddressSpace *as, _Area ustack, _Area kstack,$/;"	p	signature:(_AddressSpace *as, _Area ustack, _Area kstack, void *entry, void *args)
_ucontext	abstract-machine/am/src/native/vme.c	/^_Context *_ucontext(_AddressSpace *p, _Area ustack, _Area kstack, void *entry, void *args) {$/;"	f	signature:(_AddressSpace *p, _Area ustack, _Area kstack, void *entry, void *args)
_unprotect	abstract-machine/am/am.h	/^void _unprotect(_AddressSpace *as);$/;"	p	signature:(_AddressSpace *as)
_unprotect	abstract-machine/am/src/native/vme.c	/^void _unprotect(_AddressSpace *p) {$/;"	f	signature:(_AddressSpace *p)
_vme_init	abstract-machine/am/am.h	/^int _vme_init(void *(*pgalloc)(size_t size), void (*pgfree)(void *));$/;"	p	signature:(void *(*pgalloc)(size_t size), void (*pgfree)(void *))
_vme_init	abstract-machine/am/src/native/vme.c	/^int _vme_init(void* (*pgalloc_f)(size_t), void (*pgfree_f)(void*)) {$/;"	f	signature:(void* (*pgalloc_f)(size_t), void (*pgfree_f)(void*))
_yield	abstract-machine/am/am.h	/^void _yield();$/;"	p	signature:()
_yield	abstract-machine/am/src/native/cte.c	/^void _yield() {$/;"	f
a0	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
a1	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
a2	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
a3	abstract-machine/am/amtrace.h	/^  uintptr_t a0, a1, a2, a3;$/;"	m	struct:_CallArgs	access:public
abs	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    static int abs( int n ) { return ( n < 0 ) ? -n : n; }$/;"	f	class:N_puzzle	access:private	signature:( int n )
acos	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 acos() { return Fix16(fix16_acos(value)); }$/;"	f	class:Fix16	access:public	signature:()
active_head	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context	access:public
addr_received_high_byte	abstract-machine/apps/litenes/include/ppu.h	/^    bool addr_received_high_byte;$/;"	m	struct:__anon2	access:public
align	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t align;$/;"	m	struct:ProgramHeader	file:	access:public
align	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int align;$/;"	m	struct:stbrp_context	access:public
align_mem	abstract-machine/apps/coremark/include/core_portme.h	89;"	d
all	abstract-machine/libs/compiler-rt/int_types.h	/^    di_int all;$/;"	m	union:__anon16	access:public
all	abstract-machine/libs/compiler-rt/int_types.h	/^    du_int all;$/;"	m	union:__anon18	access:public
all	abstract-machine/libs/compiler-rt/int_types.h	/^    ti_int all;$/;"	m	union:__anon20	access:public
all	abstract-machine/libs/compiler-rt/int_types.h	/^    tu_int all;$/;"	m	union:__anon22	access:public
ans	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^int ans;$/;"	v
ans	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^static int ans;$/;"	v	file:
ans	abstract-machine/apps/microbench/src/fib/fib.c	/^static uint32_t *A, *ans, *T, *tmp;$/;"	v	file:
ans	abstract-machine/apps/microbench/src/queen/queen.c	/^static unsigned int ans;$/;"	v	file:
ans	abstract-machine/apps/microbench/src/sieve/sieve.c	/^static int ans;$/;"	v	file:
ap_entry	abstract-machine/am/src/x86/qemu/mpe.c	/^static void ap_entry() {$/;"	f	file:
ap_entry	abstract-machine/am/src/x86/qemu/mpe.c	/^static void ap_entry();$/;"	p	file:
apboot_done	abstract-machine/am/src/x86/qemu/mpe.c	/^static volatile intptr_t apboot_done = 0;$/;"	v	file:
append	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextBuffer::append(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, ...)
appendv	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API void      appendv(const char* fmt, va_list args);$/;"	p	struct:ImGuiTextBuffer	access:public	signature:(const char* fmt, va_list args)
appendv	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextBuffer::appendv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer	signature:(const char* fmt, va_list args)
area	abstract-machine/am/am.h	/^  _Area area;$/;"	m	struct:_AddressSpace	access:public
area	abstract-machine/am/src/x86/qemu/vme.c	/^  _Area area;$/;"	m	struct:vm_area	file:	access:public
areas	abstract-machine/am/src/x86/qemu/vme.c	/^static const struct vm_area areas[] = {$/;"	v	typeref:struct:vm_area	file:
args	abstract-machine/am/amtrace.h	/^  _CallArgs args;$/;"	m	union:_Payload	access:public
args	abstract-machine/am/include/x86.h	/^  uint32_t args : 5;        \/\/ # args, 0 for interrupt\/trap gates$/;"	m	struct:GateDesc	access:public
array_of_unicode_codepoints	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon45	access:public
asin	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 asin() { return Fix16(fix16_asin(value)); }$/;"	f	class:Fix16	access:public	signature:()
asm	abstract-machine/am/include/x86.h	204;"	d
asm_trap	abstract-machine/am/src/native/cte.c	/^extern void asm_trap();$/;"	p	file:
asm_trap	abstract-machine/am/src/native/trap.S	/^asm_trap:$/;"	l
assert	abstract-machine/libs/klib/include/klib.h	66;"	d
assert	abstract-machine/libs/klib/include/klib.h	68;"	d
assign	abstract-machine/apps/microbench/src/fib/fib.c	/^static inline void assign(uint32_t *a, uint32_t *b) {$/;"	f	file:	signature:(uint32_t *a, uint32_t *b)
atan	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 atan() { return Fix16(fix16_atan(value)); }$/;"	f	class:Fix16	access:public	signature:()
atan2	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 atan2(const Fix16 &inY) { return Fix16(fix16_atan2(value, inY.value)); }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &inY)
attributes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t attributes;$/;"	m	struct:VBEInfo	file:	access:public
avl	abstract-machine/am/include/x86.h	/^  uint32_t avl : 1;        \/\/ Unused (available for software use)$/;"	m	struct:SegDesc	access:public
b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
b	abstract-machine/libs/imgui/include/imgui.h	/^        const char* b;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
back	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    back() const                    { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:() const
back	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          back()                          { IM_ASSERT(Size > 0); return Data[Size-1]; }$/;"	f	class:ImVector	access:public	signature:()
bank_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t bank_size;$/;"	m	struct:VBEInfo	file:	access:public
banks	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t banks;$/;"	m	struct:VBEInfo	file:	access:public
base_15_0	abstract-machine/am/include/x86.h	/^  uint32_t base_15_0 : 16; \/\/ Low bits of segment base address$/;"	m	struct:SegDesc	access:public
base_23_16	abstract-machine/am/include/x86.h	/^  uint32_t base_23_16 : 8; \/\/ Middle bits of segment base address$/;"	m	struct:SegDesc	access:public
base_31_24	abstract-machine/am/include/x86.h	/^  uint32_t base_31_24 : 8; \/\/ High bits of segment base address$/;"	m	struct:SegDesc	access:public
baseline_y_delta	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon35	access:public
begin	abstract-machine/libs/imgui/include/imgui.h	/^        const char* begin() const { return b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
begin	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         begin() const { return &Buf.front(); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
begin	abstract-machine/libs/imgui/include/imgui.h	/^    inline const_iterator       begin() const                   { return Data; }$/;"	f	class:ImVector	access:public	signature:() const
begin	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             begin()                         { return Data; }$/;"	f	class:ImVector	access:public	signature:()
bench_15pz_prepare	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^void bench_15pz_prepare() {$/;"	f	signature:()
bench_15pz_run	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^void bench_15pz_run() {$/;"	f	signature:()
bench_15pz_validate	abstract-machine/apps/microbench/src/15pz/15pz.cpp	/^int bench_15pz_validate() {$/;"	f	signature:()
bench_alloc	abstract-machine/apps/microbench/include/benchmark.h	/^void* bench_alloc(size_t size);$/;"	p	signature:(size_t size)
bench_alloc	abstract-machine/apps/microbench/src/bench.c	/^void* bench_alloc(size_t size) {$/;"	f	signature:(size_t size)
bench_bf_prepare	abstract-machine/apps/microbench/src/bf/bf.c	/^void bench_bf_prepare() {$/;"	f
bench_bf_run	abstract-machine/apps/microbench/src/bf/bf.c	/^void bench_bf_run() {$/;"	f
bench_bf_validate	abstract-machine/apps/microbench/src/bf/bf.c	/^int bench_bf_validate() {$/;"	f
bench_check	abstract-machine/apps/microbench/src/bench.c	/^static const char *bench_check(Benchmark *bench) {$/;"	f	file:	signature:(Benchmark *bench)
bench_dinic_prepare	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^void bench_dinic_prepare() {$/;"	f	signature:()
bench_dinic_run	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^void bench_dinic_run() {$/;"	f	signature:()
bench_dinic_validate	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^int bench_dinic_validate() {$/;"	f	signature:()
bench_done	abstract-machine/apps/microbench/src/bench.c	/^static void bench_done(Result *res) {$/;"	f	file:	signature:(Result *res)
bench_fib_prepare	abstract-machine/apps/microbench/src/fib/fib.c	/^void bench_fib_prepare() {$/;"	f
bench_fib_run	abstract-machine/apps/microbench/src/fib/fib.c	/^void bench_fib_run() {$/;"	f
bench_fib_validate	abstract-machine/apps/microbench/src/fib/fib.c	/^int bench_fib_validate() {$/;"	f
bench_free	abstract-machine/apps/microbench/include/benchmark.h	/^void bench_free(void *ptr);$/;"	p	signature:(void *ptr)
bench_free	abstract-machine/apps/microbench/src/bench.c	/^void bench_free(void *ptr) {$/;"	f	signature:(void *ptr)
bench_lzip_prepare	abstract-machine/apps/microbench/src/lzip/lzip.c	/^void bench_lzip_prepare() {$/;"	f
bench_lzip_run	abstract-machine/apps/microbench/src/lzip/lzip.c	/^void bench_lzip_run() {$/;"	f
bench_lzip_validate	abstract-machine/apps/microbench/src/lzip/lzip.c	/^int bench_lzip_validate() {$/;"	f
bench_md5_prepare	abstract-machine/apps/microbench/src/md5/md5.c	/^void bench_md5_prepare() {$/;"	f
bench_md5_run	abstract-machine/apps/microbench/src/md5/md5.c	/^void bench_md5_run() {$/;"	f
bench_md5_validate	abstract-machine/apps/microbench/src/md5/md5.c	/^int bench_md5_validate() {$/;"	f
bench_memcpy	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^static inline void* bench_memcpy(void* dst, const void* src, size_t n){$/;"	f	signature:(void* dst, const void* src, size_t n)
bench_prepare	abstract-machine/apps/microbench/src/bench.c	/^static void bench_prepare(Result *res) {$/;"	f	file:	signature:(Result *res)
bench_qsort_prepare	abstract-machine/apps/microbench/src/qsort/qsort.c	/^void bench_qsort_prepare() {$/;"	f
bench_qsort_run	abstract-machine/apps/microbench/src/qsort/qsort.c	/^void bench_qsort_run() {$/;"	f
bench_qsort_validate	abstract-machine/apps/microbench/src/qsort/qsort.c	/^int bench_qsort_validate() {$/;"	f
bench_queen_prepare	abstract-machine/apps/microbench/src/queen/queen.c	/^void bench_queen_prepare() {$/;"	f
bench_queen_run	abstract-machine/apps/microbench/src/queen/queen.c	/^void bench_queen_run() {$/;"	f
bench_queen_validate	abstract-machine/apps/microbench/src/queen/queen.c	/^int bench_queen_validate() {$/;"	f
bench_rand	abstract-machine/apps/microbench/include/benchmark.h	/^uint32_t bench_rand(); \/\/ return a random number between 0..32767$/;"	p	signature:()
bench_rand	abstract-machine/apps/microbench/src/bench.c	/^uint32_t bench_rand() {$/;"	f
bench_reset	abstract-machine/apps/microbench/src/bench.c	/^static void bench_reset() {$/;"	f	file:
bench_sieve_prepare	abstract-machine/apps/microbench/src/sieve/sieve.c	/^void bench_sieve_prepare() {$/;"	f
bench_sieve_run	abstract-machine/apps/microbench/src/sieve/sieve.c	/^void bench_sieve_run() {$/;"	f
bench_sieve_validate	abstract-machine/apps/microbench/src/sieve/sieve.c	/^int bench_sieve_validate() {$/;"	f
bench_srand	abstract-machine/apps/microbench/include/benchmark.h	/^void bench_srand(uint32_t seed);$/;"	p	signature:(uint32_t seed)
bench_srand	abstract-machine/apps/microbench/src/bench.c	/^void bench_srand(uint32_t _seed) {$/;"	f	signature:(uint32_t _seed)
bench_ssort_prepare	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^void bench_ssort_prepare() {$/;"	f	signature:()
bench_ssort_run	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^void bench_ssort_run() {$/;"	f	signature:()
bench_ssort_validate	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^int bench_ssort_validate() {$/;"	f	signature:()
benchmarks	abstract-machine/apps/microbench/src/bench.c	/^Benchmark benchmarks[] = {$/;"	v
bit_extract	abstract-machine/apps/coremark/src/core_matrix.c	47;"	d	file:
blk	abstract-machine/apps/microbench/src/lzip/lzip.c	/^static char *blk;$/;"	v	file:
blue_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t blue_mask;$/;"	m	struct:VBEInfo	file:	access:public
blue_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t blue_position;$/;"	m	struct:VBEInfo	file:	access:public
bool	abstract-machine/apps/litenes/include/common.h	/^typedef int bool;$/;"	t
bool	abstract-machine/apps/typing/game.h	/^typedef char bool;$/;"	t
boot_date	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static _DEV_TIMER_DATE_t boot_date;$/;"	v	file:
boot_info	abstract-machine/am/src/x86/qemu/boot/main.c	/^struct boot_info {$/;"	s	file:
boot_info	abstract-machine/am/src/x86/x86-qemu.h	/^struct boot_info {$/;"	s
boot_info::entry	abstract-machine/am/src/x86/qemu/boot/main.c	/^  void (*entry)();$/;"	m	struct:boot_info	file:	access:public
boot_info::entry	abstract-machine/am/src/x86/x86-qemu.h	/^  void (*entry)();$/;"	m	struct:boot_info	access:public
boot_info::is_ap	abstract-machine/am/src/x86/qemu/boot/main.c	/^  int is_ap;$/;"	m	struct:boot_info	file:	access:public
boot_info::is_ap	abstract-machine/am/src/x86/x86-qemu.h	/^  int is_ap;$/;"	m	struct:boot_info	access:public
boot_time	abstract-machine/am/src/native/devices/timer.c	/^static struct timeval boot_time;$/;"	v	typeref:struct:timeval	file:
bootcpu_init	abstract-machine/am/src/x86/qemu/devices/cpu.c	/^void bootcpu_init() {$/;"	f
bootcpu_init	abstract-machine/am/src/x86/x86-qemu.h	/^void bootcpu_init();$/;"	p	signature:()
bootmain	abstract-machine/am/src/x86/qemu/boot/main.c	/^bootmain(void) {$/;"	f	signature:(void)
bootrec	abstract-machine/am/src/x86/qemu/mpe.c	/^volatile struct boot_info *bootrec = (void *)0x7000;$/;"	v	typeref:struct:boot_info
bootrec	abstract-machine/am/src/x86/x86-qemu.h	/^extern volatile struct boot_info *bootrec;$/;"	x
bottom_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
bounds	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int bounds;$/;"	m	struct:__anon55	access:public
bpp	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t bpp;$/;"	m	struct:VBEInfo	file:	access:public
break_bp	abstract-machine/apps/litenes/include/cpu.h	/^    break_bp      = 4,$/;"	e	enum:__anon4
break_flag	abstract-machine/apps/litenes/include/cpu.h	/^    break_flag     = 0x10,$/;"	e	enum:__anon3
buf	abstract-machine/apps/litenes/src/fce.c	/^static byte *buf;$/;"	v	file:
byte	abstract-machine/apps/litenes/include/common.h	/^typedef uint8_t byte;$/;"	t
c_str	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         c_str() const { return Buf.Data; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
cache	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	ui32 cache;$/;"	m	struct:__anon6	access:public
calc_func	abstract-machine/apps/coremark/src/core_list_join.c	/^ee_s16 calc_func(ee_s16 *pdata, core_results *res) {$/;"	f	signature:(ee_s16 *pdata, core_results *res)
canvas	abstract-machine/apps/litenes/include/fce.h	/^extern byte canvas[257][520];$/;"	x
canvas	abstract-machine/apps/litenes/src/fce.c	/^byte canvas[257][520];$/;"	v
canvas	abstract-machine/apps/typing/draw.c	/^static uint32_t canvas[H][W];$/;"	v	file:
cap	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
capacity	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  capacity() const                { return Capacity; }$/;"	f	class:ImVector	access:public	signature:() const
carry_bp	abstract-machine/apps/litenes/include/cpu.h	/^    carry_bp      = 0,$/;"	e	enum:__anon4
carry_flag	abstract-machine/apps/litenes/include/cpu.h	/^    carry_flag     = 0x01,$/;"	e	enum:__anon3
cause	abstract-machine/am/am.h	/^  uintptr_t cause, ref;$/;"	m	struct:_Event	access:public
cdata	abstract-machine/libs/imgui/include/stb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
cff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf cff;                    \/\/ cff font data$/;"	m	struct:stbtt_fontinfo	access:public
char_storage	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           char_storage;$/;"	m	struct:__anon32	access:public
characters	abstract-machine/apps/typing/game.c	/^fly_t characters(){$/;"	f
characters	abstract-machine/apps/typing/game.h	/^fly_t characters(void);$/;"	p	signature:(void)
chardata_for_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon45	access:public
charstrings	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf charstrings;            \/\/ the charstring index$/;"	m	struct:stbtt_fontinfo	access:public
check	abstract-machine/apps/dhrystone/dry.c	/^Boolean check(int cond) {$/;"	f	signature:(int cond)
check_data_types	abstract-machine/apps/coremark/include/coremark.h	/^ee_u8 check_data_types();$/;"	p	signature:()
check_data_types	abstract-machine/apps/coremark/src/core_util.c	/^ee_u8 check_data_types() {$/;"	f
checksum	abstract-machine/am/include/x86.h	/^  uint8_t  checksum;        \/\/ all bytes must add up to 0$/;"	m	struct:MPConf	access:public
checksum	abstract-machine/am/include/x86.h	/^  uint8_t checksum; \/\/ all bytes add to 0$/;"	m	struct:MPDesc	access:public
checksum	abstract-machine/apps/microbench/include/benchmark.h	/^  uint32_t checksum;$/;"	m	struct:Setting	access:public
checksum	abstract-machine/apps/microbench/include/benchmark.h	/^uint32_t checksum(void *start, void *end);$/;"	p	signature:(void *start, void *end)
checksum	abstract-machine/apps/microbench/src/bench.c	/^uint32_t checksum(void *start, void *end) {$/;"	f	signature:(void *start, void *end)
chr_block_count	abstract-machine/apps/litenes/src/fce.c	/^    byte chr_block_count;$/;"	m	struct:__anon1	file:	access:public
clear	abstract-machine/apps/microbench/src/sieve/sieve.c	/^static inline void clear(int n) {$/;"	f	file:	signature:(int n)
clear	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 clear()                         { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }$/;"	f	class:ImVector	access:public	signature:()
clear	abstract-machine/libs/imgui/include/imgui.h	/^    void                clear() { Buf.clear(); Buf.push_back(0); }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
cli	abstract-machine/am/include/x86.h	/^static inline void cli() {$/;"	f	signature:()
clz	abstract-machine/libs/fixmath/src/fix16.c	/^static uint8_t clz(uint32_t x)$/;"	f	file:	signature:(uint32_t x)
clz	abstract-machine/libs/fixmath/src/fix16.c	278;"	d	file:
cmp1	pstree/pstree.c	/^int cmp1(const void *a, const void *b )$/;"	f	signature:(const void *a, const void *b )
cmp2	pstree/pstree.c	/^int cmp2(const void *a, const void *b )$/;"	f	signature:(const void *a, const void *b )
cmp_complex	abstract-machine/apps/coremark/src/core_list_join.c	/^ee_s32 cmp_complex(list_data *a, list_data *b, core_results *res) {$/;"	f	signature:(list_data *a, list_data *b, core_results *res)
cmp_idx	abstract-machine/apps/coremark/src/core_list_join.c	/^ee_s32 cmp_idx(list_data *a, list_data *b, core_results *res) {$/;"	f	signature:(list_data *a, list_data *b, core_results *res)
cnt	pstree/pstree.c	/^int cnt = 0;$/;"	v
code	abstract-machine/apps/microbench/src/bf/bf.c	/^static const char *code;$/;"	v	file:
col	abstract-machine/libs/imgui/include/imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert	access:public
common_bit_set	abstract-machine/apps/litenes/include/common.h	/^static inline bool common_bit_set(unsigned long value, byte position) { return value & (1L << position); }$/;"	f	signature:(unsigned long value, byte position)
common_h	abstract-machine/apps/typing/game.h	2;"	d
common_modify_bitb	abstract-machine/apps/litenes/include/common.h	/^void common_modify_bitb(byte *variable, byte position, bool set);$/;"	p	signature:(byte *variable, byte position, bool set)
common_modify_bitd	abstract-machine/apps/litenes/include/common.h	/^void common_modify_bitd(dword *variable, byte position, bool set);$/;"	p	signature:(dword *variable, byte position, bool set)
common_modify_bitw	abstract-machine/apps/litenes/include/common.h	/^void common_modify_bitw(word *variable, byte position, bool set);$/;"	p	signature:(word *variable, byte position, bool set)
common_set_bitb	abstract-machine/apps/litenes/include/common.h	/^void common_set_bitb(byte *variable, byte position);$/;"	p	signature:(byte *variable, byte position)
common_set_bitd	abstract-machine/apps/litenes/include/common.h	/^void common_set_bitd(dword *variable, byte position);$/;"	p	signature:(dword *variable, byte position)
common_set_bitw	abstract-machine/apps/litenes/include/common.h	/^void common_set_bitw(word *variable, byte position);$/;"	p	signature:(word *variable, byte position)
common_toggle_bitb	abstract-machine/apps/litenes/include/common.h	/^void common_toggle_bitb(byte *variable, byte position);$/;"	p	signature:(byte *variable, byte position)
common_toggle_bitd	abstract-machine/apps/litenes/include/common.h	/^void common_toggle_bitd(dword *variable, byte position);$/;"	p	signature:(dword *variable, byte position)
common_toggle_bitw	abstract-machine/apps/litenes/include/common.h	/^void common_toggle_bitw(word *variable, byte position);$/;"	p	signature:(word *variable, byte position)
common_unset_bitb	abstract-machine/apps/litenes/include/common.h	/^void common_unset_bitb(byte *variable, byte position);$/;"	p	signature:(byte *variable, byte position)
common_unset_bitd	abstract-machine/apps/litenes/include/common.h	/^void common_unset_bitd(dword *variable, byte position);$/;"	p	signature:(dword *variable, byte position)
common_unset_bitw	abstract-machine/apps/litenes/include/common.h	/^void common_unset_bitw(word *variable, byte position);$/;"	p	signature:(word *variable, byte position)
compile_bf	abstract-machine/apps/microbench/src/bf/bf.c	/^static int compile_bf() {$/;"	f	file:
compilerrt_abort	abstract-machine/libs/compiler-rt/int_util.h	23;"	d
compilerrt_abort_impl	abstract-machine/libs/compiler-rt/int_util.h	/^NORETURN void compilerrt_abort_impl(const char *file, int line,$/;"	p	signature:(const char *file, int line, const char *function)
compress	abstract-machine/apps/microbench/src/lzip/lzip.c	/^static char *compress;$/;"	v	file:
conf	abstract-machine/am/include/x86.h	/^  MPConf  *conf;     \/\/ MP config table addr$/;"	m	struct:MPDesc	access:public
const_iterator	abstract-machine/libs/imgui/include/imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	class:ImVector	access:public
copy_info	abstract-machine/apps/coremark/src/core_list_join.c	/^void copy_info(list_data *to,list_data *from) {$/;"	f	signature:(list_data *to,list_data *from)
core_bench_list	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx);$/;"	p	signature:(core_results *res, ee_s16 finder_idx)
core_bench_list	abstract-machine/apps/coremark/src/core_list_join.c	/^ee_u16 core_bench_list(core_results *res, ee_s16 finder_idx) {$/;"	f	signature:(core_results *res, ee_s16 finder_idx)
core_bench_matrix	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc);$/;"	p	signature:(mat_params *p, ee_s16 seed, ee_u16 crc)
core_bench_matrix	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_u16 core_bench_matrix(mat_params *p, ee_s16 seed, ee_u16 crc) {$/;"	f	signature:(mat_params *p, ee_s16 seed, ee_u16 crc)
core_bench_state	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 core_bench_state(ee_u32 blksize, ee_u8 *memblock, $/;"	p	signature:(ee_u32 blksize, ee_u8 *memblock, ee_s16 seed1, ee_s16 seed2, ee_s16 step, ee_u16 crc)
core_bench_state	abstract-machine/apps/coremark/src/core_state.c	/^ee_u16 core_bench_state(ee_u32 blksize, ee_u8 *memblock, $/;"	f	signature:(ee_u32 blksize, ee_u8 *memblock, ee_s16 seed1, ee_s16 seed2, ee_s16 step, ee_u16 crc)
core_init_matrix	abstract-machine/apps/coremark/include/coremark.h	/^ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p);$/;"	p	signature:(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p)
core_init_matrix	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_u32 core_init_matrix(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p) {$/;"	f	signature:(ee_u32 blksize, void *memblk, ee_s32 seed, mat_params *p)
core_init_state	abstract-machine/apps/coremark/include/coremark.h	/^void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p);$/;"	p	signature:(ee_u32 size, ee_s16 seed, ee_u8 *p)
core_init_state	abstract-machine/apps/coremark/src/core_state.c	/^void core_init_state(ee_u32 size, ee_s16 seed, ee_u8 *p) {$/;"	f	signature:(ee_u32 size, ee_s16 seed, ee_u8 *p)
core_list_find	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_find(list_head *list,list_data *info) {$/;"	f	signature:(list_head *list,list_data *info)
core_list_find	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_find(list_head *list,list_data *info);$/;"	p	file:	signature:(list_head *list,list_data *info)
core_list_init	abstract-machine/apps/coremark/include/coremark.h	/^list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed);$/;"	p	signature:(ee_u32 blksize, list_head *memblock, ee_s16 seed)
core_list_init	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_init(ee_u32 blksize, list_head *memblock, ee_s16 seed) {$/;"	f	signature:(ee_u32 blksize, list_head *memblock, ee_s16 seed)
core_list_insert_new	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_insert_new(list_head *insert_point$/;"	p	file:	signature:(list_head *insert_point , list_data *info, list_head **memblock, list_data **datablock , list_head *memblock_end, list_data *datablock_end)
core_list_insert_new	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_insert_new(list_head *insert_point, list_data *info, list_head **memblock, list_data **datablock$/;"	f	signature:(list_head *insert_point, list_data *info, list_head **memblock, list_data **datablock , list_head *memblock_end, list_data *datablock_end)
core_list_mergesort	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res) {$/;"	f	signature:(list_head *list, list_cmp cmp, core_results *res)
core_list_mergesort	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_mergesort(list_head *list, list_cmp cmp, core_results *res);$/;"	p	file:	signature:(list_head *list, list_cmp cmp, core_results *res)
core_list_remove	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_remove(list_head *item) {$/;"	f	signature:(list_head *item)
core_list_remove	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_remove(list_head *item);$/;"	p	file:	signature:(list_head *item)
core_list_reverse	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_reverse(list_head *list) {$/;"	f	signature:(list_head *list)
core_list_reverse	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_reverse(list_head *list);$/;"	p	file:	signature:(list_head *list)
core_list_undo_remove	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_undo_remove(list_head *item_removed, list_head *item_modified) {$/;"	f	signature:(list_head *item_removed, list_head *item_modified)
core_list_undo_remove	abstract-machine/apps/coremark/src/core_list_join.c	/^list_head *core_list_undo_remove(list_head *item_removed, list_head *item_modified);$/;"	p	file:	signature:(list_head *item_removed, list_head *item_modified)
core_portable	abstract-machine/apps/coremark/include/core_portme.h	/^} core_portable;$/;"	t	typeref:struct:CORE_PORTABLE_S
core_results	abstract-machine/apps/coremark/include/coremark.h	/^} core_results;$/;"	t	typeref:struct:RESULTS_S
core_start_parallel	abstract-machine/apps/coremark/include/coremark.h	/^ee_u8 core_start_parallel(core_results *res);$/;"	p	signature:(core_results *res)
core_state_e	abstract-machine/apps/coremark/include/coremark.h	/^} core_state_e ;$/;"	t	typeref:enum:CORE_STATE
core_state_transition	abstract-machine/apps/coremark/src/core_state.c	/^enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count) {$/;"	f	signature:( ee_u8 **instr , ee_u32 *transition_count)
core_state_transition	abstract-machine/apps/coremark/src/core_state.c	/^enum CORE_STATE core_state_transition( ee_u8 **instr , ee_u32 *transition_count);$/;"	p	file:	signature:( ee_u8 **instr , ee_u32 *transition_count)
core_stop_parallel	abstract-machine/apps/coremark/include/coremark.h	/^ee_u8 core_stop_parallel(core_results *res);$/;"	p	signature:(core_results *res)
cos	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  cos() { return Fix16(fix16_cos(value));  }$/;"	f	class:Fix16	access:public	signature:()
cpu	abstract-machine/am/amtrace.h	/^  uint16_t cpu;   \/\/ cpu id (0 based)$/;"	m	struct:_TraceEvent	access:public
cpu	abstract-machine/apps/litenes/include/cpu.h	/^extern CPU_STATE cpu;$/;"	x
cpu	abstract-machine/apps/litenes/src/cpu.c	/^CPU_STATE cpu;$/;"	v
cpu_address_absolute	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_absolute()$/;"	f
cpu_address_absolute	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_absolute();$/;"	p	file:
cpu_address_absolute_x	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_absolute_x()$/;"	f
cpu_address_absolute_x	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_absolute_x();$/;"	p	file:
cpu_address_absolute_y	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_absolute_y()$/;"	f
cpu_address_absolute_y	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_absolute_y();$/;"	p	file:
cpu_address_immediate	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_immediate()$/;"	f
cpu_address_immediate	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_immediate();$/;"	p	file:
cpu_address_implied	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_implied()$/;"	f
cpu_address_implied	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_implied();$/;"	p	file:
cpu_address_indirect	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_indirect()$/;"	f
cpu_address_indirect	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_indirect();$/;"	p	file:
cpu_address_indirect_x	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_indirect_x()$/;"	f
cpu_address_indirect_x	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_indirect_x();$/;"	p	file:
cpu_address_indirect_y	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_indirect_y()$/;"	f
cpu_address_indirect_y	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_indirect_y();$/;"	p	file:
cpu_address_relative	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_relative()$/;"	f
cpu_address_relative	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_relative();$/;"	p	file:
cpu_address_zero_page	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_zero_page()$/;"	f
cpu_address_zero_page	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_zero_page();$/;"	p	file:
cpu_address_zero_page_x	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_zero_page_x()$/;"	f
cpu_address_zero_page_x	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_zero_page_x();$/;"	p	file:
cpu_address_zero_page_y	abstract-machine/apps/litenes/src/cpu-addressing.c	/^void cpu_address_zero_page_y()$/;"	f
cpu_address_zero_page_y	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_address_zero_page_y();$/;"	p	file:
cpu_branch	abstract-machine/apps/litenes/src/cpu.c	122;"	d	file:
cpu_clock	abstract-machine/apps/litenes/include/cpu.h	/^unsigned long cpu_clock();$/;"	p	signature:()
cpu_clock	abstract-machine/apps/litenes/src/cpu.c	/^inline unsigned long cpu_clock()$/;"	f
cpu_compare	abstract-machine/apps/litenes/src/cpu.c	130;"	d	file:
cpu_cycles	abstract-machine/apps/litenes/src/cpu.c	/^unsigned long cpu_cycles;  \/\/ Total CPU Cycles Since Power Up (wraps)$/;"	v
cpu_flag_set	abstract-machine/apps/litenes/src/cpu.c	115;"	d	file:
cpu_init	abstract-machine/apps/litenes/include/cpu.h	/^void cpu_init();$/;"	p	signature:()
cpu_init	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_init()$/;"	f
cpu_interrupt	abstract-machine/apps/litenes/include/cpu.h	/^void cpu_interrupt();$/;"	p	signature:()
cpu_interrupt	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_interrupt()$/;"	f
cpu_irq_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^inline word cpu_irq_interrupt_address()   { return memory_readw(0xFFFE); }$/;"	f
cpu_irq_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^word cpu_irq_interrupt_address();$/;"	p	file:
cpu_local	abstract-machine/am/src/x86/x86-qemu.h	/^struct cpu_local {$/;"	s
cpu_local::gdt	abstract-machine/am/src/x86/x86-qemu.h	/^  SegDesc gdt[NR_SEG];$/;"	m	struct:cpu_local	access:public
cpu_local::prot	abstract-machine/am/src/x86/x86-qemu.h	/^  _AddressSpace *prot;$/;"	m	struct:cpu_local	access:public
cpu_local::stack	abstract-machine/am/src/x86/x86-qemu.h	/^  uint8_t stack[4096];$/;"	m	struct:cpu_local	access:public
cpu_local::tss	abstract-machine/am/src/x86/x86-qemu.h	/^  TSS tss;$/;"	m	struct:cpu_local	access:public
cpu_modify_flag	abstract-machine/apps/litenes/src/cpu.c	116;"	d	file:
cpu_nmi_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^inline word cpu_nmi_interrupt_address()   { return memory_readw(0xFFFA); }$/;"	f
cpu_nmi_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^word cpu_nmi_interrupt_address();$/;"	p	file:
cpu_op_adc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_adc()$/;"	f
cpu_op_address_mode	abstract-machine/apps/litenes/src/cpu.c	/^void (*cpu_op_address_mode[256])();       \/\/ Array of address modes$/;"	v
cpu_op_and	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_and() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A &= op_value); }$/;"	f
cpu_op_asl	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_asl()$/;"	f
cpu_op_asla	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_asla()$/;"	f
cpu_op_aso	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_aso() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_op_asl(); cpu_op_ora(); }$/;"	f
cpu_op_axa	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_axa() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); memory_writeb(op_address, cpu.A & cpu.X & (op_address >> 8)); }$/;"	f
cpu_op_axs	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_axs() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); memory_writeb(op_address, cpu.A & cpu.X); }$/;"	f
cpu_op_bcc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bcc() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(!cpu_flag_set(carry_bp));    }$/;"	f
cpu_op_bcs	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bcs() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(cpu_flag_set(carry_bp));     }$/;"	f
cpu_op_beq	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_beq() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(cpu_flag_set(zero_bp));      }$/;"	f
cpu_op_bit	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bit() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_modify_flag(zero_bp, !(cpu.A & op_value)); cpu.P = (cpu.P & 0x3F) | (0xC0 & op_value); }$/;"	f
cpu_op_bmi	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bmi() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(cpu_flag_set(negative_bp));  }$/;"	f
cpu_op_bne	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bne() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(!cpu_flag_set(zero_bp));     }$/;"	f
cpu_op_bpl	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bpl() {$/;"	f
cpu_op_brk	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_brk() {$/;"	f
cpu_op_bvc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bvc() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(!cpu_flag_set(overflow_bp)); }$/;"	f
cpu_op_bvs	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_bvs() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_branch(cpu_flag_set(overflow_bp));  }$/;"	f
cpu_op_clc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_clc() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_unset_flag(carry_bp);     }$/;"	f
cpu_op_cld	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_cld() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_unset_flag(decimal_bp);   }$/;"	f
cpu_op_cli	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_cli() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_unset_flag(interrupt_bp); }$/;"	f
cpu_op_clv	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_clv() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_unset_flag(overflow_bp);  }$/;"	f
cpu_op_cmp	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_cmp() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_compare(cpu.A); }$/;"	f
cpu_op_cpx	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_cpx() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_compare(cpu.X); }$/;"	f
cpu_op_cpy	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_cpy() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_compare(cpu.Y); }$/;"	f
cpu_op_cycles	abstract-machine/apps/litenes/src/cpu.c	/^int cpu_op_cycles[256];                   \/\/ CPU cycles used by instructions$/;"	v
cpu_op_dcm	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_dcm()$/;"	f
cpu_op_dec	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_dec() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); byte result = op_value - 1; memory_writeb(op_address, result); cpu_update_zn_flags(result); }$/;"	f
cpu_op_dex	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_dex() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(--cpu.X); }$/;"	f
cpu_op_dey	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_dey() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(--cpu.Y); }$/;"	f
cpu_op_eor	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_eor() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A ^= op_value); }$/;"	f
cpu_op_handler	abstract-machine/apps/litenes/src/cpu.c	/^void (*cpu_op_handler[256])();            \/\/ Array of instruction function pointers$/;"	v
cpu_op_in_base_instruction_set	abstract-machine/apps/litenes/src/cpu.c	/^bool cpu_op_in_base_instruction_set[256]; \/\/ true if instruction is in base 6502 instruction set$/;"	v
cpu_op_inc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_inc() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); byte result = op_value + 1; memory_writeb(op_address, result); cpu_update_zn_flags(result); }$/;"	f
cpu_op_ins	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_ins()$/;"	f
cpu_op_inx	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_inx() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(++cpu.X); }$/;"	f
cpu_op_iny	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_iny() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(++cpu.Y); }$/;"	f
cpu_op_jmp	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_jmp() {$/;"	f
cpu_op_jsr	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_jsr() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_stack_pushw(cpu.PC - 1); cpu.PC = op_address; }$/;"	f
cpu_op_lax	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_lax() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A = cpu.X = op_value); }$/;"	f
cpu_op_lda	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_lda() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A = op_value); }$/;"	f
cpu_op_ldx	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_ldx() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.X = op_value); }$/;"	f
cpu_op_ldy	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_ldy() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.Y = op_value); }$/;"	f
cpu_op_lse	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_lse() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_op_lsr(); cpu_op_eor(); }$/;"	f
cpu_op_lsr	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_lsr()$/;"	f
cpu_op_lsra	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_lsra()$/;"	f
cpu_op_name	abstract-machine/apps/litenes/src/cpu.c	/^char *cpu_op_name[256];                   \/\/ Instruction names$/;"	v
cpu_op_nop	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_nop() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC);}$/;"	f
cpu_op_ora	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_ora() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A |= op_value); }$/;"	f
cpu_op_pha	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_pha() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_stack_pushb(cpu.A); }$/;"	f
cpu_op_php	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_php() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_stack_pushb(cpu.P | 0x30); }$/;"	f
cpu_op_pla	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_pla() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu.A = cpu_stack_popb(); cpu_update_zn_flags(cpu.A); }$/;"	f
cpu_op_plp	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_plp() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu.P = (cpu_stack_popb() & 0xEF) | 0x20; }$/;"	f
cpu_op_rla	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rla() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_op_rol(); cpu_op_and(); }$/;"	f
cpu_op_rol	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rol()$/;"	f
cpu_op_rola	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rola()$/;"	f
cpu_op_ror	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_ror()$/;"	f
cpu_op_rora	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rora()$/;"	f
cpu_op_rra	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rra() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_op_ror(); cpu_op_adc(); }$/;"	f
cpu_op_rti	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rti() {$/;"	f
cpu_op_rts	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_rts() {$/;"	f
cpu_op_sbc	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sbc()$/;"	f
cpu_op_sec	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sec() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_set_flag(carry_bp);       }$/;"	f
cpu_op_sed	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sed() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_set_flag(decimal_bp);     }$/;"	f
cpu_op_sei	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sei() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_set_flag(interrupt_bp);   }$/;"	f
cpu_op_sta	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sta() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); memory_writeb(op_address, cpu.A); }$/;"	f
cpu_op_stx	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_stx() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); memory_writeb(op_address, cpu.X); }$/;"	f
cpu_op_sty	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_sty() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); memory_writeb(op_address, cpu.Y); }$/;"	f
cpu_op_tax	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_tax() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.X = cpu.A);  }$/;"	f
cpu_op_tay	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_tay() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.Y = cpu.A);  }$/;"	f
cpu_op_tsx	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_tsx() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.X = cpu.SP); }$/;"	f
cpu_op_txa	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_txa() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A = cpu.X);  }$/;"	f
cpu_op_txs	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_txs() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu.SP = cpu.X; }$/;"	f
cpu_op_tya	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_op_tya() { log("cpu.P=%x, cpu.PC=%x\\n", cpu.P, cpu.PC); cpu_update_zn_flags(cpu.A = cpu.Y);  }$/;"	f
cpu_p_bp	abstract-machine/apps/litenes/include/cpu.h	/^} cpu_p_bp;$/;"	t	typeref:enum:__anon4
cpu_p_flag	abstract-machine/apps/litenes/include/cpu.h	/^} cpu_p_flag;$/;"	t	typeref:enum:__anon3
cpu_ram_read	abstract-machine/apps/litenes/include/cpu.h	/^byte cpu_ram_read(word address);$/;"	p	signature:(word address)
cpu_ram_read	abstract-machine/apps/litenes/src/cpu.c	/^byte cpu_ram_read(word address);$/;"	p	file:	signature:(word address)
cpu_ram_read	abstract-machine/apps/litenes/src/cpu.c	/^inline byte cpu_ram_read(word address)$/;"	f	signature:(word address)
cpu_ram_write	abstract-machine/apps/litenes/include/cpu.h	/^void cpu_ram_write(word address, byte data);$/;"	p	signature:(word address, byte data)
cpu_ram_write	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_ram_write(word address, byte data)$/;"	f	signature:(word address, byte data)
cpu_ram_write	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_ram_write(word address, byte data);$/;"	p	file:	signature:(word address, byte data)
cpu_reset	abstract-machine/apps/litenes/include/cpu.h	/^void cpu_reset();$/;"	p	signature:()
cpu_reset	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_reset()$/;"	f
cpu_reset_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^inline word cpu_reset_interrupt_address() { return memory_readw(0xFFFC); }$/;"	f
cpu_reset_interrupt_address	abstract-machine/apps/litenes/src/cpu.c	/^word cpu_reset_interrupt_address();$/;"	p	file:
cpu_run	abstract-machine/apps/litenes/include/cpu.h	/^void cpu_run(long cycles);$/;"	p	signature:(long cycles)
cpu_run	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_run(long cycles)$/;"	f	signature:(long cycles)
cpu_set_flag	abstract-machine/apps/litenes/src/cpu.c	117;"	d	file:
cpu_stack_popb	abstract-machine/apps/litenes/src/cpu.c	/^byte cpu_stack_popb()           { return memory_readb(0x100 + ++cpu.SP);       }$/;"	f
cpu_stack_popw	abstract-machine/apps/litenes/src/cpu.c	/^word cpu_stack_popw()           { cpu.SP += 2; return memory_readw(0xFF + cpu.SP); }$/;"	f
cpu_stack_pushb	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_stack_pushb(byte data) { memory_writeb(0x100 + cpu.SP--, data);       }$/;"	f	signature:(byte data)
cpu_stack_pushw	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_stack_pushw(word data) { memory_writew(0xFF + cpu.SP, data); cpu.SP -= 2; }$/;"	f	signature:(word data)
cpu_trace_instruction	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_trace_instruction();$/;"	p	file:
cpu_unset_flag	abstract-machine/apps/litenes/src/cpu.c	118;"	d	file:
cpu_update_zn_flags	abstract-machine/apps/litenes/src/cpu.c	/^void cpu_update_zn_flags(byte value);$/;"	p	file:	signature:(byte value)
cpu_update_zn_flags	abstract-machine/apps/litenes/src/cpu.c	120;"	d	file:
cpu_zn_flag_table	abstract-machine/apps/litenes/src/cpu.c	/^static const byte cpu_zn_flag_table[256] =$/;"	v	file:
cpuinfo	abstract-machine/am/src/x86/qemu/mpe.c	/^struct cpu_local cpuinfo[MAX_CPU];$/;"	v	typeref:struct:cpu_local
cpuinfo	abstract-machine/am/src/x86/x86-qemu.h	/^extern struct cpu_local cpuinfo[MAX_CPU];$/;"	x
crc	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crc;$/;"	m	struct:RESULTS_S	access:public
crc16	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 crc16(ee_s16 newval, ee_u16 crc);$/;"	p	signature:(ee_s16 newval, ee_u16 crc)
crc16	abstract-machine/apps/coremark/src/core_util.c	/^ee_u16 crc16(ee_s16 newval, ee_u16 crc) {$/;"	f	signature:(ee_s16 newval, ee_u16 crc)
crclist	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crclist;$/;"	m	struct:RESULTS_S	access:public
crcmatrix	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crcmatrix;$/;"	m	struct:RESULTS_S	access:public
crcstate	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u16	crcstate;$/;"	m	struct:RESULTS_S	access:public
crcu16	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 crcu16(ee_u16 newval, ee_u16 crc);$/;"	p	signature:(ee_u16 newval, ee_u16 crc)
crcu16	abstract-machine/apps/coremark/src/core_util.c	/^ee_u16 crcu16(ee_u16 newval, ee_u16 crc) {$/;"	f	signature:(ee_u16 newval, ee_u16 crc)
crcu32	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 crcu32(ee_u32 newval, ee_u16 crc);$/;"	p	signature:(ee_u32 newval, ee_u16 crc)
crcu32	abstract-machine/apps/coremark/src/core_util.c	/^ee_u16 crcu32(ee_u32 newval, ee_u16 crc) {$/;"	f	signature:(ee_u32 newval, ee_u16 crc)
crcu8	abstract-machine/apps/coremark/include/coremark.h	/^ee_u16 crcu8(ee_u8 data, ee_u16 crc);$/;"	p	signature:(ee_u8 data, ee_u16 crc)
crcu8	abstract-machine/apps/coremark/src/core_util.c	/^ee_u16 crcu8(ee_u8 data, ee_u16 crc )$/;"	f	signature:(ee_u8 data, ee_u16 crc )
create_new_letter	abstract-machine/apps/typing/game.c	/^void create_new_letter(){$/;"	f
create_new_letter	abstract-machine/apps/typing/game.h	/^void create_new_letter(void);$/;"	p	signature:(void)
cs	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
cs	abstract-machine/am/include/x86.h	/^  uint32_t cs : 16;         \/\/ Code segment selector$/;"	m	struct:GateDesc	access:public
cs	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
cur	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
cur_as	abstract-machine/am/src/native/vme.c	/^static _AddressSpace *cur_as = &empty_as;$/;"	v	file:
current	abstract-machine/apps/microbench/include/benchmark.h	/^extern Benchmark *current;$/;"	x
current	abstract-machine/apps/microbench/src/bench.c	/^Benchmark *current;$/;"	v
cursor	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int cursor;$/;"	m	struct:__anon34	access:public
cursor	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int cursor;$/;"	m	struct:__anon41	access:public
cursor_at_end_of_line	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon34	access:public
cx	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
cx1	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
cy	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
cy1	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
d	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
data	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
data	abstract-machine/apps/microbench/src/bf/bf.c	/^static unsigned short *data;$/;"	v	file:
data	abstract-machine/apps/microbench/src/qsort/qsort.c	/^static int N, *data;$/;"	v	file:
data	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo	access:public
data	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *data;$/;"	m	struct:__anon41	access:public
data16	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16 data16;$/;"	m	struct:list_data_s	access:public
db	abstract-machine/am/include/x86.h	/^  uint32_t db : 1;         \/\/ 0 = 16-bit segment, 1 = 32-bit segment$/;"	m	struct:SegDesc	access:public
decimal_bp	abstract-machine/apps/litenes/include/cpu.h	/^    decimal_bp    = 3,$/;"	e	enum:__anon4
decimal_flag	abstract-machine/apps/litenes/include/cpu.h	/^    decimal_flag   = 0x08,$/;"	e	enum:__anon3
def	abstract-machine/am/src/x86/qemu/cte.c	164;"	d	file:
default_num_contexts	abstract-machine/apps/coremark/include/core_portme.h	/^extern ee_u32 default_num_contexts;$/;"	x
default_num_contexts	abstract-machine/apps/coremark/src/core_portme.c	/^ee_u32 default_num_contexts=1;$/;"	v
delete_length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           delete_length;$/;"	m	struct:__anon32	access:public
desc	abstract-machine/apps/microbench/include/benchmark.h	/^  const char *name, *desc;$/;"	m	struct:Benchmark	access:public
determine_hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    void determine_hash();$/;"	p	class:N_puzzle	access:private	signature:()
determine_hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^void N_puzzle<N>::determine_hash() {$/;"	f	class:N_puzzle	signature:()
dfs	abstract-machine/apps/microbench/src/queen/queen.c	/^static unsigned int dfs(unsigned int row, unsigned int ld, unsigned int rd) {$/;"	f	file:	signature:(unsigned int row, unsigned int ld, unsigned int rd)
di_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef          long long di_int;$/;"	t
digest	abstract-machine/apps/microbench/src/md5/md5.c	/^static uint8_t *digest;$/;"	v	file:
direct_color_attributes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t direct_color_attributes;$/;"	m	struct:VBEInfo	file:	access:public
direction	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge	access:public
direction	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge	access:public
display_image	abstract-machine/apps/slider/main.cpp	/^void display_image(int i) {$/;"	f	signature:(int i)
done	abstract-machine/apps/microbench/include/benchmark.h	/^void done(Result *res);$/;"	p	signature:(Result *res)
double_bits	abstract-machine/libs/compiler-rt/int_types.h	/^} double_bits;$/;"	t	typeref:union:__anon25
dpl	abstract-machine/am/include/x86.h	/^  uint32_t dpl : 2;         \/\/ Descriptor(meaning new) privilege level$/;"	m	struct:GateDesc	access:public
dpl	abstract-machine/am/include/x86.h	/^  uint32_t dpl : 2;        \/\/ Descriptor Privilege Level$/;"	m	struct:SegDesc	access:public
draw	abstract-machine/apps/litenes/src/ppu.c	/^static inline void draw(int col, int row, int idx) {$/;"	f	file:	signature:(int col, int row, int idx)
draw_character	abstract-machine/apps/typing/draw.c	/^static inline void draw_character(char ch, int x, int y, int color) {$/;"	f	file:	signature:(char ch, int x, int y, int color)
draw_rect	abstract-machine/libs/klib/include/klib.h	/^void draw_rect(uint32_t *pixels, int x, int y, int w, int h);$/;"	p	signature:(uint32_t *pixels, int x, int y, int w, int h)
draw_rect	abstract-machine/libs/klib/src/io.c	/^void draw_rect(uint32_t *pixels, int x, int y, int w, int h) {$/;"	f	signature:(uint32_t *pixels, int x, int y, int w, int h)
draw_rect	amgame/src/game.c	/^void draw_rect(int x, int y, int w, int h, uint32_t color) {$/;"	f	signature:(int x, int y, int w, int h, uint32_t color)
draw_string	abstract-machine/apps/typing/draw.c	/^static inline void draw_string(const char *str, int x, int y, int color) {$/;"	f	file:	signature:(const char *str, int x, int y, int color)
draw_sync	abstract-machine/libs/klib/include/klib.h	/^void draw_sync();$/;"	p	signature:()
draw_sync	abstract-machine/libs/klib/src/io.c	/^void draw_sync() {$/;"	f
ds	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
ds	abstract-machine/am/include/x86.h	/^  uint32_t es, ds;               \/\/ Segment register$/;"	m	struct:TrapFrame	access:public
du_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef unsigned long long du_int;$/;"	t
dword	abstract-machine/apps/litenes/include/common.h	/^typedef uint32_t dword;$/;"	t
dwords	abstract-machine/libs/compiler-rt/int_types.h	/^} dwords;$/;"	t	typeref:union:__anon16
dx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
e	abstract-machine/libs/imgui/include/imgui.h	/^        const char* e;$/;"	m	struct:ImGuiTextFilter::TextRange	access:public
eax	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
eax	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
ebp	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
ebp	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
ebx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
ebx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
ecx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
ecx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
edges	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  Edge edges[MAXM];$/;"	m	struct:Dinic	file:	access:public
edi	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
edi	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
edx	abstract-machine/am/include/arch/x86-qemu.h	/^  uint32_t eax, ebx, ecx, edx,$/;"	m	struct:_Context	access:public
edx	abstract-machine/am/include/x86.h	/^  uint32_t ebx, edx, ecx, eax;   \/\/ Register saved by pushal$/;"	m	struct:TrapFrame	access:public
ee_f32	abstract-machine/apps/coremark/include/core_portme.h	/^typedef double ee_f32;$/;"	t
ee_isdigit	abstract-machine/apps/coremark/src/core_state.c	/^static ee_u8 ee_isdigit(ee_u8 c) {$/;"	f	file:	signature:(ee_u8 c)
ee_printf	abstract-machine/apps/coremark/include/coremark.h	44;"	d
ee_ptr_int	abstract-machine/apps/coremark/include/core_portme.h	/^typedef unsigned long ee_ptr_int;$/;"	t
ee_s16	abstract-machine/apps/coremark/include/core_portme.h	/^typedef signed short ee_s16;$/;"	t
ee_s32	abstract-machine/apps/coremark/include/core_portme.h	/^typedef signed int ee_s32;$/;"	t
ee_size_t	abstract-machine/apps/coremark/include/core_portme.h	/^typedef size_t ee_size_t;$/;"	t
ee_u16	abstract-machine/apps/coremark/include/core_portme.h	/^typedef unsigned short ee_u16;$/;"	t
ee_u32	abstract-machine/apps/coremark/include/core_portme.h	/^typedef unsigned int ee_u32;$/;"	t
ee_u8	abstract-machine/apps/coremark/include/core_portme.h	/^typedef unsigned char ee_u8;$/;"	t
eflags	abstract-machine/am/include/arch/x86-qemu.h	/^           eip, eflags,$/;"	m	struct:_Context	access:public
eflags	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
ehsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t ehsize;$/;"	m	struct:ELFHeader	file:	access:public
eip	abstract-machine/am/include/arch/x86-qemu.h	/^           eip, eflags,$/;"	m	struct:_Context	access:public
eip	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
element	abstract-machine/apps/microbench/src/15pz/heap.h	/^    T element;$/;"	m	class:Updatable_heap::Step	access:public
elf	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint8_t  elf[12];$/;"	m	struct:ELFHeader	file:	access:public
empty	abstract-machine/libs/imgui/include/imgui.h	/^        bool empty() const { return b == e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
empty	abstract-machine/libs/imgui/include/imgui.h	/^    bool                empty() { return Buf.Size <= 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:()
empty	abstract-machine/libs/imgui/include/imgui.h	/^    inline bool                 empty() const                   { return Size == 0; }$/;"	f	class:ImVector	access:public	signature:() const
empty_as	abstract-machine/am/src/native/vme.c	/^static _AddressSpace empty_as = { .ptr = NULL };$/;"	v	file:
end	abstract-machine/am/am.h	/^  void *start, *end;$/;"	m	struct:_Area	access:public
end	abstract-machine/libs/imgui/include/imgui.h	/^        const char* end() const { return e; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
end	abstract-machine/libs/imgui/include/imgui.h	/^    const char*         end() const { return &Buf.back(); }      \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
end	abstract-machine/libs/imgui/include/imgui.h	/^    inline const_iterator       end() const                     { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:() const
end	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             end()                           { return Data + Size; }$/;"	f	class:ImVector	access:public	signature:()
entry	abstract-machine/am/include/x86.h	/^  uint16_t entry;          \/\/ entry count$/;"	m	struct:MPConf	access:public
entry	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t entry;$/;"	m	struct:ELFHeader	file:	access:public
entry	abstract-machine/am/src/x86/qemu/boot/main.c	/^  void (*entry)();$/;"	m	struct:boot_info	file:	access:public
entry	abstract-machine/am/src/x86/x86-qemu.h	/^  void (*entry)();$/;"	m	struct:boot_info	access:public
erase	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             erase(const_iterator it)        { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it)
err	abstract-machine/am/include/x86.h	/^  uint32_t err, eip, cs, eflags; \/\/ Execution state before trap $/;"	m	struct:TrapFrame	access:public
err	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	err;$/;"	m	struct:RESULTS_S	access:public
errpat	abstract-machine/apps/coremark/src/core_state.c	/^static ee_u8 *errpat[4]  ={(ee_u8 *)"T0.3e-1F",(ee_u8 *)"-T.T++Tq",(ee_u8 *)"1T3.4e4z",(ee_u8 *)"34.0e-T^"};$/;"	v	file:
es	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
es	abstract-machine/am/include/x86.h	/^  uint32_t es, ds;               \/\/ Segment register$/;"	m	struct:TrapFrame	access:public
esi	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
esi	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
esp	abstract-machine/am/include/x86.h	/^  uint32_t esp, ss;              \/\/ Used only when returning to DPL=3$/;"	m	struct:TrapFrame	access:public
esp0	abstract-machine/am/include/arch/x86-qemu.h	/^           ss0, esp0;$/;"	m	struct:_Context	access:public
esp0	abstract-machine/am/include/x86.h	/^  uint32_t esp0;     \/\/ Stack pointers and segment selectors$/;"	m	struct:TSS	access:public
esp3	abstract-machine/am/include/arch/x86-qemu.h	/^           esi, edi, ebp, esp3,$/;"	m	struct:_Context	access:public
esp_	abstract-machine/am/include/x86.h	/^  uint32_t edi, esi, ebp, esp_;$/;"	m	struct:TrapFrame	access:public
estimate_freq	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static uint32_t estimate_freq() {$/;"	f	file:
event	abstract-machine/am/am.h	/^  int event;$/;"	m	struct:_Event	access:public
event_thread	abstract-machine/am/src/native/devices/input.c	/^static int event_thread(void *args) {$/;"	f	file:	signature:(void *args)
execs	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32	execs;		\/* Bitmask of operations to execute *\/$/;"	m	struct:RESULTS_S	access:public
execute_bf	abstract-machine/apps/microbench/src/bf/bf.c	/^static void execute_bf() {$/;"	f	file:
exit_platform	abstract-machine/am/src/native/platform.cpp	/^static void exit_platform() {$/;"	f	file:	signature:()
extra	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context	access:public
ey	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge	access:public
f	abstract-machine/libs/compiler-rt/int_types.h	/^    double  f;$/;"	m	union:__anon25	access:public
f	abstract-machine/libs/compiler-rt/int_types.h	/^    float f;$/;"	m	union:__anon24	access:public
f	abstract-machine/libs/compiler-rt/int_types.h	/^    long double f;$/;"	m	union:__anon27	access:public
false	abstract-machine/am/include/arch/native.h	12;"	d
false	abstract-machine/apps/dhrystone/dry.c	387;"	d	file:
false	abstract-machine/apps/litenes/include/common.h	12;"	d
false	abstract-machine/apps/microbench/include/benchmark.h	15;"	d
false	abstract-machine/apps/typing/game.h	104;"	d
fast_read	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline ui32 fast_read(void const *src, ui32 bytes)$/;"	f	file:	signature:(void const *src, ui32 bytes)
fast_write	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline void fast_write(ui32 f, void *dst, size_t bytes)$/;"	f	file:	signature:(ui32 f, void *dst, size_t bytes)
fb	abstract-machine/am/src/native/devices/video.c	/^static uint32_t fb[W * H];$/;"	v	file:
fb	abstract-machine/am/src/x86/qemu/devices/video.c	/^} __attribute__ ((packed)) *fb;$/;"	v	typeref:struct:FBPixel	file:
fce_init	abstract-machine/apps/litenes/include/fce.h	/^void fce_init();$/;"	p	signature:()
fce_init	abstract-machine/apps/litenes/src/fce.c	/^void fce_init()$/;"	f
fce_load_rom	abstract-machine/apps/litenes/include/fce.h	/^int fce_load_rom(char *rom);$/;"	p	signature:(char *rom)
fce_load_rom	abstract-machine/apps/litenes/src/fce.c	/^int fce_load_rom(char *rom)$/;"	f	signature:(char *rom)
fce_rom_header	abstract-machine/apps/litenes/src/fce.c	/^static ines_header *fce_rom_header;$/;"	v	file:
fce_run	abstract-machine/apps/litenes/include/fce.h	/^void fce_run();$/;"	p	signature:()
fce_run	abstract-machine/apps/litenes/src/fce.c	/^void fce_run()$/;"	f
fce_update_screen	abstract-machine/apps/litenes/include/fce.h	/^void fce_update_screen();$/;"	p	signature:()
fce_update_screen	abstract-machine/apps/litenes/src/fce.c	/^void fce_update_screen()$/;"	f
fdselect	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf fdselect;               \/\/ map from glyph to fontdict$/;"	m	struct:stbtt_fontinfo	access:public
fdx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
fdy	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
filesz	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t filesz;$/;"	m	struct:ProgramHeader	file:	access:public
first_char	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon36	access:public
first_free	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap	access:public
first_unicode_codepoint_in_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon45	access:public
first_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon55	access:public
first_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon55	access:public
fix16__log2_inner	abstract-machine/libs/fixmath/src/fix16_exp.c	/^static fix16_t fix16__log2_inner(fix16_t x)$/;"	f	file:	signature:(fix16_t x)
fix16_abs	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_abs(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_acos	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_acos(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_add	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_add(fix16_t inArg0, fix16_t inArg1) { return (inArg0 + inArg1); }$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1)
fix16_add	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_add(fix16_t a, fix16_t b)$/;"	f	signature:(fix16_t a, fix16_t b)
fix16_asin	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_asin(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_atan	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_atan(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_atan2	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_atan2(fix16_t inY , fix16_t inX)$/;"	f	signature:(fix16_t inY , fix16_t inX)
fix16_ceil	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_ceil(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_clamp	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_clamp(fix16_t x, fix16_t lo, fix16_t hi)$/;"	f	signature:(fix16_t x, fix16_t lo, fix16_t hi)
fix16_cos	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_cos(fix16_t inAngle)$/;"	f	signature:(fix16_t inAngle)
fix16_deg_to_rad	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_deg_to_rad(fix16_t degrees)$/;"	f	signature:(fix16_t degrees)
fix16_deg_to_rad_mult	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_deg_to_rad_mult = 1144;$/;"	v
fix16_div	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_div(fix16_t a, fix16_t b)$/;"	f	signature:(fix16_t a, fix16_t b)
fix16_e	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_e   = 178145;     \/*!< fix16_t value of e *\/$/;"	v
fix16_exp	abstract-machine/libs/fixmath/src/fix16_exp.c	/^fix16_t fix16_exp(fix16_t inValue) {$/;"	f	signature:(fix16_t inValue)
fix16_floor	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_floor(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_from_dbl	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_from_dbl(double a)$/;"	f	signature:(double a)
fix16_from_float	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_from_float(float a)$/;"	f	signature:(float a)
fix16_from_int	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_from_int(int a)     { return a * fix16_one; }$/;"	f	signature:(int a)
fix16_from_str	abstract-machine/libs/fixmath/include/fix16.h	/^extern fix16_t fix16_from_str(const char *buf);$/;"	p	signature:(const char *buf)
fix16_from_str	abstract-machine/libs/fixmath/src/fix16_str.c	/^fix16_t fix16_from_str(const char *buf)$/;"	f	signature:(const char *buf)
fix16_lerp16	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_lerp16(fix16_t inArg0, fix16_t inArg1, uint16_t inFract)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1, uint16_t inFract)
fix16_lerp32	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_lerp32(fix16_t inArg0, fix16_t inArg1, uint32_t inFract)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1, uint32_t inFract)
fix16_lerp8	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_lerp8(fix16_t inArg0, fix16_t inArg1, uint8_t inFract)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1, uint8_t inFract)
fix16_log	abstract-machine/libs/fixmath/src/fix16_exp.c	/^fix16_t fix16_log(fix16_t inValue)$/;"	f	signature:(fix16_t inValue)
fix16_log2	abstract-machine/libs/fixmath/src/fix16_exp.c	/^fix16_t fix16_log2(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_max	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_max(fix16_t x, fix16_t y)$/;"	f	signature:(fix16_t x, fix16_t y)
fix16_maximum	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_maximum  = 0x7FFFFFFF; \/*!< the maximum value of fix16_t *\/$/;"	v
fix16_min	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_min(fix16_t x, fix16_t y)$/;"	f	signature:(fix16_t x, fix16_t y)
fix16_minimum	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_minimum  = 0x80000000; \/*!< the minimum value of fix16_t *\/$/;"	v
fix16_mod	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_mod(fix16_t x, fix16_t y)$/;"	f	signature:(fix16_t x, fix16_t y)
fix16_mul	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1)
fix16_one	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_one = 0x00010000; \/*!< fix16_t value of 1 *\/$/;"	v
fix16_overflow	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_overflow = 0x80000000; \/*!< the value used to indicate overflows when FIXMATH_NO_OVERFLOW is not specified *\/$/;"	v
fix16_pi	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_pi  = 205887;     \/*!< fix16_t value of pi *\/$/;"	v
fix16_rad_to_deg	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_rad_to_deg(fix16_t radians)$/;"	f	signature:(fix16_t radians)
fix16_rad_to_deg_mult	abstract-machine/libs/fixmath/include/fix16.h	/^static const fix16_t fix16_rad_to_deg_mult = 3754936;$/;"	v
fix16_rs	abstract-machine/libs/fixmath/src/fix16_exp.c	/^static inline fix16_t fix16_rs(fix16_t x)$/;"	f	file:	signature:(fix16_t x)
fix16_sadd	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_sadd(fix16_t a, fix16_t b)$/;"	f	signature:(fix16_t a, fix16_t b)
fix16_sdiv	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_sdiv(fix16_t inArg0, fix16_t inArg1)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1)
fix16_sin	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_sin(fix16_t inAngle)$/;"	f	signature:(fix16_t inAngle)
fix16_sin_parabola	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_sin_parabola(fix16_t inAngle)$/;"	f	signature:(fix16_t inAngle)
fix16_slog2	abstract-machine/libs/fixmath/src/fix16_exp.c	/^fix16_t fix16_slog2(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_smul	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_smul(fix16_t inArg0, fix16_t inArg1)$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1)
fix16_sq	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_sq(fix16_t x)$/;"	f	signature:(fix16_t x)
fix16_sqrt	abstract-machine/libs/fixmath/src/fix16_sqrt.c	/^fix16_t fix16_sqrt(fix16_t inValue)$/;"	f	signature:(fix16_t inValue)
fix16_ssub	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_ssub(fix16_t a, fix16_t b)$/;"	f	signature:(fix16_t a, fix16_t b)
fix16_sub	abstract-machine/libs/fixmath/include/fix16.h	/^static inline fix16_t fix16_sub(fix16_t inArg0, fix16_t inArg1) { return (inArg0 - inArg1); }$/;"	f	signature:(fix16_t inArg0, fix16_t inArg1)
fix16_sub	abstract-machine/libs/fixmath/src/fix16.c	/^fix16_t fix16_sub(fix16_t a, fix16_t b)$/;"	f	signature:(fix16_t a, fix16_t b)
fix16_t	abstract-machine/libs/fixmath/include/fix16.h	/^typedef int32_t fix16_t;$/;"	t
fix16_tan	abstract-machine/libs/fixmath/src/fix16_trig.c	/^fix16_t fix16_tan(fix16_t inAngle)$/;"	f	signature:(fix16_t inAngle)
fix16_to_dbl	abstract-machine/libs/fixmath/include/fix16.h	/^static inline double  fix16_to_dbl(fix16_t a)   { return (double)a \/ fix16_one; }$/;"	f	signature:(fix16_t a)
fix16_to_float	abstract-machine/libs/fixmath/include/fix16.h	/^static inline float   fix16_to_float(fix16_t a) { return (float)a \/ fix16_one; }$/;"	f	signature:(fix16_t a)
fix16_to_int	abstract-machine/libs/fixmath/include/fix16.h	/^static inline int fix16_to_int(fix16_t a)$/;"	f	signature:(fix16_t a)
fix16_to_str	abstract-machine/libs/fixmath/include/fix16.h	/^extern void fix16_to_str(fix16_t value, char *buf, int decimals);$/;"	p	signature:(fix16_t value, char *buf, int decimals)
fix16_to_str	abstract-machine/libs/fixmath/src/fix16_str.c	/^void fix16_to_str(fix16_t value, char *buf, int decimals)$/;"	f	signature:(fix16_t value, char *buf, int decimals)
flags	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t flags;$/;"	m	struct:ELFHeader	file:	access:public
flags	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t flags;$/;"	m	struct:ProgramHeader	file:	access:public
float_bits	abstract-machine/libs/compiler-rt/int_types.h	/^} float_bits;$/;"	t	typeref:union:__anon24
floatpat	abstract-machine/apps/coremark/src/core_state.c	/^static ee_u8 *floatpat[4]={(ee_u8 *)"35.54400",(ee_u8 *)".1234500",(ee_u8 *)"-110.700",(ee_u8 *)"+0.64400"};$/;"	v	file:
flow	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
font8x8_basic	abstract-machine/apps/typing/draw.c	/^extern char font8x8_basic[128][8];$/;"	x
font8x8_basic	abstract-machine/apps/typing/font.c	/^char font8x8_basic[128][8] = {$/;"	v
font_size	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float font_size;$/;"	m	struct:__anon45	access:public
fontdicts	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf fontdicts;              \/\/ array of font dicts$/;"	m	struct:stbtt_fontinfo	access:public
fontstart	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo	access:public
fract32_create	abstract-machine/libs/fixmath/include/fract32.h	/^extern fract32_t fract32_create(uint32_t inNumerator, uint32_t inDenominator);$/;"	p	signature:(uint32_t inNumerator, uint32_t inDenominator)
fract32_create	abstract-machine/libs/fixmath/src/fract32.c	/^fract32_t fract32_create(uint32_t inNumerator, uint32_t inDenominator) {$/;"	f	signature:(uint32_t inNumerator, uint32_t inDenominator)
fract32_invert	abstract-machine/libs/fixmath/include/fract32.h	/^extern fract32_t fract32_invert(fract32_t inFract);$/;"	p	signature:(fract32_t inFract)
fract32_invert	abstract-machine/libs/fixmath/src/fract32.c	/^fract32_t fract32_invert(fract32_t inFract) {$/;"	f	signature:(fract32_t inFract)
fract32_smul	abstract-machine/libs/fixmath/include/fract32.h	/^extern int32_t   fract32_smul(int32_t inVal, fract32_t inFract);$/;"	p	signature:(int32_t inVal, fract32_t inFract)
fract32_smul	abstract-machine/libs/fixmath/src/fract32.c	/^int32_t fract32_smul(int32_t inVal, fract32_t inFract) {$/;"	f	signature:(int32_t inVal, fract32_t inFract)
fract32_t	abstract-machine/libs/fixmath/include/fract32.h	/^typedef uint32_t fract32_t;$/;"	t
fract32_usmul	abstract-machine/libs/fixmath/include/fract32.h	/^extern uint32_t  fract32_usmul(uint32_t inVal, fract32_t inFract);$/;"	p	signature:(uint32_t inVal, fract32_t inFract)
fract32_usmul	abstract-machine/libs/fixmath/src/fract32.c	/^uint32_t fract32_usmul(uint32_t inVal, fract32_t inFract) {$/;"	f	signature:(uint32_t inVal, fract32_t inFract)
frame_cnt	abstract-machine/apps/litenes/include/fce.h	/^extern int frame_cnt;$/;"	x
frame_cnt	abstract-machine/apps/litenes/src/fce.c	/^int frame_cnt;$/;"	v
framebuffer	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t framebuffer;$/;"	m	struct:VBEInfo	file:	access:public
free_head	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context	access:public
free_mem	abstract-machine/apps/dhrystone/dry.c	/^static char *free_mem = &memory[0];$/;"	v	file:
freq_mhz	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static uint32_t freq_mhz = 2000;$/;"	v	file:
from	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
front	abstract-machine/libs/imgui/include/imgui.h	/^        char front() const { return *b; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:() const
front	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    front() const                   { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:() const
front	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          front()                         { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	class:ImVector	access:public	signature:()
ftex	abstract-machine/libs/imgui/include/stb_truetype.h	/^GLuint ftex;$/;"	v
fx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
g	abstract-machine/am/include/x86.h	/^  uint32_t g : 1;          \/\/ Granularity: limit scaled by 4K when set$/;"	m	struct:SegDesc	access:public
g	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
gdt	abstract-machine/am/src/x86/qemu/boot/start.S	/^gdt:$/;"	l
gdt	abstract-machine/am/src/x86/x86-qemu.h	/^  SegDesc gdt[NR_SEG];$/;"	m	struct:cpu_local	access:public
gdtdesc	abstract-machine/am/src/x86/qemu/boot/start.S	/^gdtdesc:$/;"	l
get	abstract-machine/apps/microbench/src/fib/fib.c	/^static uint32_t get(uint32_t *m, int i, int j) {$/;"	f	file:	signature:(uint32_t *m, int i, int j)
get	abstract-machine/apps/microbench/src/sieve/sieve.c	/^static inline int get(int n) {$/;"	f	file:	signature:(int n)
get_cr0	abstract-machine/am/include/x86.h	/^static inline uint32_t get_cr0(void) {$/;"	f	signature:(void)
get_cr2	abstract-machine/am/include/x86.h	/^static inline uint32_t get_cr2() {$/;"	f	signature:()
get_cur_as	abstract-machine/am/src/native/cte.c	/^extern void get_cur_as(_Context *c);$/;"	p	file:	signature:(_Context *c)
get_cur_as	abstract-machine/am/src/native/vme.c	/^void get_cur_as(_Context *c) {$/;"	f	signature:(_Context *c)
get_date	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static void get_date(_DEV_TIMER_DATE_t *rtc) {$/;"	f	file:	signature:(_DEV_TIMER_DATE_t *rtc)
get_efl	abstract-machine/am/include/x86.h	/^static inline uint32_t get_efl() {$/;"	f	signature:()
get_example_uc	abstract-machine/am/src/native/cte.c	/^void get_example_uc(_Context *r);$/;"	p	file:	signature:(_Context *r)
get_example_uc	abstract-machine/am/src/native/platform.cpp	/^void get_example_uc(_Context *r) {$/;"	f	signature:(_Context *r)
get_example_uc	abstract-machine/am/src/native/vme.c	/^void get_example_uc(_Context *r);$/;"	p	file:	signature:(_Context *r)
get_fps	abstract-machine/apps/typing/game.c	/^int get_fps() {$/;"	f
get_fps	abstract-machine/apps/typing/game.h	/^int get_fps(void);$/;"	p	signature:(void)
get_hit	abstract-machine/apps/typing/game.c	/^int get_hit(){$/;"	f
get_hit	abstract-machine/apps/typing/game.h	/^int get_hit(void);$/;"	p	signature:(void)
get_info	pstree/pstree.c	/^void get_info();$/;"	p	file:
get_info	pstree/pstree.c	/^void get_info(){$/;"	f
get_miss	abstract-machine/apps/typing/game.c	/^int get_miss(){$/;"	f
get_miss	abstract-machine/apps/typing/game.h	/^int get_miss(void);$/;"	p	signature:(void)
get_seed	abstract-machine/apps/coremark/src/core_main.c	60;"	d	file:
get_seed	abstract-machine/apps/coremark/src/core_main.c	64;"	d	file:
get_seed_32	abstract-machine/apps/coremark/src/core_main.c	/^ee_s32 get_seed_32(int i);$/;"	p	file:	signature:(int i)
get_seed_32	abstract-machine/apps/coremark/src/core_main.c	61;"	d	file:
get_seed_32	abstract-machine/apps/coremark/src/core_util.c	/^	ee_s32 get_seed_32(int i) {$/;"	f	signature:(int i)
get_seed_32	abstract-machine/apps/coremark/src/core_util.c	/^ee_s32 get_seed_32(int i) {$/;"	f	signature:(int i)
get_seed_args	abstract-machine/apps/coremark/src/core_main.c	/^ee_s32 get_seed_args(int i, int argc, char *argv[]);$/;"	p	file:	signature:(int i, int argc, char *argv[])
get_seed_args	abstract-machine/apps/coremark/src/core_util.c	/^ee_s32 get_seed_args(int i, int argc, char *argv[]) {$/;"	f	signature:(int i, int argc, char *argv[])
get_time	abstract-machine/apps/coremark/include/coremark.h	/^CORE_TICKS get_time(void);$/;"	p	signature:(void)
get_time	abstract-machine/apps/coremark/src/core_portme.c	/^CORE_TICKS get_time(void) {$/;"	f	signature:(void)
get_timeofday	abstract-machine/libs/klib/include/klib.h	/^void get_timeofday(void *rtc);$/;"	p	signature:(void *rtc)
get_timeofday	abstract-machine/libs/klib/src/io.c	/^void get_timeofday(void *rtc) {$/;"	f	signature:(void *rtc)
glyf	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
granularity	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t granularity;$/;"	m	struct:VBEInfo	file:	access:public
green_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t green_mask;$/;"	m	struct:VBEInfo	file:	access:public
green_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t green_position;$/;"	m	struct:VBEInfo	file:	access:public
gsubrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf gsubrs;                 \/\/ global charstring subroutines index$/;"	m	struct:stbtt_fontinfo	access:public
gtime	abstract-machine/apps/litenes/src/fce.c	/^static unsigned long gtime;$/;"	v	file:
h	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
h	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
h	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
h	amgame/src/game.c	/^int w, h;$/;"	v
h_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon45	access:public
h_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
handler	abstract-machine/am/am.h	/^int _cte_init(_Context *(*handler)(_Event ev, _Context *ctx));$/;"	p	signature:(_Event ev, _Context *ctx)
handler	abstract-machine/am/src/native/cte.c	/^int _cte_init(_Context*(*handler)(_Event, _Context*)) {$/;"	f	signature:(_Event, _Context*)
has_preferred_x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon34	access:public
hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    unsigned int hash() const;$/;"	p	class:N_puzzle	access:public	signature:() const
hash	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^unsigned int N_puzzle<N>::hash() const {$/;"	f	class:N_puzzle	signature:() const
hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		qlz_hash_decompress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon10	access:public
hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		qlz_hash_decompress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon9	access:public
hash	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	qlz_hash_compress hash[QLZ_HASH_VALUES];$/;"	m	struct:__anon8	access:public
hash_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char hash_counter[QLZ_HASH_VALUES];$/;"	m	struct:__anon9	access:public
hash_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	unsigned char hash_counter[QLZ_HASH_VALUES];$/;"	m	struct:__anon8	access:public
hash_func	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline ui32 hash_func(ui32 i)$/;"	f	file:	signature:(ui32 i)
hash_table	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *hash_table[M];$/;"	m	class:Updatable_heap	access:private
hash_value	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int hash_value;$/;"	m	class:N_puzzle	access:private
hashat	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline ui32 hashat(const unsigned char *src)$/;"	f	file:	signature:(const unsigned char *src)
hbrk	abstract-machine/apps/microbench/src/bench.c	/^static char *hbrk;$/;"	v	file:
head	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int head[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
head	abstract-machine/apps/typing/game.c	/^static fly_t head = NULL;$/;"	v	file:
head	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
head	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk	access:public
heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *heap[M + 1];$/;"	m	class:Updatable_heap	access:private
heap_index	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int heap_index;$/;"	m	class:Updatable_heap::Step	access:public
heap_init	abstract-machine/am/src/x86/qemu/trm.c	/^static void heap_init() {$/;"	f	file:
heap_init	abstract-machine/am/src/x86/qemu/trm.c	/^static void heap_init();$/;"	p	file:
heap_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int heap_size;$/;"	m	class:Updatable_heap	access:private
height	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t height;$/;"	m	struct:VBEInfo	file:	access:public
height	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int height;$/;"	m	struct:stbrp_context	access:public
height	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon36	access:public
height	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context	access:public
height	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon57	access:public
heuristic	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int heuristic;$/;"	m	struct:stbrp_context	access:public
hhea	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
hi	abstract-machine/libs/fixmath/include/int64.h	/^	 int32_t hi;$/;"	m	struct:__anon31	access:public
high	abstract-machine/libs/compiler-rt/int_types.h	/^        di_int high;$/;"	m	struct:__anon20::__anon21	access:public
high	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int high;$/;"	m	struct:__anon22::__anon23	access:public
high	abstract-machine/libs/compiler-rt/int_types.h	/^        si_int high;$/;"	m	struct:__anon16::__anon17	access:public
high	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int high;$/;"	m	struct:__anon18::__anon19	access:public
high	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords high;$/;"	m	struct:__anon26	access:public
hit	abstract-machine/apps/typing/game.c	/^static int hit = 0, miss = 0;$/;"	v	file:
hlt	abstract-machine/am/include/x86.h	/^static inline void hlt() {$/;"	f	signature:()
hlt	abstract-machine/am/src/x86/qemu/boot/main.c	/^static inline void hlt() {$/;"	f	file:
hmtx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
id	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int            id;$/;"	m	struct:stbrp_rect	access:public
id	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
idt	abstract-machine/am/src/x86/qemu/cte.c	/^static GateDesc idt[NR_IRQ];$/;"	v	file:
idx	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16 idx;$/;"	m	struct:list_data_s	access:public
if_V	pstree/pstree.c	/^bool if_n = 0, if_p = 0, if_V = 0;$/;"	v
if_n	pstree/pstree.c	/^bool if_n = 0, if_p = 0, if_V = 0;$/;"	v
if_p	pstree/pstree.c	/^bool if_n = 0, if_p = 0, if_V = 0;$/;"	v
image	abstract-machine/apps/slider/image.S	/^image:$/;"	l
image	abstract-machine/apps/slider/main.cpp	/^extern uint32_t image[][400][300];$/;"	x
image_end	abstract-machine/apps/slider/image.S	/^image_end:$/;"	l
image_end	abstract-machine/apps/slider/main.cpp	/^extern uint32_t image_end[][400][300];$/;"	x
image_pages	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t image_pages;$/;"	m	struct:VBEInfo	file:	access:public
imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { double real, imaginary; } Dcomplex;$/;"	m	struct:__anon29	access:public
imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { float real, imaginary; } Fcomplex;$/;"	m	struct:__anon28	access:public
imaginary	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { long double real, imaginary; } Lcomplex;$/;"	m	struct:__anon30	access:public
imcrp	abstract-machine/am/include/x86.h	/^  uint8_t imcrp;$/;"	m	struct:MPDesc	access:public
in_byte	abstract-machine/am/src/x86/qemu/boot/main.c	/^static inline char in_byte(short port) {$/;"	f	file:	signature:(short port)
in_long	abstract-machine/am/src/x86/qemu/boot/main.c	/^static inline int in_long(short port) {$/;"	f	file:	signature:(short port)
in_range	abstract-machine/am/src/x86/x86-qemu.h	/^static inline int in_range(void *ptr, _Area area) {$/;"	f	signature:(void *ptr, _Area area)
inb	abstract-machine/am/include/x86.h	/^static inline uint8_t inb(int port) {$/;"	f	signature:(int port)
indexToLocFormat	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo	access:public
index_map	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo	access:public
ines_header	abstract-machine/apps/litenes/src/fce.c	/^} ines_header;$/;"	t	typeref:struct:__anon1	file:
info	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_data_s *info;$/;"	m	struct:list_head_s	typeref:struct:list_head_s::list_data_s	access:public
init	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void init( T const &, Step *, int, int );$/;"	p	class:Updatable_heap::Step	access:public	signature:( T const &, Step *, int, int )
init	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void init(); $/;"	p	class:Updatable_heap	access:public	signature:()
init	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::Step::init( T const &pz, Step *n, int hi, int dist ) {$/;"	f	class:Updatable_heap::Step	signature:( T const &pz, Step *n, int hi, int dist )
init	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::init() {$/;"	f	class:Updatable_heap	signature:()
init	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  void init(int n) {$/;"	f	struct:Dinic	access:public	signature:(int n)
init_mode	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int init_mode;$/;"	m	struct:stbrp_context	access:public
init_platform	abstract-machine/am/src/native/platform.cpp	/^static void init_platform() {$/;"	f	file:	signature:()
init_screen	amgame/src/game.c	/^void init_screen() {$/;"	f
init_screen	amgame/src/game.c	/^void init_screen();$/;"	p	file:
initialized	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon34	access:public
inl	abstract-machine/am/include/x86.h	/^static inline uint32_t inl(int port) {$/;"	f	signature:(int port)
input	abstract-machine/apps/microbench/src/bf/bf.c	/^static char *input;$/;"	v	file:
input_init	abstract-machine/am/src/native/devices/input.c	/^void input_init() {$/;"	f
input_init	abstract-machine/am/src/native/ioe.c	/^void input_init();$/;"	p	file:
input_read	abstract-machine/am/src/native/devices/input.c	/^size_t input_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
input_read	abstract-machine/am/src/native/ioe.c	/^size_t input_read(uintptr_t reg, void *buf, size_t size);$/;"	p	file:	signature:(uintptr_t reg, void *buf, size_t size)
input_read	abstract-machine/am/src/x86/qemu/devices/input.c	/^size_t input_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
input_read	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(input_read);$/;"	v
insert	abstract-machine/libs/imgui/include/imgui.h	/^    inline iterator             insert(const_iterator it, const value_type& v)  { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(Capacity ? Capacity * 2 : 4); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); Data[off] = v; Size++; return Data + off; }$/;"	f	class:ImVector	access:public	signature:(const_iterator it, const value_type& v)
insert_length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short           insert_length;$/;"	m	struct:__anon32	access:public
insert_mode	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon34	access:public
instruction_t	abstract-machine/apps/microbench/src/bf/bf.c	/^struct instruction_t {$/;"	s	file:
instruction_t::operand	abstract-machine/apps/microbench/src/bf/bf.c	/^  unsigned short operand;$/;"	m	struct:instruction_t	file:	access:public
instruction_t::operator	abstract-machine/apps/microbench/src/bf/bf.c	/^  unsigned short operator;$/;"	m	struct:instruction_t	file:	access:public
int64_add	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_add(__int64_t x, __int64_t y) {$/;"	f	signature:(__int64_t x, __int64_t y)
int64_add	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_add(int64_t x, int64_t y)   { return (x + y);  }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_eq	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_eq(__int64_t x, __int64_t y) { return ((x.hi == y.hi) && (x.lo == y.lo)); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_eq	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_eq(int64_t x, int64_t y) { return (x == y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_ge	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_ge(__int64_t x, __int64_t y) { return ((x.hi > y.hi) || ((x.hi == y.hi) && (x.lo >= y.lo))); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_ge	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_ge(int64_t x, int64_t y) { return (x >= y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_gt	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_gt(__int64_t x, __int64_t y) { return ((x.hi > y.hi) || ((x.hi == y.hi) && (x.lo >  y.lo))); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_gt	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_gt(int64_t x, int64_t y) { return (x >  y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_le	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_le(__int64_t x, __int64_t y) { return ((x.hi < y.hi) || ((x.hi == y.hi) && (x.lo <= y.lo))); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_le	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_le(int64_t x, int64_t y) { return (x <= y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_lt	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_lt(__int64_t x, __int64_t y) { return ((x.hi < y.hi) || ((x.hi == y.hi) && (x.lo <  y.lo))); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_lt	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_lt(int64_t x, int64_t y) { return (x <  y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_cmp_ne	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_ne(__int64_t x, __int64_t y) { return ((x.hi != y.hi) || (x.lo != y.lo)); }$/;"	f	signature:(__int64_t x, __int64_t y)
int64_cmp_ne	abstract-machine/libs/fixmath/include/int64.h	/^static inline int int64_cmp_ne(int64_t x, int64_t y) { return (x != y); }$/;"	f	signature:(int64_t x, int64_t y)
int64_const	abstract-machine/libs/fixmath/include/int64.h	/^static inline  int64_t int64_const(int32_t hi, uint32_t lo) { return (((int64_t)hi << 32) | lo); }$/;"	f	signature:(int32_t hi, uint32_t lo)
int64_const	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_const(int32_t hi, uint32_t lo) { return (__int64_t){ hi, lo }; }$/;"	f	signature:(int32_t hi, uint32_t lo)
int64_div_i64_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_div_i64_i32(__int64_t x, int32_t y) {$/;"	f	signature:(__int64_t x, int32_t y)
int64_div_i64_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_div_i64_i32(int64_t x, int32_t y) { return (x \/ y);  }$/;"	f	signature:(int64_t x, int32_t y)
int64_from_int32	abstract-machine/libs/fixmath/include/int64.h	/^static inline  int64_t int64_from_int32(int32_t x) { return (int64_t)x; }$/;"	f	signature:(int32_t x)
int64_from_int32	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_from_int32(int32_t x) { return (__int64_t){ (x < 0 ? -1 : 0), x }; }$/;"	f	signature:(int32_t x)
int64_hi	abstract-machine/libs/fixmath/include/int64.h	/^static inline   int32_t int64_hi(__int64_t x) { return x.hi; }$/;"	f	signature:(__int64_t x)
int64_hi	abstract-machine/libs/fixmath/include/int64.h	/^static inline  int32_t int64_hi(int64_t x) { return (x >> 32); }$/;"	f	signature:(int64_t x)
int64_lo	abstract-machine/libs/fixmath/include/int64.h	/^static inline  uint32_t int64_lo(__int64_t x) { return x.lo; }$/;"	f	signature:(__int64_t x)
int64_lo	abstract-machine/libs/fixmath/include/int64.h	/^static inline uint32_t int64_lo(int64_t x) { return (x & ((1ULL << 32) - 1)); }$/;"	f	signature:(int64_t x)
int64_mul_i32_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_mul_i32_i32(int32_t x, int32_t y) {$/;"	f	signature:(int32_t x, int32_t y)
int64_mul_i32_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_mul_i32_i32(int32_t x, int32_t y) { return (x * y);  }$/;"	f	signature:(int32_t x, int32_t y)
int64_mul_i64_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_mul_i64_i32(__int64_t x, int32_t y) {$/;"	f	signature:(__int64_t x, int32_t y)
int64_mul_i64_i32	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_mul_i64_i32(int64_t x, int32_t y) { return (x * y);  }$/;"	f	signature:(int64_t x, int32_t y)
int64_neg	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_neg(__int64_t x) {$/;"	f	signature:(__int64_t x)
int64_neg	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_neg(int64_t x)              { return (-x);     }$/;"	f	signature:(int64_t x)
int64_shift	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_shift(__int64_t x, int8_t y) {$/;"	f	signature:(__int64_t x, int8_t y)
int64_shift	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_shift(int64_t x, int8_t y)  { return (y < 0 ? (x >> -y) : (x << y)); }$/;"	f	signature:(int64_t x, int8_t y)
int64_sub	abstract-machine/libs/fixmath/include/int64.h	/^static inline __int64_t int64_sub(__int64_t x, __int64_t y) {$/;"	f	signature:(__int64_t x, __int64_t y)
int64_sub	abstract-machine/libs/fixmath/include/int64.h	/^static inline int64_t int64_sub(int64_t x, int64_t y)   { return (x - y);  }$/;"	f	signature:(int64_t x, int64_t y)
int64_t	abstract-machine/libs/fixmath/include/int64.h	154;"	d
int_shl	abstract-machine/apps/litenes/src/ppu.c	/^static inline uint64_t int_shl(int n, int s) {$/;"	f	file:	signature:(int n, int s)
interrupt_bp	abstract-machine/apps/litenes/include/cpu.h	/^    interrupt_bp  = 2,$/;"	e	enum:__anon4
interrupt_flag	abstract-machine/apps/litenes/include/cpu.h	/^    interrupt_flag = 0x04,$/;"	e	enum:__anon3
intpat	abstract-machine/apps/coremark/src/core_state.c	/^static ee_u8 *intpat[4]  ={(ee_u8 *)"5012",(ee_u8 *)"1234",(ee_u8 *)"-874",(ee_u8 *)"+122"};$/;"	v	file:
intr_read	abstract-machine/am/src/x86/qemu/cte.c	/^int intr_read() {$/;"	f
intr_write	abstract-machine/am/src/x86/qemu/cte.c	/^void intr_write(int enable) {$/;"	f	signature:(int enable)
invert	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge	access:public
inw	abstract-machine/am/include/x86.h	/^static inline uint32_t inw(int port) {$/;"	f	signature:(int port)
ioapic	abstract-machine/am/src/x86/qemu/devices/apic.c	/^static volatile IOAPIC *ioapic;$/;"	v	file:
ioapic_enable	abstract-machine/am/src/x86/qemu/devices/apic.c	/^ioapic_enable(int irq, int cpunum)$/;"	f	signature:(int irq, int cpunum)
ioapic_enable	abstract-machine/am/src/x86/x86-qemu.h	/^void ioapic_enable(int irq, int cpu);$/;"	p	signature:(int irq, int cpu)
ioapic_init	abstract-machine/am/src/x86/qemu/devices/apic.c	/^ioapic_init(void)$/;"	f	signature:(void)
ioapic_init	abstract-machine/am/src/x86/x86-qemu.h	/^void ioapic_init();$/;"	p	signature:()
ioapicread	abstract-machine/am/src/x86/qemu/devices/apic.c	/^ioapicread(int reg)$/;"	f	file:	signature:(int reg)
ioapicwrite	abstract-machine/am/src/x86/qemu/devices/apic.c	/^ioapicwrite(int reg, unsigned int data)$/;"	f	file:	signature:(int reg, unsigned int data)
irq	abstract-machine/am/include/x86.h	/^  int32_t  irq;                  \/\/ # of irq$/;"	m	struct:TrapFrame	access:public
irq_handle	abstract-machine/am/src/native/cte.c	/^void irq_handle(_Context *c) {$/;"	f	signature:(_Context *c)
irq_handle	abstract-machine/am/src/x86/qemu/cte.c	/^void irq_handle(TrapFrame *tf) {$/;"	f	signature:(TrapFrame *tf)
is_ap	abstract-machine/am/src/x86/qemu/boot/main.c	/^  int is_ap;$/;"	m	struct:boot_info	file:	access:public
is_ap	abstract-machine/am/src/x86/x86-qemu.h	/^  int is_ap;$/;"	m	struct:boot_info	access:public
is_blank	abstract-machine/libs/imgui/include/imgui.h	/^        static bool is_blank(char c) { return c == ' ' || c == '\\t'; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:(char c)
is_mapped	abstract-machine/am/src/native/vme.c	/^  int is_mapped;$/;"	m	struct:PageMap	file:	access:public
is_separator	abstract-machine/libs/imgui/src/imgui.cpp	/^static bool is_separator(unsigned int c)                                        { return ImCharIsSpace(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	namespace:ImGuiStb	signature:(unsigned int c)
is_word_boundary	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )$/;"	f	signature:( STB_TEXTEDIT_STRING *str, int idx )
is_word_boundary_from_left	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->Text[idx-1] ) && is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
is_word_boundary_from_right	abstract-machine/libs/imgui/src/imgui.cpp	/^static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->Text[idx-1] ) && !is_separator( obj->Text[idx] ) ) : 1; }$/;"	f	namespace:ImGuiStb	signature:(STB_TEXTEDIT_STRING* obj, int idx)
iterate	abstract-machine/apps/coremark/include/coremark.h	/^void *iterate(void *pres);$/;"	p	signature:(void *pres)
iterate	abstract-machine/apps/coremark/src/core_main.c	/^void *iterate(void *pres) {$/;"	f	signature:(void *pres)
iterations	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32 iterations;		\/* Number of iterations to execute *\/$/;"	m	struct:RESULTS_S	access:public
iterator	abstract-machine/libs/imgui/include/imgui.h	/^    typedef value_type*         iterator;$/;"	t	class:ImVector	access:public
itoa	abstract-machine/apps/typing/draw.c	/^char *itoa(int n)  {  $/;"	f	signature:(int n)
itoa_loop	abstract-machine/libs/fixmath/src/fix16_str.c	/^static char *itoa_loop(char *buf, uint32_t scale, uint32_t value, bool skip)$/;"	f	file:	signature:(char *buf, uint32_t scale, uint32_t value, bool skip)
jump_to	abstract-machine/am/src/x86/qemu/mpe.c	/^static void jump_to(void (*entry)()) {$/;"	f	file:	signature:(void (*entry)())
jump_to	abstract-machine/am/src/x86/qemu/mpe.c	/^static void jump_to(void (*entry)());$/;"	p	file:	signature:(void (*entry)())
k	abstract-machine/apps/microbench/src/md5/md5.c	/^const uint32_t k[64] = {$/;"	v
kalloc	abstract-machine/libs/imgui/include/imconfig.h	/^void* kalloc(size_t);$/;"	p	signature:(size_t)
kcontext	abstract-machine/am/src/x86/qemu/cte.c	/^_Context *kcontext(_Area stack, void (*entry)(void *), void *arg) {$/;"	f	signature:(_Area stack, void (*entry)(void *), void *arg)
kern	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
key	abstract-machine/libs/imgui/include/imgui.h	/^        ImGuiID key;$/;"	m	struct:ImGuiStorage::Pair	access:public
key_code	abstract-machine/apps/typing/keyboard.c	/^static int key_code = 0;$/;"	v	file:
key_f	abstract-machine/am/src/native/devices/input.c	/^static int key_f = 0, key_r = 0;$/;"	v	file:
key_queue	abstract-machine/am/src/native/devices/input.c	/^static int key_queue[KEY_QUEUE_LEN];$/;"	v	file:
key_queue_lock	abstract-machine/am/src/native/devices/input.c	/^static SDL_mutex *key_queue_lock;$/;"	v	file:
key_r	abstract-machine/am/src/native/devices/input.c	/^static int key_f = 0, key_r = 0;$/;"	v	file:
key_state	abstract-machine/apps/litenes/src/fce.c	/^int key_state[256];$/;"	v
key_state	abstract-machine/apps/litenes/src/psg.c	/^extern int key_state[];$/;"	x
keyboard_event	abstract-machine/apps/typing/game.h	/^bool keyboard_event();$/;"	p	signature:()
keyboard_event	abstract-machine/apps/typing/keyboard.c	/^bool keyboard_event() {$/;"	f
keymap	abstract-machine/am/src/native/devices/input.c	/^static int keymap[256] = {$/;"	v	file:
kfree	abstract-machine/libs/imgui/include/imconfig.h	/^void kfree(void*);$/;"	p	signature:(void*)
kpt	abstract-machine/am/src/x86/qemu/vme.c	/^static PDE *kpt;$/;"	v	file:
lapic	abstract-machine/am/src/x86/qemu/devices/apic.c	/^volatile unsigned int *lapic;  \/\/ Initialized in mp.c$/;"	v
lapic	abstract-machine/am/src/x86/x86-qemu.h	/^extern volatile uint32_t *lapic;$/;"	x
lapic_bootap	abstract-machine/am/src/x86/qemu/devices/apic.c	/^lapic_bootap(unsigned int apicid, unsigned int addr)$/;"	f	signature:(unsigned int apicid, unsigned int addr)
lapic_bootap	abstract-machine/am/src/x86/x86-qemu.h	/^void lapic_bootap(unsigned int cpu, uint32_t address);$/;"	p	signature:(unsigned int cpu, uint32_t address)
lapic_eoi	abstract-machine/am/src/x86/qemu/devices/apic.c	/^lapic_eoi(void)$/;"	f	signature:(void)
lapic_eoi	abstract-machine/am/src/x86/x86-qemu.h	/^void lapic_eoi();$/;"	p	signature:()
lapicaddr	abstract-machine/am/include/x86.h	/^  uint32_t *lapicaddr;     \/\/ address of local APIC$/;"	m	struct:MPConf	access:public
lapicw	abstract-machine/am/src/x86/qemu/devices/apic.c	/^lapicw(int index, int value)$/;"	f	file:	signature:(int index, int value)
last_key_code	abstract-machine/apps/typing/game.h	/^int last_key_code(void);$/;"	p	signature:(void)
last_key_code	abstract-machine/apps/typing/keyboard.c	/^int last_key_code(void) {$/;"	f	signature:(void)
len	abstract-machine/apps/microbench/src/lzip/lzip.c	/^static int len;$/;"	v	file:
len	pstree/pstree.c	/^int len(int num){$/;"	f	signature:(int num)
length	abstract-machine/am/include/x86.h	/^  uint16_t length;         \/\/ total table length$/;"	m	struct:MPConf	access:public
length	abstract-machine/am/include/x86.h	/^  uint8_t length;   \/\/ 1$/;"	m	struct:MPDesc	access:public
length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int length( T const & ) const;$/;"	p	class:Updatable_heap	access:public	signature:( T const & ) const
length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int length() const;$/;"	p	class:Updatable_heap::Step	access:public	signature:() const
length	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::Step::length() const {$/;"	f	class:Updatable_heap::Step	signature:() const
length	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::length( T const &pz ) const {$/;"	f	class:Updatable_heap	signature:( T const &pz ) const
length	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon36	access:public
leq	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^inline bool leq(int a1, int a2,   int b1, int b2) { \/\/ lexic. order for pairs$/;"	f	signature:(int a1, int a2, int b1, int b2)
leq	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^inline bool leq(int a1, int a2, int a3,   int b1, int b2, int b3) {$/;"	f	signature:(int a1, int a2, int a3, int b1, int b2, int b3)
letter_code	abstract-machine/apps/typing/keyboard.c	/^static int letter_code[] = {$/;"	v	file:
letter_pressed	abstract-machine/apps/typing/keyboard.c	/^static bool letter_pressed[26];$/;"	v	file:
lim_15_0	abstract-machine/am/include/x86.h	/^  uint32_t lim_15_0 : 16;  \/\/ Low bits of segment limit$/;"	m	struct:SegDesc	access:public
lim_19_16	abstract-machine/am/include/x86.h	/^  uint32_t lim_19_16 : 4;  \/\/ High bits of segment limit$/;"	m	struct:SegDesc	access:public
line	pstree/pstree.c	/^int line[100] = {};$/;"	v
link	abstract-machine/am/include/x86.h	/^  uint32_t link;     \/\/ Unused$/;"	m	struct:TSS	access:public
list	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_head_s *list;$/;"	m	struct:RESULTS_S	typeref:struct:RESULTS_S::list_head_s	access:public
list_cmp	abstract-machine/apps/coremark/src/core_list_join.c	/^typedef ee_s32(*list_cmp)(list_data *a, list_data *b, core_results *res);$/;"	t	file:
list_data	abstract-machine/apps/coremark/include/coremark.h	/^} list_data;$/;"	t	typeref:struct:list_data_s
list_data_s	abstract-machine/apps/coremark/include/coremark.h	/^typedef struct list_data_s {$/;"	s
list_data_s::data16	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16 data16;$/;"	m	struct:list_data_s	access:public
list_data_s::idx	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16 idx;$/;"	m	struct:list_data_s	access:public
list_foreach	abstract-machine/am/src/native/vme.c	15;"	d	file:
list_head	abstract-machine/apps/coremark/include/coremark.h	/^} list_head;$/;"	t	typeref:struct:list_head_s
list_head_s	abstract-machine/apps/coremark/include/coremark.h	/^typedef struct list_head_s {$/;"	s
list_head_s::info	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_data_s *info;$/;"	m	struct:list_head_s	typeref:struct:list_head_s::list_data_s	access:public
list_head_s::next	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_head_s *next;$/;"	m	struct:list_head_s	typeref:struct:list_head_s::list_head_s	access:public
list_known_crc	abstract-machine/apps/coremark/src/core_main.c	/^static ee_u16 list_known_crc[]   =      {(ee_u16)0xd4b0,(ee_u16)0x3340,(ee_u16)0x6a79,(ee_u16)0xe714,(ee_u16)0xe3c1};$/;"	v	file:
lo	abstract-machine/libs/fixmath/include/int64.h	/^	uint32_t lo;$/;"	m	struct:__anon31	access:public
loca	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
log	abstract-machine/apps/litenes/include/common.h	15;"	d
log_byte	abstract-machine/am/src/x86/qemu/trace.c	/^static inline void log_byte(uint8_t ch) {$/;"	f	file:	signature:(uint8_t ch)
log_ev	abstract-machine/am/src/x86/qemu/trace.c	/^static inline void log_ev(_TraceEvent ev, int length, void *ptr) {$/;"	f	file:	signature:(_TraceEvent ev, int length, void *ptr)
long_double_bits	abstract-machine/libs/compiler-rt/int_types.h	/^} long_double_bits;$/;"	t	typeref:union:__anon27
low	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int low;$/;"	m	struct:__anon20::__anon21	access:public
low	abstract-machine/libs/compiler-rt/int_types.h	/^        du_int low;$/;"	m	struct:__anon22::__anon23	access:public
low	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int low;$/;"	m	struct:__anon16::__anon17	access:public
low	abstract-machine/libs/compiler-rt/int_types.h	/^        su_int low;$/;"	m	struct:__anon18::__anon19	access:public
low	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords low;$/;"	m	struct:__anon26	access:public
lower_bound	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int lower_bound() const;$/;"	p	class:N_puzzle	access:public	signature:() const
lower_bound	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^int N_puzzle<N>::lower_bound() const {$/;"	f	class:N_puzzle	signature:() const
m	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
machine	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t machine;$/;"	m	struct:ELFHeader	file:	access:public
magic	abstract-machine/am/include/x86.h	/^  int     magic;$/;"	m	struct:MPDesc	access:public
magic	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t magic;$/;"	m	struct:ELFHeader	file:	access:public
main	abstract-machine/am/src/x86/qemu/trm.c	/^int main();$/;"	p	file:
main	abstract-machine/apps/coremark/src/core_main.c	/^MAIN_RETURN_TYPE main(void) {$/;"	f	signature:(void)
main	abstract-machine/apps/dhrystone/dry.c	/^int main ()$/;"	f
main	abstract-machine/apps/hello/hello.c	/^int main() {$/;"	f
main	abstract-machine/apps/litenes/src/fce.c	/^int main() {$/;"	f
main	abstract-machine/apps/microbench/src/bench.c	/^int main() {$/;"	f
main	abstract-machine/apps/slider/main.cpp	/^int main() {$/;"	f	signature:()
main	abstract-machine/apps/typing/game.c	/^int main (){$/;"	f
main	abstract-machine/libs/imgui/include/stb_truetype.h	/^int main(int argc, char **argv)$/;"	f	signature:(int argc, char **argv)
main	amgame/src/game.c	/^int main() {$/;"	f
main	pstree/pstree.c	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
make_ti	abstract-machine/libs/compiler-rt/int_types.h	/^static __inline ti_int make_ti(di_int h, di_int l) {$/;"	f	signature:(di_int h, di_int l)
make_tu	abstract-machine/libs/compiler-rt/int_types.h	/^static __inline tu_int make_tu(du_int h, du_int l) {$/;"	f	signature:(du_int h, du_int l)
manhattan_distance	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int8_t manhattan_distance;$/;"	m	class:N_puzzle	access:private
map	abstract-machine/am/src/x86/qemu/vme.c	/^int map(_AddressSpace *p, void *va, void *pa, int prot) {$/;"	f	signature:(_AddressSpace *p, void *va, void *pa, int prot)
mat	abstract-machine/apps/coremark/include/coremark.h	/^	mat_params mat;$/;"	m	struct:RESULTS_S	access:public
mat_params	abstract-machine/apps/coremark/include/coremark.h	/^} mat_params;$/;"	t	typeref:struct:MAT_PARAMS_S
matrix_add_const	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val) {$/;"	f	signature:(ee_u32 N, MATDAT *A, MATDAT val)
matrix_add_const	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_add_const(ee_u32 N, MATDAT *A, MATDAT val);$/;"	p	file:	signature:(ee_u32 N, MATDAT *A, MATDAT val)
matrix_big	abstract-machine/apps/coremark/src/core_matrix.c	46;"	d	file:
matrix_clip	abstract-machine/apps/coremark/src/core_matrix.c	45;"	d	file:
matrix_known_crc	abstract-machine/apps/coremark/src/core_main.c	/^static ee_u16 matrix_known_crc[] =      {(ee_u16)0xbe52,(ee_u16)0x1199,(ee_u16)0x5608,(ee_u16)0x1fd7,(ee_u16)0x0747};$/;"	v	file:
matrix_mul_const	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val)
matrix_mul_const	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_const(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT val)
matrix_mul_matrix	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_mul_matrix	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_matrix(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_mul_matrix_bitextract	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_mul_matrix_bitextract	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_matrix_bitextract(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_mul_vect	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_mul_vect	abstract-machine/apps/coremark/src/core_matrix.c	/^void matrix_mul_vect(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B)
matrix_sum	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_s16 matrix_sum(ee_u32 N, MATRES *C, MATDAT clipval) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT clipval)
matrix_sum	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_s16 matrix_sum(ee_u32 N, MATRES *C, MATDAT clipval);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT clipval)
matrix_test	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val) {$/;"	f	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val)
matrix_test	abstract-machine/apps/coremark/src/core_matrix.c	/^ee_s16 matrix_test(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val);$/;"	p	file:	signature:(ee_u32 N, MATRES *C, MATDAT *A, MATDAT *B, MATDAT val)
matrix_test_next	abstract-machine/apps/coremark/src/core_matrix.c	44;"	d	file:
max	abstract-machine/apps/microbench/src/15pz/heap.h	/^T max(T a, T b) {$/;"	f	signature:(T a, T b)
max_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
max_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
maximum_heap_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int maximum_heap_size;$/;"	m	class:Updatable_heap	access:private
maximum_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int maximum_size() const;$/;"	p	class:Updatable_heap	access:public	signature:() const
maximum_size	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::maximum_size() const {$/;"	f	class:Updatable_heap	signature:() const
md5	abstract-machine/apps/microbench/src/md5/md5.c	/^static void md5(uint8_t *msg, size_t initial_len, uint8_t *digest) {$/;"	f	file:	signature:(uint8_t *msg, size_t initial_len, uint8_t *digest)
mem_name	abstract-machine/apps/coremark/src/core_main.c	/^char *mem_name[3] = {"Static","Heap","Stack"};$/;"	v
memblock	abstract-machine/apps/coremark/include/coremark.h	/^	void	*memblock[4];	\/* Pointer to safe memory location *\/$/;"	m	struct:RESULTS_S	access:public
memcmp	abstract-machine/apps/litenes/include/common.h	/^static inline int memcmp(const void *dest, const void *src, size_t n) {$/;"	f	signature:(const void *dest, const void *src, size_t n)
memcmp	abstract-machine/libs/klib/include/klib.h	/^int memcmp(const void* s1, const void* s2, size_t n);$/;"	p	signature:(const void* s1, const void* s2, size_t n)
memcmp	abstract-machine/libs/klib/include/klib.h	22;"	d
memcmp	abstract-machine/libs/klib/src/string.c	/^int memcmp(const void* s1, const void* s2, size_t n){$/;"	f	signature:(const void* s1, const void* s2, size_t n)
memcpy	abstract-machine/apps/dhrystone/dry.c	/^memcpy (d, s, l)$/;"	f
memcpy	abstract-machine/apps/litenes/include/common.h	/^static inline void* memcpy(void *dest, const void *src, size_t n) {$/;"	f	signature:(void *dest, const void *src, size_t n)
memcpy	abstract-machine/libs/klib/include/klib.h	/^void* memcpy(void* dst, const void* src, size_t n);$/;"	p	signature:(void* dst, const void* src, size_t n)
memcpy	abstract-machine/libs/klib/include/klib.h	21;"	d
memcpy	abstract-machine/libs/klib/src/string.c	/^void* memcpy(void* out, const void* in, size_t n) {$/;"	f	signature:(void* out, const void* in, size_t n)
memcpy_up	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline void memcpy_up(unsigned char *dst, const unsigned char *src, ui32 n)$/;"	f	file:	signature:(unsigned char *dst, const unsigned char *src, ui32 n)
memory	abstract-machine/apps/dhrystone/dry.c	/^static char memory[1024];$/;"	v	file:
memory	abstract-machine/apps/litenes/src/mmc.c	/^byte memory[0x10000];$/;"	v
memory_model	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t memory_model;$/;"	m	struct:VBEInfo	file:	access:public
memory_readb	abstract-machine/apps/litenes/include/memory.h	/^static inline byte memory_readb(word address)$/;"	f	signature:(word address)
memory_readw	abstract-machine/apps/litenes/include/memory.h	/^static inline word memory_readw(word address)$/;"	f	signature:(word address)
memory_writeb	abstract-machine/apps/litenes/include/memory.h	/^static inline void memory_writeb(word address, byte data)$/;"	f	signature:(word address, byte data)
memory_writew	abstract-machine/apps/litenes/include/memory.h	/^static inline void memory_writew(word address, word data)$/;"	f	signature:(word address, word data)
memset	abstract-machine/libs/klib/include/klib.h	/^void* memset(void* v, int c, size_t n);$/;"	p	signature:(void* v, int c, size_t n)
memset	abstract-machine/libs/klib/include/klib.h	20;"	d
memset	abstract-machine/libs/klib/src/string.c	/^void* memset(void* v,int c,size_t n) {$/;"	f	signature:(void* v,int c,size_t n)
memsz	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t memsz;$/;"	m	struct:ProgramHeader	file:	access:public
microdelay	abstract-machine/am/src/x86/qemu/devices/apic.c	/^microdelay(int us)$/;"	f	file:	signature:(int us)
min	abstract-machine/am/src/native/devices/video.c	/^static inline int min(int x, int y) {$/;"	f	file:	signature:(int x, int y)
min	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^static inline T min(T x, T y) {$/;"	f	file:	signature:(T x, T y)
min_x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
min_y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon55	access:public
mirroring	abstract-machine/apps/litenes/include/ppu.h	/^    int mirroring, mirroring_xor;$/;"	m	struct:__anon2	access:public
mirroring_xor	abstract-machine/apps/litenes/include/ppu.h	/^    int mirroring, mirroring_xor;$/;"	m	struct:__anon2	access:public
miss	abstract-machine/apps/typing/game.c	/^static int hit = 0, miss = 0;$/;"	v	file:
mlim	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long mlim, ref;$/;"	m	struct:Setting	access:public
mmc_append_chr_rom_page	abstract-machine/apps/litenes/include/mmc.h	/^void mmc_append_chr_rom_page(byte *source);$/;"	p	signature:(byte *source)
mmc_append_chr_rom_page	abstract-machine/apps/litenes/src/mmc.c	/^inline void mmc_append_chr_rom_page(byte *source)$/;"	f	signature:(byte *source)
mmc_chr_pages	abstract-machine/apps/litenes/src/mmc.c	/^byte mmc_chr_pages[MMC_MAX_PAGE_COUNT][0x2000];$/;"	v
mmc_chr_pages_number	abstract-machine/apps/litenes/src/mmc.c	/^int mmc_chr_pages_number;$/;"	v
mmc_copy	abstract-machine/apps/litenes/include/mmc.h	/^void mmc_copy(word address, byte *source, int length);$/;"	p	signature:(word address, byte *source, int length)
mmc_copy	abstract-machine/apps/litenes/src/mmc.c	/^inline void mmc_copy(word address, byte *source, int length)$/;"	f	signature:(word address, byte *source, int length)
mmc_id	abstract-machine/apps/litenes/include/mmc.h	/^extern byte mmc_id;$/;"	x
mmc_id	abstract-machine/apps/litenes/src/mmc.c	/^byte mmc_id;$/;"	v
mmc_read	abstract-machine/apps/litenes/include/mmc.h	/^byte mmc_read(word address);$/;"	p	signature:(word address)
mmc_read	abstract-machine/apps/litenes/src/mmc.c	/^inline byte mmc_read(word address)$/;"	f	signature:(word address)
mmc_write	abstract-machine/apps/litenes/include/mmc.h	/^void mmc_write(word address, byte data);$/;"	p	signature:(word address, byte data)
mmc_write	abstract-machine/apps/litenes/src/mmc.c	/^inline void mmc_write(word address, byte data)$/;"	f	signature:(word address, byte data)
msec	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long tsc, msec;$/;"	m	struct:Result	access:public
msg	abstract-machine/am/am.h	/^  const char *msg;$/;"	m	struct:_Event	access:public
mult	abstract-machine/apps/microbench/src/fib/fib.c	/^static inline void mult(uint32_t *c, uint32_t *a, uint32_t *b) {$/;"	f	file:	signature:(uint32_t *c, uint32_t *a, uint32_t *b)
my_stbtt_initfont	abstract-machine/libs/imgui/include/stb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f	signature:(void)
my_stbtt_print	abstract-machine/libs/imgui/include/stb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f	signature:(float x, float y, char *text)
myalloc	abstract-machine/apps/dhrystone/dry.c	/^static char* myalloc(size_t size) {$/;"	f	file:	signature:(size_t size)
myqsort	abstract-machine/apps/microbench/src/qsort/qsort.c	/^static void myqsort(int *a, int l, int r) {$/;"	f	file:	signature:(int *a, int l, int r)
n	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
name	abstract-machine/apps/microbench/include/benchmark.h	/^  const char *name, *desc;$/;"	m	struct:Benchmark	access:public
ncpu	abstract-machine/am/src/x86/qemu/mpe.c	/^int ncpu = 0;$/;"	v
ncpu	abstract-machine/am/src/x86/x86-qemu.h	/^extern int ncpu;$/;"	x
negative_bp	abstract-machine/apps/litenes/include/cpu.h	/^    negative_bp   = 7$/;"	e	enum:__anon4
negative_flag	abstract-machine/apps/litenes/include/cpu.h	/^    negative_flag  = 0x80$/;"	e	enum:__anon3
next	abstract-machine/am/src/native/vme.c	/^  struct PageMap *next;$/;"	m	struct:PageMap	typeref:struct:PageMap::PageMap	file:	access:public
next	abstract-machine/apps/coremark/include/coremark.h	/^	struct list_head_s *next;$/;"	m	struct:list_head_s	typeref:struct:list_head_s::list_head_s	access:public
next	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *next;$/;"	m	class:Updatable_heap::Step	access:public
next	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node	access:public
next	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge	access:public
next	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk	access:public
next	abstract-machine/libs/klib/src/stdlib.c	/^static unsigned long int next = 1;$/;"	v	file:
nodes	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context	access:public
noutput	abstract-machine/apps/microbench/src/bf/bf.c	/^static int noutput;$/;"	v	file:
numGlyphs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo	access:public
num_chars	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon35	access:public
num_chars	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon45	access:public
num_nodes	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context	access:public
num_of_son	pstree/pstree.c	/^    int num_of_son;$/;"	m	struct:PROC	file:	access:public
num_remaining_in_head_chunk	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap	access:public
num_vertices	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int num_vertices;$/;"	m	struct:__anon55	access:public
nxt	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int nxt[MAXM];$/;"	m	struct:Dinic	file:	access:public
oemlength	abstract-machine/am/include/x86.h	/^  uint16_t oemlength;      \/\/ OEM table length$/;"	m	struct:MPConf	access:public
oemtable	abstract-machine/am/include/x86.h	/^  uint32_t *oemtable;      \/\/ OEM table pointer$/;"	m	struct:MPConf	access:public
off	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t off;$/;"	m	struct:ProgramHeader	file:	access:public
off_15_0	abstract-machine/am/include/x86.h	/^  uint32_t off_15_0 : 16;   \/\/ Low 16 bits of offset in segment$/;"	m	struct:GateDesc	access:public
off_31_16	abstract-machine/am/include/x86.h	/^  uint32_t off_31_16 : 16;  \/\/ High bits of offset in segment$/;"	m	struct:GateDesc	access:public
off_screen_mem_off	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t off_screen_mem_off;$/;"	m	struct:VBEInfo	file:	access:public
off_screen_mem_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t off_screen_mem_size;$/;"	m	struct:VBEInfo	file:	access:public
offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	const unsigned char *offset;$/;"	m	struct:__anon6	access:public
offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	const unsigned char *offset;$/;"	m	struct:__anon7	access:public
offset	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	unsigned int offset;$/;"	m	struct:__anon6	access:public
op_address	abstract-machine/apps/litenes/include/cpu.h	/^extern int op_value, op_address; \/\/ Arguments for current instruction$/;"	x
op_address	abstract-machine/apps/litenes/src/cpu.c	/^int op_value, op_address; \/\/ Arguments for current instruction$/;"	v
op_code	abstract-machine/apps/litenes/include/cpu.h	/^extern byte op_code;             \/\/ Current instruction code$/;"	x
op_code	abstract-machine/apps/litenes/src/cpu.c	/^byte op_code;             \/\/ Current instruction code$/;"	v
op_cycles	abstract-machine/apps/litenes/include/cpu.h	/^extern int op_cycles;            \/\/ Additional instruction cycles used (e.g. when paging occurs)$/;"	x
op_cycles	abstract-machine/apps/litenes/src/cpu.c	/^int op_cycles;            \/\/ Additional instruction cycles used (e.g. when paging occurs)$/;"	v
op_value	abstract-machine/apps/litenes/include/cpu.h	/^extern int op_value, op_address; \/\/ Arguments for current instruction$/;"	x
op_value	abstract-machine/apps/litenes/src/cpu.c	/^int op_value, op_address; \/\/ Arguments for current instruction$/;"	v
operand	abstract-machine/apps/microbench/src/bf/bf.c	/^  unsigned short operand;$/;"	m	struct:instruction_t	file:	access:public
operator	abstract-machine/apps/microbench/src/bf/bf.c	/^  unsigned short operator;$/;"	m	struct:instruction_t	file:	access:public
operator !=	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool operator!=( N_puzzle const & ) const;$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & ) const
operator !=	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::operator!=( N_puzzle const &rhs ) const {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs ) const
operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const Fix16 &other)  const { return (value != other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const double other)  const { return (value != fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const fix16_t other) const { return (value != other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const float other)   const { return (value != fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator !=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator!=(const int16_t other) const { return (value != fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const Fix16 &other) const  { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const double other) const  { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const fix16_t other) const { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const float other) const   { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator *	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator*(const int16_t other) const { Fix16 ret = *this; ret *= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator *	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator *	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }$/;"	f	signature:(const ImVec2& lhs, const float rhs)
operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const Fix16 &rhs)  { value = fix16_mul(value, rhs.value); return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const double rhs)  { value = fix16_mul(value, fix16_from_dbl(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const fix16_t rhs) { value = fix16_mul(value, rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const float rhs)   { value = fix16_mul(value, fix16_from_float(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
operator *=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator*=(const int16_t rhs) { value *= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
operator *=	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }$/;"	f	signature:(ImVec2& lhs, const float rhs)
operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const Fix16 &other) const  { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const double other) const  { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const fix16_t other) const { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const float other) const   { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator +	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator+(const int16_t other) const { Fix16 ret = *this; ret += other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator +	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const Fix16 &rhs)  { value += rhs.value;             return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const double rhs)  { value += fix16_from_dbl(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const fix16_t rhs) { value += rhs;                   return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const float rhs)   { value += fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
operator +=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator+=(const int16_t rhs) { value += fix16_from_int(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
operator +=	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }$/;"	f	signature:(ImVec2& lhs, const ImVec2& rhs)
operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const Fix16 &other) const  { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const double other) const  { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const fix16_t other) const { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const float other) const   { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator -	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator-(const int16_t other) const { Fix16 ret = *this; ret -= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator -	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator -	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }$/;"	f	signature:(const ImVec4& lhs, const ImVec4& rhs)
operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const Fix16 &rhs)  { value -= rhs.value; return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const double rhs)  { value -= fix16_from_dbl(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const fix16_t rhs) { value -= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const float rhs)   { value -= fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
operator -=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator-=(const int16_t rhs) { value -= fix16_from_int(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
operator -=	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }$/;"	f	signature:(ImVec2& lhs, const ImVec2& rhs)
operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const Fix16 &other) const  { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const double other) const  { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const fix16_t other) const { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const float other) const   { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator /	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 operator\/(const int16_t other) const { Fix16 ret = *this; ret \/= other; return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator /	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x\/rhs.x, lhs.y\/rhs.y); }$/;"	f	signature:(const ImVec2& lhs, const ImVec2& rhs)
operator /	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x\/rhs, lhs.y\/rhs); }$/;"	f	signature:(const ImVec2& lhs, const float rhs)
operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const Fix16 &rhs)  { value = fix16_div(value, rhs.value); return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const double rhs)  { value = fix16_div(value, fix16_from_dbl(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const fix16_t rhs) { value = fix16_div(value, rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const float rhs)   { value = fix16_div(value, fix16_from_float(rhs)); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
operator /=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator\/=(const int16_t rhs) { value \/= rhs; return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
operator /=	abstract-machine/libs/imgui/include/imgui_internal.h	/^static inline ImVec2& operator\/=(ImVec2& lhs, const float rhs)                  { lhs.x \/= rhs; lhs.y \/= rhs; return lhs; }$/;"	f	signature:(ImVec2& lhs, const float rhs)
operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const Fix16 &other)  const { return (value <  other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const double other)  const { return (value <  fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const fix16_t other) const { return (value <  other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const float other)   const { return (value <  fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator <	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator< (const int16_t other) const { return (value <  fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const Fix16 &other)  const { return (value <= other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const double other)  const { return (value <= fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const fix16_t other) const { return (value <= other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const float other)   const { return (value <= fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator <=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator<=(const int16_t other) const { return (value <= fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator =	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle &operator=( N_puzzle const & );$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & )
operator =	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> &N_puzzle<N>::operator=( N_puzzle const &rhs ) {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs )
operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const Fix16 &rhs)  { value = rhs.value;             return *this; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &rhs)
operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const double rhs)  { value = fix16_from_dbl(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const double rhs)
operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const fix16_t rhs) { value = rhs;                   return *this; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t rhs)
operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const float rhs)   { value = fix16_from_float(rhs); return *this; }$/;"	f	class:Fix16	access:public	signature:(const float rhs)
operator =	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 & operator=(const int16_t rhs) { value = fix16_from_int(rhs);   return *this; }$/;"	f	class:Fix16	access:public	signature:(const int16_t rhs)
operator ==	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool operator==( N_puzzle const & ) const;$/;"	p	class:N_puzzle	access:public	signature:( N_puzzle const & ) const
operator ==	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::operator==( N_puzzle const &rhs ) const {$/;"	f	class:N_puzzle	signature:( N_puzzle const &rhs ) const
operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const Fix16 &other)  const { return (value == other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const double other)  const { return (value == fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const fix16_t other) const { return (value == other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const float other)   const { return (value == fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator ==	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator==(const int16_t other) const { return (value == fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const Fix16 &other)  const { return (value >  other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const double other)  const { return (value >  fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const fix16_t other) const { return (value >  other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const float other)   const { return (value >  fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator >	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator> (const int16_t other) const { return (value >  fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const Fix16 &other)  const { return (value >= other.value);             }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const double other)  const { return (value >= fix16_from_dbl(other));   }$/;"	f	class:Fix16	access:public	signature:(const double other) const
operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const fix16_t other) const { return (value >= other);                   }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const float other)   const { return (value >= fix16_from_float(other)); }$/;"	f	class:Fix16	access:public	signature:(const float other) const
operator >=	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const int operator>=(const int16_t other) const { return (value >= fix16_from_int(other));   }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
operator ImU32	abstract-machine/libs/imgui/include/imgui.h	/^    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor	access:public	signature:() const
operator ImVec4	abstract-machine/libs/imgui/include/imgui.h	/^    inline operator ImVec4() const                                  { return Value; }$/;"	f	struct:ImColor	access:public	signature:() const
operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline char         operator[](int i) { return Buf.Data[i]; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:(int i)
operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline const value_type&    operator[](int i) const         { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i) const
operator []	abstract-machine/libs/imgui/include/imgui.h	/^    inline value_type&          operator[](int i)               { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	class:ImVector	access:public	signature:(int i)
operator bool	abstract-machine/libs/imgui/include/imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame	access:public	signature:() const
operator delete	abstract-machine/libs/imgui/include/imgui_internal.h	/^inline void operator delete(void*, ImPlacementNewDummy, void*) {}$/;"	f	signature:(void*, ImPlacementNewDummy, void*)
operator double	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator double()  const { return fix16_to_dbl(value);   }$/;"	f	class:Fix16	access:public	signature:() const
operator fix16_t	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator fix16_t() const { return value;                 }$/;"	f	class:Fix16	access:public	signature:() const
operator float	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator float()   const { return fix16_to_float(value); }$/;"	f	class:Fix16	access:public	signature:() const
operator int16_t	abstract-machine/libs/fixmath/include/fix16.hpp	/^		operator int16_t() const { return fix16_to_int(value);   }$/;"	f	class:Fix16	access:public	signature:() const
operator new	abstract-machine/libs/imgui/include/imgui_internal.h	/^inline void* operator new(size_t, ImPlacementNewDummy, void* ptr) { return ptr; }$/;"	f	signature:(size_t, ImPlacementNewDummy, void* ptr)
othercpu_halt	abstract-machine/am/src/x86/qemu/devices/cpu.c	/^void othercpu_halt() {$/;"	f
othercpu_halt	abstract-machine/am/src/x86/x86-qemu.h	/^void othercpu_halt();$/;"	p	signature:()
out_byte	abstract-machine/am/src/x86/qemu/boot/main.c	/^static inline void out_byte(short port, char data) {$/;"	f	file:	signature:(short port, char data)
outb	abstract-machine/am/include/x86.h	/^static inline void outb(int port, uint8_t data) {$/;"	f	signature:(int port, uint8_t data)
outl	abstract-machine/am/include/x86.h	/^static inline void outl(int port, uint32_t data) {$/;"	f	signature:(int port, uint32_t data)
output	abstract-machine/apps/microbench/src/bf/bf.c	/^static char *output;$/;"	v	file:
outw	abstract-machine/am/include/x86.h	/^static inline void outw(int port, uint16_t data) {$/;"	f	signature:(int port, uint16_t data)
overflow_bp	abstract-machine/apps/litenes/include/cpu.h	/^    overflow_bp   = 6,$/;"	e	enum:__anon4
overflow_flag	abstract-machine/apps/litenes/include/cpu.h	/^    overflow_flag  = 0x40,$/;"	e	enum:__anon3
p	abstract-machine/am/include/x86.h	/^  uint32_t p : 1;           \/\/ Present$/;"	m	struct:GateDesc	access:public
p	abstract-machine/am/include/x86.h	/^  uint32_t p : 1;          \/\/ Present$/;"	m	struct:SegDesc	access:public
p	abstract-machine/apps/litenes/src/psg.c	/^static int p = 10;$/;"	v	file:
pack_info	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context	access:public
pad	abstract-machine/am/include/arch/native.h	/^    uint8_t pad[1024];$/;"	m	union:_Context::__anon63	access:public
pad	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
padding	abstract-machine/am/include/x86.h	/^  char     padding[88];$/;"	m	struct:TSS	access:public
padding	abstract-machine/libs/imgui/include/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon47	access:public
padding	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context	access:public
padding1	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
padding2	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
padding3	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon34	access:public
paddr	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t paddr;$/;"	m	struct:ProgramHeader	file:	access:public
palette	abstract-machine/apps/litenes/src/fce.c	/^static const uint32_t palette[64] = {$/;"	v	file:
panic	abstract-machine/am/src/x86/x86-qemu.h	79;"	d
panic_on_return	abstract-machine/am/src/x86/qemu/cte.c	/^static void panic_on_return() { panic("kernel context returns"); }$/;"	f	file:
parseval	abstract-machine/apps/coremark/include/coremark.h	/^ee_s32 parseval(char *valstring);$/;"	p	signature:(char *valstring)
parseval	abstract-machine/apps/coremark/src/core_util.c	/^ee_s32 parseval(char *valstring) {$/;"	f	signature:(char *valstring)
pass	abstract-machine/apps/dhrystone/dry.c	/^Boolean pass = true;$/;"	v
pass	abstract-machine/apps/microbench/include/benchmark.h	/^  int pass;$/;"	m	struct:Result	access:public
path_length	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int path_length;$/;"	m	class:Updatable_heap::Step	access:public
path_weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int path_weight;$/;"	m	class:Updatable_heap::Step	access:public
pause	abstract-machine/am/include/x86.h	/^static inline void pause() {$/;"	f	signature:()
payload	abstract-machine/am/amtrace.h	/^  char payload[]; \/\/ _Payload: CALL -> .args$/;"	m	struct:_TraceEvent	access:public
pciconf_read	abstract-machine/am/src/x86/qemu/devices/pcdev.c	/^size_t pciconf_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
pciconf_read	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(pciconf_read);$/;"	v
pciconf_write	abstract-machine/am/src/x86/qemu/devices/pcdev.c	/^size_t pciconf_write(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
pciconf_write	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(pciconf_write);$/;"	v
percolate_down	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void percolate_down();$/;"	p	class:Updatable_heap	access:private	signature:()
percolate_down	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::percolate_down() {$/;"	f	class:Updatable_heap	signature:()
percolate_up	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void percolate_up( int );$/;"	p	class:Updatable_heap	access:private	signature:( int )
percolate_up	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::percolate_up( int n ) {$/;"	f	class:Updatable_heap	signature:( int n )
percpu_entry	abstract-machine/am/src/x86/qemu/mpe.c	/^static void percpu_entry() {$/;"	f	file:
percpu_entry	abstract-machine/am/src/x86/qemu/mpe.c	/^static void percpu_entry();$/;"	p	file:
percpu_initgdt	abstract-machine/am/src/x86/qemu/devices/cpu.c	/^void percpu_initgdt() {$/;"	f
percpu_initgdt	abstract-machine/am/src/x86/x86-qemu.h	/^void percpu_initgdt();$/;"	p	signature:()
percpu_initirq	abstract-machine/am/src/x86/qemu/cte.c	/^void percpu_initirq() {$/;"	f
percpu_initirq	abstract-machine/am/src/x86/x86-qemu.h	/^void percpu_initirq();$/;"	p	signature:()
percpu_initlapic	abstract-machine/am/src/x86/qemu/devices/apic.c	/^percpu_initlapic(void)$/;"	f	signature:(void)
percpu_initlapic	abstract-machine/am/src/x86/x86-qemu.h	/^void percpu_initlapic();$/;"	p	signature:()
percpu_initpg	abstract-machine/am/src/x86/qemu/vme.c	/^void percpu_initpg() { \/\/ called by all cpus$/;"	f
percpu_initpg	abstract-machine/am/src/x86/x86-qemu.h	/^void percpu_initpg();$/;"	p	signature:()
pgalloc	abstract-machine/am/src/x86/qemu/vme.c	/^static void *pgalloc() {$/;"	f	file:
pgalloc	abstract-machine/am/src/x86/qemu/vme.c	/^static void *pgalloc();$/;"	p	file:
pgalloc_usr	abstract-machine/am/src/x86/qemu/vme.c	/^static void *(*pgalloc_usr)(size_t);$/;"	v	file:
pgfree	abstract-machine/am/src/x86/qemu/vme.c	/^static void pgfree(void *ptr) {$/;"	f	file:	signature:(void *ptr)
pgfree	abstract-machine/am/src/x86/qemu/vme.c	/^static void pgfree(void *ptr);$/;"	p	file:	signature:(void *ptr)
pgfree_usr	abstract-machine/am/src/x86/qemu/vme.c	/^static void (*pgfree_usr)(void *);$/;"	v	file:
pgsize	abstract-machine/am/am.h	/^  size_t pgsize;$/;"	m	struct:_AddressSpace	access:public
phentsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t phentsize;$/;"	m	struct:ELFHeader	file:	access:public
phnum	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t phnum;$/;"	m	struct:ELFHeader	file:	access:public
phoff	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t phoff;$/;"	m	struct:ELFHeader	file:	access:public
physical	abstract-machine/am/src/x86/qemu/vme.c	/^  int physical;$/;"	m	struct:vm_area	file:	access:public
pid	pstree/pstree.c	/^char pid[10000][10];$/;"	v
pitch	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t pitch;$/;"	m	struct:VBEInfo	file:	access:public
pixel	abstract-machine/am/src/native/devices/video.c	/^static inline uint32_t pixel(uint8_t r, uint8_t g, uint8_t b) {$/;"	f	file:	signature:(uint8_t r, uint8_t g, uint8_t b)
pixel	abstract-machine/am/src/x86/qemu/devices/video.c	/^static inline uint32_t pixel(uint8_t r, uint8_t g, uint8_t b) {$/;"	f	file:	signature:(uint8_t r, uint8_t g, uint8_t b)
pixel	abstract-machine/apps/litenes/include/common.h	/^static inline uint32_t pixel(uint8_t r, uint8_t g, uint8_t b) {$/;"	f	signature:(uint8_t r, uint8_t g, uint8_t b)
pixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon48	access:public
pixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context	access:public
planes	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t planes;$/;"	m	struct:VBEInfo	file:	access:public
platform_dummy	abstract-machine/am/src/native/platform.cpp	/^void platform_dummy() {$/;"	f	signature:()
platform_dummy	abstract-machine/am/src/native/trm.c	/^extern void platform_dummy();$/;"	p	file:
pmem_fd	abstract-machine/am/src/native/platform.cpp	/^static int pmem_fd;$/;"	v	file:
pointer	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *pointer( T const & ) const;$/;"	p	class:Updatable_heap	access:private	signature:( T const & ) const
pointer	abstract-machine/apps/microbench/src/15pz/heap.h	/^typename Updatable_heap<T, M>::Step *Updatable_heap<T, M>::pointer( T const &pz ) const {$/;"	f	class:Updatable_heap	signature:( T const &pz ) const
pop	abstract-machine/apps/microbench/src/15pz/heap.h	/^    T pop();$/;"	p	class:Updatable_heap	access:public	signature:()
pop	abstract-machine/apps/microbench/src/15pz/heap.h	/^T Updatable_heap<T, M>::pop() {$/;"	f	class:Updatable_heap	signature:()
pop_back	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 pop_back()                      { IM_ASSERT(Size > 0); Size--; }$/;"	f	class:ImVector	access:public	signature:()
port	abstract-machine/apps/coremark/include/coremark.h	/^	core_portable port;$/;"	m	struct:RESULTS_S	access:public
port_read	abstract-machine/am/src/x86/qemu/devices/pcdev.c	/^static inline uintptr_t port_read(int port, size_t nmemb) {$/;"	f	file:	signature:(int port, size_t nmemb)
port_write	abstract-machine/am/src/x86/qemu/devices/pcdev.c	/^static inline void port_write(int port, size_t nmemb, uintptr_t data) {$/;"	f	file:	signature:(int port, size_t nmemb, uintptr_t data)
portable_fini	abstract-machine/apps/coremark/include/core_portme.h	/^void portable_fini(core_portable *p);$/;"	p	signature:(core_portable *p)
portable_fini	abstract-machine/apps/coremark/src/core_portme.c	/^void portable_fini(core_portable *p)$/;"	f	signature:(core_portable *p)
portable_free	abstract-machine/apps/coremark/include/coremark.h	/^void portable_free(void *p);$/;"	p	signature:(void *p)
portable_id	abstract-machine/apps/coremark/include/core_portme.h	/^	ee_u8	portable_id;$/;"	m	struct:CORE_PORTABLE_S	access:public
portable_init	abstract-machine/apps/coremark/include/core_portme.h	/^void portable_init(core_portable *p, int *argc, char *argv[]);$/;"	p	signature:(core_portable *p, int *argc, char *argv[])
portable_init	abstract-machine/apps/coremark/src/core_portme.c	/^void portable_init(core_portable *p, int *argc, char *argv[])$/;"	f	signature:(core_portable *p, int *argc, char *argv[])
portable_malloc	abstract-machine/apps/coremark/include/coremark.h	/^void *portable_malloc(ee_size_t size);$/;"	p	signature:(ee_size_t size)
pos	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert	access:public
ppn	abstract-machine/am/src/native/vme.c	/^  uintptr_t ppn;$/;"	m	struct:PageMap	file:	access:public
ppu	abstract-machine/apps/litenes/include/ppu.h	/^extern PPU_STATE ppu;$/;"	x
ppu	abstract-machine/apps/litenes/src/ppu.c	/^PPU_STATE ppu;$/;"	v
ppu_2007_first_read	abstract-machine/apps/litenes/src/ppu.c	/^bool ppu_2007_first_read;$/;"	v
ppu_addr_latch	abstract-machine/apps/litenes/src/ppu.c	/^byte ppu_addr_latch;$/;"	v
ppu_background_pattern_table_address	abstract-machine/apps/litenes/include/ppu.h	/^word ppu_background_pattern_table_address();$/;"	p	signature:()
ppu_background_pattern_table_address	abstract-machine/apps/litenes/src/ppu.c	/^inline word ppu_background_pattern_table_address()                  { return common_bit_set(ppu.PPUCTRL, 4) ? 0x1000 : 0x0000; }$/;"	f
ppu_base_nametable_address	abstract-machine/apps/litenes/include/ppu.h	/^word ppu_base_nametable_address();$/;"	p	signature:()
ppu_base_nametable_address	abstract-machine/apps/litenes/src/ppu.c	/^inline word ppu_base_nametable_address()                            { return ppu_base_nametable_addresses[ppu.PPUCTRL & 0x3];  }$/;"	f
ppu_base_nametable_addresses	abstract-machine/apps/litenes/src/ppu.c	/^static const word ppu_base_nametable_addresses[4] = { 0x2000, 0x2400, 0x2800, 0x2C00 };$/;"	v	file:
ppu_copy	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_copy(word address, byte *source, int length);$/;"	p	signature:(word address, byte *source, int length)
ppu_copy	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_copy(word address, byte *source, int length)$/;"	f	signature:(word address, byte *source, int length)
ppu_cycle	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_cycle();$/;"	p	signature:()
ppu_cycle	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_cycle()$/;"	f
ppu_draw_background_scanline	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_draw_background_scanline(bool mirror)$/;"	f	signature:(bool mirror)
ppu_draw_sprite_scanline	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_draw_sprite_scanline()$/;"	f
ppu_finish	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_finish();$/;"	p	signature:()
ppu_generates_nmi	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_generates_nmi();$/;"	p	signature:()
ppu_generates_nmi	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_generates_nmi()                                     { return common_bit_set(ppu.PPUCTRL, 7);                   }$/;"	f
ppu_get_real_ram_address	abstract-machine/apps/litenes/include/ppu.h	/^word ppu_get_real_ram_address(word address);$/;"	p	signature:(word address)
ppu_get_real_ram_address	abstract-machine/apps/litenes/src/ppu.c	/^inline word ppu_get_real_ram_address(word address)$/;"	f	signature:(word address)
ppu_in_vblank	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_in_vblank();$/;"	p	signature:()
ppu_in_vblank	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_in_vblank()                                         { return common_bit_set(ppu.PPUSTATUS, 7); }$/;"	f
ppu_init	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_init();$/;"	p	signature:()
ppu_init	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_init()$/;"	f
ppu_intensifies_blues	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_intensifies_blues();$/;"	p	signature:()
ppu_intensifies_blues	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_intensifies_blues()                                 { return common_bit_set(ppu.PPUMASK, 7); }$/;"	f
ppu_intensifies_greens	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_intensifies_greens();$/;"	p	signature:()
ppu_intensifies_greens	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_intensifies_greens()                                { return common_bit_set(ppu.PPUMASK, 6); }$/;"	f
ppu_intensifies_reds	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_intensifies_reds();$/;"	p	signature:()
ppu_intensifies_reds	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_intensifies_reds()                                  { return common_bit_set(ppu.PPUMASK, 5); }$/;"	f
ppu_io_read	abstract-machine/apps/litenes/include/ppu.h	/^byte ppu_io_read(word address);$/;"	p	signature:(word address)
ppu_io_read	abstract-machine/apps/litenes/src/ppu.c	/^inline byte ppu_io_read(word address)$/;"	f	signature:(word address)
ppu_io_write	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_io_write(word address, byte data);$/;"	p	signature:(word address, byte data)
ppu_io_write	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_io_write(word address, byte data)$/;"	f	signature:(word address, byte data)
ppu_l_h_addition	abstract-machine/apps/litenes/include/ppu.h	/^static inline byte ppu_l_h_addition(int h, int l, int x) {$/;"	f	signature:(int h, int l, int x)
ppu_l_h_addition_flip	abstract-machine/apps/litenes/include/ppu.h	/^static inline byte ppu_l_h_addition_flip(int l, int h, int x) {$/;"	f	signature:(int l, int h, int x)
ppu_latch	abstract-machine/apps/litenes/include/ppu.h	/^extern byte ppu_latch;$/;"	x
ppu_latch	abstract-machine/apps/litenes/src/ppu.c	/^byte ppu_latch;$/;"	v
ppu_ram_map	abstract-machine/apps/litenes/src/ppu.c	/^static word ppu_ram_map[0x4000];$/;"	v	file:
ppu_ram_read	abstract-machine/apps/litenes/include/ppu.h	/^byte ppu_ram_read(word address);$/;"	p	signature:(word address)
ppu_ram_read	abstract-machine/apps/litenes/src/ppu.c	/^inline byte ppu_ram_read(word address)$/;"	f	signature:(word address)
ppu_ram_write	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_ram_write(word address, byte data);$/;"	p	signature:(word address, byte data)
ppu_ram_write	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_ram_write(word address, byte data)$/;"	f	signature:(word address, byte data)
ppu_render_screen	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_render_screen();$/;"	p	signature:()
ppu_renders_grayscale	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_renders_grayscale();$/;"	p	signature:()
ppu_renders_grayscale	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_renders_grayscale()                                 { return common_bit_set(ppu.PPUMASK, 0); }$/;"	f
ppu_run	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_run(int cycles);$/;"	p	signature:(int cycles)
ppu_run	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_run(int cycles)$/;"	f	signature:(int cycles)
ppu_scanline	abstract-machine/apps/litenes/include/ppu.h	/^int ppu_scanline();$/;"	p	signature:()
ppu_screen_background	abstract-machine/apps/litenes/src/ppu.c	/^byte ppu_screen_background[264][264];$/;"	v
ppu_set_background_color	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_background_color(byte color);$/;"	p	signature:(byte color)
ppu_set_background_color	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_set_background_color(byte color)$/;"	f	signature:(byte color)
ppu_set_generates_nmi	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_generates_nmi(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_in_vblank	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_in_vblank(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_in_vblank	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_in_vblank(bool yesno)                           { common_modify_bitb(&ppu.PPUSTATUS, 7, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_intensifies_blues	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_intensifies_blues(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_intensifies_blues	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_intensifies_blues(bool yesno)                   { common_modify_bitb(&ppu.PPUMASK, 7, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_intensifies_greens	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_intensifies_greens(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_intensifies_greens	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_intensifies_greens(bool yesno)                  { common_modify_bitb(&ppu.PPUMASK, 6, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_intensifies_reds	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_intensifies_reds(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_intensifies_reds	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_intensifies_reds(bool yesno)                    { common_modify_bitb(&ppu.PPUMASK, 5, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_mirroring	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_mirroring(byte mirroring);$/;"	p	signature:(byte mirroring)
ppu_set_mirroring	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_set_mirroring(byte mirroring)$/;"	f	signature:(byte mirroring)
ppu_set_renders_grayscale	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_renders_grayscale(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_renders_grayscale	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_renders_grayscale(bool yesno)                   { common_modify_bitb(&ppu.PPUMASK, 0, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_scanline	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_scanline(int s);$/;"	p	signature:(int s)
ppu_set_shows_background	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_shows_background(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_shows_background	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_shows_background(bool yesno)                    { common_modify_bitb(&ppu.PPUMASK, 3, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_shows_background_in_leftmost_8px	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_shows_background_in_leftmost_8px(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_shows_background_in_leftmost_8px	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_shows_background_in_leftmost_8px(bool yesno)    { common_modify_bitb(&ppu.PPUMASK, 1, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_shows_sprites	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_shows_sprites(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_shows_sprites	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_shows_sprites(bool yesno)                       { common_modify_bitb(&ppu.PPUMASK, 4, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_shows_sprites_in_leftmost_8px	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_shows_sprites_in_leftmost_8px(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_shows_sprites_in_leftmost_8px	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_shows_sprites_in_leftmost_8px(bool yesno)       { common_modify_bitb(&ppu.PPUMASK, 2, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_sprite_0_hit	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_sprite_0_hit(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_sprite_0_hit	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_sprite_0_hit(bool yesno)                        { common_modify_bitb(&ppu.PPUSTATUS, 6, yesno); }$/;"	f	signature:(bool yesno)
ppu_set_sprite_overflow	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_set_sprite_overflow(bool yesno);$/;"	p	signature:(bool yesno)
ppu_set_sprite_overflow	abstract-machine/apps/litenes/src/ppu.c	/^inline void ppu_set_sprite_overflow(bool yesno)                     { common_modify_bitb(&ppu.PPUSTATUS, 5, yesno); }$/;"	f	signature:(bool yesno)
ppu_shows_background	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_shows_background();$/;"	p	signature:()
ppu_shows_background	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_shows_background()                                  { return common_bit_set(ppu.PPUMASK, 3); }$/;"	f
ppu_shows_background_in_leftmost_8px	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_shows_background_in_leftmost_8px();$/;"	p	signature:()
ppu_shows_background_in_leftmost_8px	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_shows_background_in_leftmost_8px()                  { return common_bit_set(ppu.PPUMASK, 1); }$/;"	f
ppu_shows_sprites	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_shows_sprites();$/;"	p	signature:()
ppu_shows_sprites	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_shows_sprites()                                     { return common_bit_set(ppu.PPUMASK, 4); }$/;"	f
ppu_shows_sprites_in_leftmost_8px	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_shows_sprites_in_leftmost_8px();$/;"	p	signature:()
ppu_shows_sprites_in_leftmost_8px	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_shows_sprites_in_leftmost_8px()                     { return common_bit_set(ppu.PPUMASK, 2); }$/;"	f
ppu_sprite_0_hit	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_sprite_0_hit();$/;"	p	signature:()
ppu_sprite_0_hit	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_sprite_0_hit()                                      { return common_bit_set(ppu.PPUSTATUS, 6); }$/;"	f
ppu_sprite_height	abstract-machine/apps/litenes/include/ppu.h	/^byte ppu_sprite_height();$/;"	p	signature:()
ppu_sprite_height	abstract-machine/apps/litenes/src/ppu.c	/^inline byte ppu_sprite_height()                                     { return common_bit_set(ppu.PPUCTRL, 5) ? 16 : 8;          }$/;"	f
ppu_sprite_hit_occured	abstract-machine/apps/litenes/include/ppu.h	/^extern bool ppu_sprite_hit_occured;$/;"	x
ppu_sprite_hit_occured	abstract-machine/apps/litenes/src/ppu.c	/^bool ppu_sprite_hit_occured = false;$/;"	v
ppu_sprite_overflow	abstract-machine/apps/litenes/include/ppu.h	/^bool ppu_sprite_overflow();$/;"	p	signature:()
ppu_sprite_overflow	abstract-machine/apps/litenes/src/ppu.c	/^inline bool ppu_sprite_overflow()                                   { return common_bit_set(ppu.PPUSTATUS, 5); }$/;"	f
ppu_sprite_palette	abstract-machine/apps/litenes/src/ppu.c	/^byte ppu_sprite_palette[4][4];$/;"	v
ppu_sprite_pattern_table_address	abstract-machine/apps/litenes/include/ppu.h	/^word ppu_sprite_pattern_table_address();$/;"	p	signature:()
ppu_sprite_pattern_table_address	abstract-machine/apps/litenes/src/ppu.c	/^inline word ppu_sprite_pattern_table_address()                      { return common_bit_set(ppu.PPUCTRL, 3) ? 0x1000 : 0x0000; }$/;"	f
ppu_sprite_width	abstract-machine/apps/litenes/include/ppu.h	/^byte ppu_sprite_width();$/;"	p	signature:()
ppu_sprram_write	abstract-machine/apps/litenes/include/ppu.h	/^void ppu_sprram_write(byte data);$/;"	p	signature:(byte data)
ppu_sprram_write	abstract-machine/apps/litenes/src/ppu.c	/^void ppu_sprram_write(byte data)$/;"	f	signature:(byte data)
ppu_vram_address_increment	abstract-machine/apps/litenes/include/ppu.h	/^byte ppu_vram_address_increment();$/;"	p	signature:()
ppu_vram_address_increment	abstract-machine/apps/litenes/src/ppu.c	/^inline byte ppu_vram_address_increment()                            { return common_bit_set(ppu.PPUCTRL, 2) ? 32 : 1;          }$/;"	f
preferred_x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon34	access:public
prepare	abstract-machine/apps/microbench/include/benchmark.h	/^  void (*prepare)();$/;"	m	struct:Benchmark	access:public
prepare	abstract-machine/apps/microbench/include/benchmark.h	/^void prepare(Result *res);$/;"	p	signature:(Result *res)
press_key	abstract-machine/apps/typing/game.h	/^void press_key(int scan_code);$/;"	p	signature:(int scan_code)
press_key	abstract-machine/apps/typing/keyboard.c	/^void press_key(int scan_code) {$/;"	f	signature:(int scan_code)
prev_first	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon36	access:public
prev_link	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon39	access:public
prev_write	abstract-machine/apps/litenes/src/psg.c	/^static byte prev_write;$/;"	v	file:
previous_step	abstract-machine/apps/microbench/src/15pz/heap.h	/^    Step *previous_step;$/;"	m	class:Updatable_heap::Step	access:public
prg_block_count	abstract-machine/apps/litenes/src/fce.c	/^    byte prg_block_count;$/;"	m	struct:__anon1	file:	access:public
primes	abstract-machine/apps/microbench/src/sieve/sieve.c	/^static uint32_t *primes;$/;"	v	file:
print	abstract-machine/apps/hello/hello.c	/^void print(const char *s) {$/;"	f	signature:(const char *s)
print_tree	pstree/pstree.c	/^void print_tree(int pid, int retract, bool first_son, bool last_son);$/;"	p	file:	signature:(int pid, int retract, bool first_son, bool last_son)
print_tree	pstree/pstree.c	/^void print_tree(int pid, int retract, bool first_son, bool last_son){$/;"	f	signature:(int pid, int retract, bool first_son, bool last_son)
print_version	pstree/pstree.c	/^void print_version();$/;"	p	file:
print_version	pstree/pstree.c	/^void print_version(){$/;"	f
printf	abstract-machine/libs/klib/include/klib.h	/^int printf(const char* fmt, ...);$/;"	p	signature:(const char* fmt, ...)
printf	abstract-machine/libs/klib/include/klib.h	23;"	d
printf	abstract-machine/libs/klib/src/stdio.c	/^int printf(const char *fmt, ...) {$/;"	f	signature:(const char *fmt, ...)
printmat	abstract-machine/apps/coremark/src/core_matrix.c	/^void printmat(MATDAT *A, ee_u32 N, char *name) {$/;"	f	signature:(MATDAT *A, ee_u32 N, char *name)
printmatC	abstract-machine/apps/coremark/src/core_matrix.c	/^void printmatC(MATRES *C, ee_u32 N, char *name) {$/;"	f	signature:(MATRES *C, ee_u32 N, char *name)
proc	pstree/pstree.c	/^}proc[10000];$/;"	v	typeref:struct:PROC
product	abstract-machine/am/include/x86.h	/^  uint8_t  product[20];     \/\/ product id$/;"	m	struct:MPConf	access:public
proggy_clean_ttf_compressed_data_base85	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static const char proggy_clean_ttf_compressed_data_base85[11980+1] =$/;"	v	file:
prot	abstract-machine/am/include/arch/native.h	/^      void *prot;$/;"	m	struct:_Context::__anon63::__anon64	access:public
prot	abstract-machine/am/include/arch/x86-qemu.h	/^  struct _AddressSpace *prot;$/;"	m	struct:_Context	typeref:struct:_Context::_AddressSpace	access:public
prot	abstract-machine/am/src/x86/x86-qemu.h	/^  _AddressSpace *prot;$/;"	m	struct:cpu_local	access:public
protect	abstract-machine/am/src/x86/qemu/vme.c	/^int protect(_AddressSpace *p) {$/;"	f	signature:(_AddressSpace *p)
psg_io_read	abstract-machine/apps/litenes/include/psg.h	/^byte psg_io_read(word address);$/;"	p	signature:(word address)
psg_io_read	abstract-machine/apps/litenes/src/psg.c	/^inline byte psg_io_read(word address)$/;"	f	signature:(word address)
psg_io_write	abstract-machine/apps/litenes/include/psg.h	/^void psg_io_write(word address, byte data);$/;"	p	signature:(word address, byte data)
psg_io_write	abstract-machine/apps/litenes/src/psg.c	/^inline void psg_io_write(word address, byte data)$/;"	f	signature:(word address, byte data)
psg_joy1	abstract-machine/apps/litenes/include/psg.h	/^extern unsigned char psg_joy1[8];$/;"	x
ptr	abstract-machine/am/am.h	/^  void *ptr;$/;"	m	struct:_AddressSpace	access:public
push	abstract-machine/am/src/x86/qemu/cte.c	163;"	d	file:
push	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void push( T const &, int );$/;"	p	class:Updatable_heap	access:public	signature:( T const &, int )
push	abstract-machine/apps/microbench/src/15pz/heap.h	/^void Updatable_heap<T, M>::push( T const &pz, int path_length ) {$/;"	f	class:Updatable_heap	signature:( T const &pz, int path_length )
push_back	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 push_back(const value_type& v)  { if (Size == Capacity) reserve(_grow_capacity(Size+1)); Data[Size++] = v; }$/;"	f	class:ImVector	access:public	signature:(const value_type& v)
put	abstract-machine/apps/microbench/src/fib/fib.c	/^static void put(uint32_t *m, int i, int j, uint32_t data) {$/;"	f	file:	signature:(uint32_t *m, int i, int j, uint32_t data)
puts	abstract-machine/am/src/x86/x86-qemu.h	/^static inline void puts(const char *s) {$/;"	f	signature:(const char *s)
puts	amgame/include/game.h	/^static inline void puts(const char *s) {$/;"	f	signature:(const char *s)
puzzle	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    int8_t puzzle[N][N];$/;"	m	class:N_puzzle	access:private
puzzle_valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool puzzle_valid;$/;"	m	class:N_puzzle	access:private
pvertices	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt_vertex *pvertices;$/;"	m	struct:__anon55	access:public
qlz_compress	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^size_t qlz_compress(const void *source, char *destination, size_t size, qlz_state_compress *state)$/;"	f	signature:(const void *source, char *destination, size_t size, qlz_state_compress *state)
qlz_compress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^size_t qlz_compress(const void *source, char *destination, size_t size, qlz_state_compress *state);$/;"	p	signature:(const void *source, char *destination, size_t size, qlz_state_compress *state)
qlz_compress_core	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static size_t qlz_compress_core(const unsigned char *source, unsigned char *destination, size_t size, qlz_state_compress *state)$/;"	f	file:	signature:(const unsigned char *source, unsigned char *destination, size_t size, qlz_state_compress *state)
qlz_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state)$/;"	f	signature:(const char *source, void *destination, qlz_state_decompress *state)
qlz_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^size_t qlz_decompress(const char *source, void *destination, qlz_state_decompress *state);$/;"	p	signature:(const char *source, void *destination, qlz_state_decompress *state)
qlz_decompress_core	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static size_t qlz_decompress_core(const unsigned char *source, unsigned char *destination, size_t size, qlz_state_decompress *state, const unsigned char *history)$/;"	f	file:	signature:(const unsigned char *source, unsigned char *destination, size_t size, qlz_state_decompress *state, const unsigned char *history)
qlz_get_setting	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^int qlz_get_setting(int setting)$/;"	f	signature:(int setting)
qlz_get_setting	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^int qlz_get_setting(int setting);$/;"	p	signature:(int setting)
qlz_hash_compress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^} qlz_hash_compress;$/;"	t	typeref:struct:__anon6
qlz_hash_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^} qlz_hash_decompress;$/;"	t	typeref:struct:__anon7
qlz_size_compressed	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^size_t qlz_size_compressed(const char *source)$/;"	f	signature:(const char *source)
qlz_size_compressed	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^size_t qlz_size_compressed(const char *source);$/;"	p	signature:(const char *source)
qlz_size_decompressed	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^size_t qlz_size_decompressed(const char *source)$/;"	f	signature:(const char *source)
qlz_size_decompressed	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^size_t qlz_size_decompressed(const char *source);$/;"	p	signature:(const char *source)
qlz_size_header	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^size_t qlz_size_header(const char *source)$/;"	f	signature:(const char *source)
qlz_state_compress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^} qlz_state_compress;$/;"	t	typeref:struct:__anon8
qlz_state_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	} qlz_state_decompress;$/;"	t	typeref:struct:__anon10
qlz_state_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	} qlz_state_decompress;$/;"	t	typeref:struct:__anon9
query_key	abstract-machine/apps/typing/game.h	/^bool query_key(int ch);$/;"	p	signature:(int ch)
query_key	abstract-machine/apps/typing/keyboard.c	/^bool query_key(int index) {$/;"	f	signature:(int index)
queue	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int d[MAXN*2 + 2], cur[MAXN*2 + 2], queue[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
r	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t b, g, r;$/;"	m	struct:FBPixel	file:	access:public
r	abstract-machine/apps/microbench/src/md5/md5.c	/^static const uint32_t r[] = {7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,$/;"	v	file:
radixPass	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^static void radixPass(int* a, int* b, int* r, int n, int K) $/;"	f	file:	signature:(int* a, int* b, int* r, int n, int K)
rand	abstract-machine/libs/klib/include/klib.h	/^int rand();$/;"	p	signature:()
rand	abstract-machine/libs/klib/src/stdlib.c	/^int rand(void) {$/;"	f	signature:(void)
rax	abstract-machine/am/include/arch/native.h	/^  uintptr_t rax;$/;"	m	struct:_Context	access:public
rdi	abstract-machine/am/include/arch/native.h	/^  uintptr_t rdi;$/;"	m	struct:_Context	access:public
rdtsc	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static inline uint64_t rdtsc() {$/;"	f	file:
read_key	abstract-machine/libs/klib/include/klib.h	/^int read_key();$/;"	p	signature:()
read_key	abstract-machine/libs/klib/src/io.c	/^int read_key() {$/;"	f
read_key	amgame/src/game.c	/^void read_key() {$/;"	f
read_key	amgame/src/game.c	/^void read_key();$/;"	p	file:
read_rtc	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static int read_rtc(int reg) {$/;"	f	file:	signature:(int reg)
readsect	abstract-machine/am/src/x86/qemu/boot/main.c	/^readsect(volatile void *dst, int offset) {$/;"	f	signature:(volatile void *dst, int offset)
readseg	abstract-machine/am/src/x86/qemu/boot/main.c	/^readseg(unsigned char *pa, int count, int offset) {$/;"	f	signature:(unsigned char *pa, int count, int offset)
readseg	abstract-machine/am/src/x86/qemu/boot/main.c	/^void readseg(unsigned char *, int, int);$/;"	p	file:	signature:(unsigned char *, int, int)
ready	abstract-machine/apps/litenes/include/ppu.h	/^    bool ready;$/;"	m	struct:__anon2	access:public
real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { double real, imaginary; } Dcomplex;$/;"	m	struct:__anon29	access:public
real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { float real, imaginary; } Fcomplex;$/;"	m	struct:__anon28	access:public
real	abstract-machine/libs/compiler-rt/int_types.h	/^typedef struct { long double real, imaginary; } Lcomplex;$/;"	m	struct:__anon30	access:public
real_fps	abstract-machine/apps/typing/game.c	/^static int real_fps;$/;"	v	file:
record	abstract-machine/apps/dhrystone/dry.c	/^typedef struct record $/;"	s	file:
record::Discr	abstract-machine/apps/dhrystone/dry.c	/^    Enumeration    Discr;$/;"	m	struct:record	file:	access:public
record::Ptr_Comp	abstract-machine/apps/dhrystone/dry.c	/^    struct record *Ptr_Comp;$/;"	m	struct:record	typeref:struct:record::record	file:	access:public
record::__anon12::__anon13::Enum_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  Enumeration Enum_Comp;$/;"	m	struct:record::__anon12::__anon13	file:	access:public
record::__anon12::__anon13::Int_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  int         Int_Comp;$/;"	m	struct:record::__anon12::__anon13	file:	access:public
record::__anon12::__anon13::Str_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Str_Comp [31];$/;"	m	struct:record::__anon12::__anon13	file:	access:public
record::__anon12::__anon14::E_Comp_2	abstract-machine/apps/dhrystone/dry.c	/^                  Enumeration E_Comp_2;$/;"	m	struct:record::__anon12::__anon14	file:	access:public
record::__anon12::__anon14::Str_2_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Str_2_Comp [31];$/;"	m	struct:record::__anon12::__anon14	file:	access:public
record::__anon12::__anon15::Ch_1_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Ch_1_Comp;$/;"	m	struct:record::__anon12::__anon15	file:	access:public
record::__anon12::__anon15::Ch_2_Comp	abstract-machine/apps/dhrystone/dry.c	/^                  char        Ch_2_Comp;$/;"	m	struct:record::__anon12::__anon15	file:	access:public
record::__anon12::var_1	abstract-machine/apps/dhrystone/dry.c	/^                  } var_1;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon13	file:	access:public
record::__anon12::var_2	abstract-machine/apps/dhrystone/dry.c	/^                  } var_2;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon14	file:	access:public
record::__anon12::var_3	abstract-machine/apps/dhrystone/dry.c	/^                  } var_3;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon15	file:	access:public
record::variant	abstract-machine/apps/dhrystone/dry.c	/^          } variant;$/;"	m	struct:record	typeref:union:record::__anon12	file:	access:public
rect_height_compare	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static int rect_height_compare(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
rect_original_order	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static int rect_original_order(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
rect_width_compare	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static int rect_width_compare(const void *a, const void *b)$/;"	f	signature:(const void *a, const void *b)
red_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t red_mask;$/;"	m	struct:VBEInfo	file:	access:public
red_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t red_position;$/;"	m	struct:VBEInfo	file:	access:public
redo_char_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon33	access:public
redo_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon33	access:public
redraw_screen	abstract-machine/apps/typing/draw.c	/^void redraw_screen() {$/;"	f
redraw_screen	abstract-machine/apps/typing/game.h	/^void redraw_screen();$/;"	p	signature:()
ref	abstract-machine/am/am.h	/^  uintptr_t cause, ref;$/;"	m	struct:_Event	access:public
ref	abstract-machine/am/amtrace.h	/^  uintptr_t ref;  \/\/ a pointer$/;"	m	struct:_TraceEvent	access:public
ref	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long mlim, ref;$/;"	m	struct:Setting	access:public
reg	abstract-machine/am/src/x86/qemu/devices/apic.c	/^    uint32_t reg, pad[3], data;$/;"	m	struct:IOAPIC	file:	access:public
release_key	abstract-machine/apps/typing/game.h	/^void release_key(int ch);$/;"	p	signature:(int ch)
release_key	abstract-machine/apps/typing/keyboard.c	/^void release_key(int index) {$/;"	f	signature:(int index)
renderer	abstract-machine/am/src/native/devices/video.c	/^static SDL_Renderer *renderer;$/;"	v	file:
reserve	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 reserve(int new_capacity)$/;"	f	class:ImVector	access:public	signature:(int new_capacity)
reserved	abstract-machine/am/include/x86.h	/^  uint8_t  reserved;$/;"	m	struct:MPConf	access:public
reserved	abstract-machine/am/include/x86.h	/^  uint8_t reserved[3];$/;"	m	struct:MPDesc	access:public
reserved	abstract-machine/apps/litenes/src/fce.c	/^    byte reserved[8];$/;"	m	struct:__anon1	file:	access:public
reserved0	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved0;$/;"	m	struct:VBEInfo	file:	access:public
reserved1	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved1[206];$/;"	m	struct:VBEInfo	file:	access:public
reserved_mask	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved_mask;$/;"	m	struct:VBEInfo	file:	access:public
reserved_position	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t reserved_position;$/;"	m	struct:VBEInfo	file:	access:public
reset_table_compress	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static void reset_table_compress(qlz_state_compress *state)$/;"	f	file:	signature:(qlz_state_compress *state)
reset_table_decompress	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static void reset_table_decompress(qlz_state_decompress *state)$/;"	f	file:	signature:(qlz_state_decompress *state)
resize	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 resize(int new_size)            { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	class:ImVector	access:public	signature:(int new_size)
ret_from_trap	abstract-machine/am/src/native/cte.c	/^extern void ret_from_trap();$/;"	p	file:
ret_from_trap	abstract-machine/am/src/native/trap.S	/^ret_from_trap:$/;"	l
retval	abstract-machine/am/amtrace.h	/^  uintptr_t retval;$/;"	m	union:_Payload	access:public
rip	abstract-machine/am/include/arch/native.h	/^  uintptr_t rip;$/;"	m	struct:_Context	access:public
rom_mario_nes	abstract-machine/apps/litenes/include/fce.h	/^extern char rom_mario_nes[];$/;"	x
rom_mario_nes	abstract-machine/apps/litenes/src/rom_mario.c	/^unsigned char rom_mario_nes[] = {$/;"	v
rom_mario_nes_len	abstract-machine/apps/litenes/src/rom_mario.c	/^unsigned int rom_mario_nes_len = 40976;$/;"	v
rom_type	abstract-machine/apps/litenes/src/fce.c	/^    word rom_type;$/;"	m	struct:__anon1	file:	access:public
romread	abstract-machine/apps/litenes/src/fce.c	/^byte *romread(int size)$/;"	f	signature:(int size)
row	abstract-machine/apps/litenes/src/fce.c	/^static uint32_t row[1024];$/;"	v	file:
rsv1	abstract-machine/am/include/x86.h	/^  uint32_t rsv1 : 1;       \/\/ Reserved$/;"	m	struct:SegDesc	access:public
rsv1	abstract-machine/am/include/x86.h	/^  uint32_t rsv1 : 3;        \/\/ Reserved(should be zero I guess)$/;"	m	struct:GateDesc	access:public
run	abstract-machine/apps/microbench/include/benchmark.h	/^  void (*run)();$/;"	m	struct:Benchmark	access:public
run_once	abstract-machine/apps/microbench/src/bench.c	/^static void run_once(Benchmark *b, Result *res) {$/;"	f	file:	signature:(Benchmark *b, Result *res)
s	abstract-machine/am/include/x86.h	/^  uint32_t s : 1;           \/\/ Must be 0 (system)$/;"	m	struct:GateDesc	access:public
s	abstract-machine/am/include/x86.h	/^  uint32_t s : 1;          \/\/ 0 = system, 1 = application$/;"	m	struct:SegDesc	access:public
s	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
s	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^static int *s, *sa;$/;"	v	file:
s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon16	typeref:struct:__anon16::__anon17	access:public
s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon18	typeref:struct:__anon18::__anon19	access:public
s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon20	typeref:struct:__anon20::__anon21	access:public
s	abstract-machine/libs/compiler-rt/int_types.h	/^    }s;$/;"	m	union:__anon22	typeref:struct:__anon22::__anon23	access:public
s0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
s1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
sa	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^static int *s, *sa;$/;"	v	file:
sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const Fix16 &other)  const { Fix16 ret = fix16_sadd(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const double other)  const { Fix16 ret = fix16_sadd(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const fix16_t other) const { Fix16 ret = fix16_sadd(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const float other)   const { Fix16 ret = fix16_sadd(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
sadd	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sadd(const int16_t other) const { Fix16 ret = fix16_sadd(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
same	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static int same(const unsigned char *src, size_t n)$/;"	f	file:	signature:(const unsigned char *src, size_t n)
scales	abstract-machine/libs/fixmath/src/fix16_str.c	/^static const uint32_t scales[8] = {$/;"	v	file:
scan_code	abstract-machine/am/src/x86/qemu/devices/input.c	/^static int scan_code[] = {$/;"	v	file:
scanline	abstract-machine/apps/litenes/include/ppu.h	/^    int x, scanline;$/;"	m	struct:__anon2	access:public
scipat	abstract-machine/apps/coremark/src/core_state.c	/^static ee_u8 *scipat[4]  ={(ee_u8 *)"5.500e+3",(ee_u8 *)"-.123e-2",(ee_u8 *)"-87e+832",(ee_u8 *)"+0.6e-12"};$/;"	v	file:
score	abstract-machine/apps/microbench/src/bench.c	/^static unsigned long score(Benchmark *b, unsigned long tsc, unsigned long msec) {$/;"	f	file:	signature:(Benchmark *b, unsigned long tsc, unsigned long msec)
screen_height	abstract-machine/libs/klib/include/klib.h	/^int screen_height();$/;"	p	signature:()
screen_height	abstract-machine/libs/klib/src/io.c	/^int screen_height() {$/;"	f
screen_width	abstract-machine/libs/klib/include/klib.h	/^int screen_width();$/;"	p	signature:()
screen_width	abstract-machine/libs/klib/src/io.c	/^int screen_width() {$/;"	f
scroll_received_x	abstract-machine/apps/litenes/include/ppu.h	/^    bool scroll_received_x;$/;"	m	struct:__anon2	access:public
sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const Fix16 &other)  const { Fix16 ret = fix16_sdiv(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const double other)  const { Fix16 ret = fix16_sdiv(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const fix16_t other) const { Fix16 ret = fix16_sdiv(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const float other)   const { Fix16 ret = fix16_sdiv(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
sdiv	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 sdiv(const int16_t other) const { Fix16 ret = fix16_sdiv(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
secs_ret	abstract-machine/apps/coremark/include/coremark.h	/^typedef double secs_ret;$/;"	t
secs_ret	abstract-machine/apps/coremark/include/coremark.h	/^typedef ee_u32 secs_ret;$/;"	t
seed	abstract-machine/apps/microbench/src/bench.c	/^static uint32_t seed = 1;$/;"	v	file:
seed1	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed1;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
seed1_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed1_volatile=0x0;$/;"	v
seed1_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed1_volatile=0x3415;$/;"	v
seed1_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed1_volatile=0x8;$/;"	v
seed1_volatile	abstract-machine/apps/coremark/src/core_util.c	/^	extern volatile ee_s32 seed1_volatile;$/;"	x
seed2	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed2;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
seed2_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed2_volatile=0x0;$/;"	v
seed2_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed2_volatile=0x3415;$/;"	v
seed2_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed2_volatile=0x8;$/;"	v
seed2_volatile	abstract-machine/apps/coremark/src/core_util.c	/^	extern volatile ee_s32 seed2_volatile;$/;"	x
seed3	abstract-machine/apps/coremark/include/coremark.h	/^	ee_s16	seed3;		\/* Initializing seed *\/$/;"	m	struct:RESULTS_S	access:public
seed3_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed3_volatile=0x66;$/;"	v
seed3_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed3_volatile=0x8;$/;"	v
seed3_volatile	abstract-machine/apps/coremark/src/core_util.c	/^	extern volatile ee_s32 seed3_volatile;$/;"	x
seed4_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed4_volatile=ITERATIONS;$/;"	v
seed4_volatile	abstract-machine/apps/coremark/src/core_util.c	/^	extern volatile ee_s32 seed4_volatile;$/;"	x
seed5_volatile	abstract-machine/apps/coremark/src/core_portme.c	/^	volatile ee_s32 seed5_volatile=0;$/;"	v
seed5_volatile	abstract-machine/apps/coremark/src/core_util.c	/^	extern volatile ee_s32 seed5_volatile;$/;"	x
segment_a	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t segment_a;$/;"	m	struct:VBEInfo	file:	access:public
segment_b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t segment_b;$/;"	m	struct:VBEInfo	file:	access:public
select_end	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int select_end;$/;"	m	struct:__anon34	access:public
select_start	abstract-machine/libs/imgui/include/stb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon34	access:public
set_cr0	abstract-machine/am/include/x86.h	/^static inline void set_cr0(uint32_t cr0) {$/;"	f	signature:(uint32_t cr0)
set_cr3	abstract-machine/am/include/x86.h	/^static inline void set_cr3(void *pdir) {$/;"	f	signature:(void *pdir)
set_fps	abstract-machine/apps/typing/game.c	/^void set_fps(int value) {$/;"	f	signature:(int value)
set_fps	abstract-machine/apps/typing/game.h	/^void set_fps(int fps);$/;"	p	signature:(int fps)
set_gdt	abstract-machine/am/include/x86.h	/^static inline void set_gdt(SegDesc *gdt, int size) {$/;"	f	signature:(SegDesc *gdt, int size)
set_idt	abstract-machine/am/include/x86.h	/^static inline void set_idt(GateDesc *idt, int size) {$/;"	f	signature:(GateDesc *idt, int size)
set_tr	abstract-machine/am/include/x86.h	/^static inline void set_tr(int selector) {$/;"	f	signature:(int selector)
setting	abstract-machine/apps/microbench/include/benchmark.h	/^extern Setting *setting;$/;"	x
setting	abstract-machine/apps/microbench/src/bench.c	/^Setting *setting;$/;"	v
settings	abstract-machine/apps/microbench/include/benchmark.h	/^  Setting settings[2];$/;"	m	struct:Benchmark	access:public
shentsize	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shentsize;$/;"	m	struct:ELFHeader	file:	access:public
shm_mmap	abstract-machine/am/src/native/platform.cpp	/^void shm_mmap(void *va, void *pa, int prot) {$/;"	f	signature:(void *va, void *pa, int prot)
shm_mmap	abstract-machine/am/src/native/vme.c	/^void shm_mmap(void *va, void *pa, int prot);$/;"	p	file:	signature:(void *va, void *pa, int prot)
shm_munmap	abstract-machine/am/src/native/platform.cpp	/^void shm_munmap(void *va) {$/;"	f	signature:(void *va)
shm_munmap	abstract-machine/am/src/native/vme.c	/^void shm_munmap(void *va);$/;"	p	file:	signature:(void *va)
shnum	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shnum;$/;"	m	struct:ELFHeader	file:	access:public
shoff	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t shoff;$/;"	m	struct:ELFHeader	file:	access:public
shstrndx	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t shstrndx;$/;"	m	struct:ELFHeader	file:	access:public
si_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef      int si_int;$/;"	t
si_int	abstract-machine/libs/compiler-rt/int_types.h	25;"	d
signature	abstract-machine/am/include/x86.h	/^  uint8_t  signature[4];    \/\/ "PCMP"$/;"	m	struct:MPConf	access:public
signature	abstract-machine/apps/litenes/src/fce.c	/^    char signature[4];$/;"	m	struct:__anon1	file:	access:public
sin	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  sin() { return Fix16(fix16_sin(value));  }$/;"	f	class:Fix16	access:public	signature:()
single_line	abstract-machine/libs/imgui/include/stb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon34	access:public
size	abstract-machine/apps/coremark/include/coremark.h	/^	ee_u32	size;		\/* Size of the data *\/$/;"	m	struct:RESULTS_S	access:public
size	abstract-machine/apps/microbench/include/benchmark.h	/^  int size;$/;"	m	struct:Setting	access:public
size	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int size() const;$/;"	p	class:Updatable_heap	access:public	signature:() const
size	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::size() const {$/;"	f	class:Updatable_heap	signature:() const
size	abstract-machine/libs/imgui/include/imgui.h	/^    inline int                  size() const                    { return Size; }$/;"	f	class:ImVector	access:public	signature:() const
size	abstract-machine/libs/imgui/include/imgui.h	/^    int                 size() const { return Buf.Size - 1; }$/;"	f	struct:ImGuiTextBuffer	access:public	signature:() const
size	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int size;$/;"	m	struct:__anon41	access:public
smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const Fix16 &other)  const { Fix16 ret = fix16_smul(value, other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const double other)  const { Fix16 ret = fix16_smul(value, fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const fix16_t other) const { Fix16 ret = fix16_smul(value, other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const float other)   const { Fix16 ret = fix16_smul(value, fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
smul	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 smul(const int16_t other) const { Fix16 ret = fix16_smul(value, fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
snprintf	abstract-machine/libs/imgui/src/imgui_demo.cpp	23;"	d	file:
snprintf	abstract-machine/libs/imgui/src/imgui_draw.cpp	23;"	d	file:
snprintf	abstract-machine/libs/klib/include/klib.h	/^int snprintf(char* s, size_t n, const char* format, ...);$/;"	p	signature:(char* s, size_t n, const char* format, ...)
snprintf	abstract-machine/libs/klib/include/klib.h	26;"	d
snprintf	abstract-machine/libs/klib/src/stdio.c	/^int snprintf(char *out, size_t n, const char *fmt, ...) {$/;"	f	signature:(char *out, size_t n, const char *fmt, ...)
solution	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle static solution();$/;"	p	class:N_puzzle	access:public	signature:()
solution	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::solution() {$/;"	f	class:N_puzzle	signature:()
solvable	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool solvable() const;$/;"	p	class:N_puzzle	access:public	signature:() const
solvable	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::solvable() const {$/;"	f	class:N_puzzle	signature:() const
son	pstree/pstree.c	/^    int son[100];$/;"	m	struct:PROC	file:	access:public
specrev	abstract-machine/am/include/x86.h	/^  uint8_t specrev;  \/\/ [14]$/;"	m	struct:MPDesc	access:public
splash	amgame/src/game.c	/^void splash() {$/;"	f
splash	amgame/src/game.c	/^void splash();$/;"	p	file:
split	abstract-machine/libs/imgui/include/imgui.h	/^        IMGUI_API void split(char separator, ImVector<TextRange>& out);$/;"	p	struct:ImGuiTextFilter::TextRange	access:public	signature:(char separator, ImVector<TextRange>& out)
split	abstract-machine/libs/imgui/src/imgui.cpp	/^void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)$/;"	f	class:ImGuiTextFilter::TextRange	signature:(char separator, ImVector<TextRange>& out)
sprintf	abstract-machine/libs/klib/include/klib.h	/^int sprintf(char* out, const char* format, ...);$/;"	p	signature:(char* out, const char* format, ...)
sprintf	abstract-machine/libs/klib/include/klib.h	25;"	d
sprintf	abstract-machine/libs/klib/src/stdio.c	/^int sprintf(char *out, const char *fmt, ...) {$/;"	f	signature:(char *out, const char *fmt, ...)
sqrt	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16 sqrt() { return Fix16(fix16_sqrt(value)); }$/;"	f	class:Fix16	access:public	signature:()
srand	abstract-machine/libs/klib/include/klib.h	/^void srand(unsigned int seed);$/;"	p	signature:(unsigned int seed)
srand	abstract-machine/libs/klib/src/stdlib.c	/^void srand(unsigned int seed) {$/;"	f	signature:(unsigned int seed)
ss	abstract-machine/am/include/arch/x86-qemu.h	/^           cs, ds, es, ss,$/;"	m	struct:_Context	access:public
ss	abstract-machine/am/include/x86.h	/^  uint32_t esp, ss;              \/\/ Used only when returning to DPL=3$/;"	m	struct:TrapFrame	access:public
ss0	abstract-machine/am/include/arch/x86-qemu.h	/^           ss0, esp0;$/;"	m	struct:_Context	access:public
ss0	abstract-machine/am/include/x86.h	/^  uint32_t ss0;      \/\/   after an increase in privilege level$/;"	m	struct:TSS	access:public
ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const Fix16 &other)  const { Fix16 ret = fix16_sadd(value, -other.value);             return ret; }$/;"	f	class:Fix16	access:public	signature:(const Fix16 &other) const
ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const double other)  const { Fix16 ret = fix16_sadd(value, -fix16_from_dbl(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const double other) const
ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const fix16_t other) const { Fix16 ret = fix16_sadd(value, -other);                   return ret; }$/;"	f	class:Fix16	access:public	signature:(const fix16_t other) const
ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const float other)   const { Fix16 ret = fix16_sadd(value, -fix16_from_float(other)); return ret; }$/;"	f	class:Fix16	access:public	signature:(const float other) const
ssub	abstract-machine/libs/fixmath/include/fix16.hpp	/^		const Fix16 ssub(const int16_t other) const { Fix16 ret = fix16_sadd(value, -fix16_from_int(other));   return ret; }$/;"	f	class:Fix16	access:public	signature:(const int16_t other) const
stack	abstract-machine/am/src/x86/x86-qemu.h	/^  uint8_t stack[4096];$/;"	m	struct:cpu_local	access:public
start	abstract-machine/am/am.h	/^  void *start, *end;$/;"	m	struct:_Area	access:public
start32	abstract-machine/am/src/x86/qemu/boot/start.S	/^start32:$/;"	l
start_time	abstract-machine/apps/coremark/include/coremark.h	/^void start_time(void);$/;"	p	signature:(void)
start_time	abstract-machine/apps/coremark/src/core_portme.c	/^void start_time(void) {$/;"	f	signature:(void)
start_time_val	abstract-machine/apps/coremark/src/core_portme.c	/^unsigned long start_time_val, stop_time_val;$/;"	v
started	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int started;$/;"	m	struct:__anon55	access:public
state	abstract-machine/apps/microbench/src/lzip/lzip.c	/^static qlz_state_compress *state;$/;"	v	file:
state_known_crc	abstract-machine/apps/coremark/src/core_main.c	/^static ee_u16 state_known_crc[]  =      {(ee_u16)0x5e47,(ee_u16)0x39bf,(ee_u16)0xe5a4,(ee_u16)0x8e3a,(ee_u16)0x8d84};$/;"	v	file:
static_memblk	abstract-machine/apps/coremark/src/core_main.c	/^ee_u8 static_memblk[TOTAL_DATA_SIZE];$/;"	v
stb__barrier	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier2	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier3	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__barrier4	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb__barrier, *stb__barrier2, *stb__barrier3, *stb__barrier4;$/;"	v	file:
stb__dout	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb__dout;$/;"	v	file:
stb__in2	abstract-machine/libs/imgui/src/imgui_draw.cpp	2221;"	d	file:
stb__in3	abstract-machine/libs/imgui/src/imgui_draw.cpp	2222;"	d	file:
stb__in4	abstract-machine/libs/imgui/src/imgui_draw.cpp	2223;"	d	file:
stb__lit	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static void stb__lit(unsigned char *data, unsigned int length)$/;"	f	file:	signature:(unsigned char *data, unsigned int length)
stb__match	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static void stb__match(unsigned char *data, unsigned int length)$/;"	f	file:	signature:(unsigned char *data, unsigned int length)
stb_adler32	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)$/;"	f	file:	signature:(unsigned int adler32, unsigned char *buffer, unsigned int buflen)
stb_decompress	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length)$/;"	f	file:	signature:(unsigned char *output, unsigned char *i, unsigned int length)
stb_decompress	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int stb_decompress(unsigned char *output, unsigned char *i, unsigned int length);$/;"	p	file:	signature:(unsigned char *output, unsigned char *i, unsigned int length)
stb_decompress_length	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int stb_decompress_length(unsigned char *input)$/;"	f	file:	signature:(unsigned char *input)
stb_decompress_length	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned int stb_decompress_length(unsigned char *input);$/;"	p	file:	signature:(unsigned char *input)
stb_decompress_token	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^static unsigned char *stb_decompress_token(unsigned char *i)$/;"	f	file:	signature:(unsigned char *i)
stb_text_create_undo_record	abstract-machine/libs/imgui/include/stb_textedit.h	/^static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)$/;"	f	signature:(StbUndoState *state, int numchars)
stb_text_createundo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)$/;"	f	signature:(StbUndoState *state, int pos, int insert_len, int delete_len)
stb_text_locate_coord	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, float x, float y)
stb_text_makeundo_delete	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
stb_text_makeundo_delete	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)
stb_text_makeundo_insert	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)$/;"	f	signature:(STB_TexteditState *state, int where, int length)
stb_text_makeundo_insert	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length);$/;"	p	signature:(STB_TexteditState *state, int where, int length)
stb_text_makeundo_replace	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
stb_text_makeundo_replace	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)
stb_text_redo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_redo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_undo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_text_undo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state);$/;"	p	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_clamp	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_clear_state	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)$/;"	f	signature:(STB_TexteditState *state, int is_single_line)
stb_textedit_click	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
stb_textedit_cut	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_delete	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)
stb_textedit_delete_selection	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_discard_redo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_discard_redo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_discard_undo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_discard_undo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_drag	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
stb_textedit_find_charpos	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)$/;"	f	signature:(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)
stb_textedit_flush_redo	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_flush_redo(StbUndoState *state)$/;"	f	signature:(StbUndoState *state)
stb_textedit_initialize_state	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)$/;"	f	signature:(STB_TexteditState *state, int is_single_line)
stb_textedit_key	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)
stb_textedit_move_to_first	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_move_to_first(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stb_textedit_move_to_last	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
stb_textedit_move_to_word_next	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )$/;"	f	signature:( STB_TEXTEDIT_STRING *str, int c )
stb_textedit_move_to_word_previous	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )$/;"	f	signature:( STB_TEXTEDIT_STRING *str, int c )
stb_textedit_paste	abstract-machine/libs/imgui/include/stb_textedit.h	/^static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)$/;"	f	signature:(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)
stb_textedit_prep_selection_at_cursor	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stb_textedit_sortselection	abstract-machine/libs/imgui/include/stb_textedit.h	/^static void stb_textedit_sortselection(STB_TexteditState *state)$/;"	f	signature:(STB_TexteditState *state)
stbrp__findresult	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^} stbrp__findresult;$/;"	t	typeref:struct:__anon39
stbrp__skyline_find_best_pos	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)$/;"	f	signature:(stbrp_context *c, int width, int height)
stbrp__skyline_find_min_y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)$/;"	f	signature:(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)
stbrp__skyline_pack_rectangle	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)$/;"	f	signature:(stbrp_context *context, int width, int height)
stbrp_context	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^struct stbrp_context$/;"	s
stbrp_context	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^typedef struct stbrp_context stbrp_context;$/;"	t	typeref:struct:stbrp_context
stbrp_context	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbrp_context;$/;"	t	typeref:struct:__anon57
stbrp_context::active_head	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context	access:public
stbrp_context::align	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int align;$/;"	m	struct:stbrp_context	access:public
stbrp_context::extra	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context	access:public
stbrp_context::free_head	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context	access:public
stbrp_context::height	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int height;$/;"	m	struct:stbrp_context	access:public
stbrp_context::heuristic	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int heuristic;$/;"	m	struct:stbrp_context	access:public
stbrp_context::init_mode	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int init_mode;$/;"	m	struct:stbrp_context	access:public
stbrp_context::num_nodes	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context	access:public
stbrp_context::width	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int width;$/;"	m	struct:stbrp_context	access:public
stbrp_coord	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^typedef int            stbrp_coord;$/;"	t
stbrp_coord	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^typedef unsigned short stbrp_coord;$/;"	t
stbrp_coord	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef int stbrp_coord;$/;"	t
stbrp_init_target	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_init_target (stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes);$/;"	p	signature:(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
stbrp_init_target	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)$/;"	f	signature:(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)
stbrp_init_target	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)$/;"	f	signature:(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)
stbrp_node	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^struct stbrp_node$/;"	s
stbrp_node	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^typedef struct stbrp_node    stbrp_node;$/;"	t	typeref:struct:stbrp_node
stbrp_node	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbrp_node;$/;"	t	typeref:struct:__anon58
stbrp_node::next	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node	access:public
stbrp_node::x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
stbrp_node::y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
stbrp_pack_rects	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_pack_rects (stbrp_context *context, stbrp_rect *rects, int num_rects);$/;"	p	signature:(stbrp_context *context, stbrp_rect *rects, int num_rects)
stbrp_pack_rects	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbrp_context *context, stbrp_rect *rects, int num_rects)
stbrp_pack_rects	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbrp_context *con, stbrp_rect *rects, int num_rects)
stbrp_rect	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^struct stbrp_rect$/;"	s
stbrp_rect	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^typedef struct stbrp_rect    stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect	abstract-machine/libs/imgui/include/stb_truetype.h	/^struct stbrp_rect$/;"	s
stbrp_rect	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbrp_rect stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect::h	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::h	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::id	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int            id;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::id	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::w	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::w	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::was_packed	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::was_packed	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
stbrp_rect::y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
stbrp_setup_allow_out_of_mem	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem (stbrp_context *context, int allow_out_of_mem);$/;"	p	signature:(stbrp_context *context, int allow_out_of_mem)
stbrp_setup_allow_out_of_mem	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)$/;"	f	signature:(stbrp_context *context, int allow_out_of_mem)
stbrp_setup_heuristic	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_heuristic (stbrp_context *context, int heuristic);$/;"	p	signature:(stbrp_context *context, int heuristic)
stbrp_setup_heuristic	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)$/;"	f	signature:(stbrp_context *context, int heuristic)
stbtt_BakeFontBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	p	signature:(const unsigned char *data, int offset, float pixel_height, unsigned char *pixels, int pw, int ph, int first_char, int num_chars, stbtt_bakedchar *chardata)
stbtt_BakeFontBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,$/;"	f	signature:(const unsigned char *data, int offset, float pixel_height, unsigned char *pixels, int pw, int ph, int first_char, int num_chars, stbtt_bakedchar *chardata)
stbtt_BakeFontBitmap_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f	signature:(unsigned char *data, int offset, float pixel_height, unsigned char *pixels, int pw, int ph, int first_char, int num_chars, stbtt_bakedchar *chardata)
stbtt_CompareUTF8toUTF16_bigendian	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)$/;"	f	signature:(const char *s1, int len1, const char *s2, int len2)
stbtt_CompareUTF8toUTF16_bigendian	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2);$/;"	p	signature:(const char *s1, int len1, const char *s2, int len2)
stbtt_CompareUTF8toUTF16_bigendian_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) $/;"	f	signature:(char *s1, int len1, char *s2, int len2)
stbtt_FindGlyphIndex	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, int unicode_codepoint)
stbtt_FindGlyphIndex	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, int unicode_codepoint)
stbtt_FindMatchingFont	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)$/;"	f	signature:(const unsigned char *fontdata, const char *name, int flags)
stbtt_FindMatchingFont	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags);$/;"	p	signature:(const unsigned char *fontdata, const char *name, int flags)
stbtt_FindMatchingFont_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)$/;"	f	signature:(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)
stbtt_FlattenCurves	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f	signature:(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)
stbtt_FreeBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f	signature:(unsigned char *bitmap, void *userdata)
stbtt_FreeBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata);$/;"	p	signature:(unsigned char *bitmap, void *userdata)
stbtt_FreeShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f	signature:(const stbtt_fontinfo *info, stbtt_vertex *v)
stbtt_FreeShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *vertices);$/;"	p	signature:(const stbtt_fontinfo *info, stbtt_vertex *vertices)
stbtt_GetBakedQuad	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph,  \/\/ same data as above$/;"	p	signature:(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
stbtt_GetBakedQuad	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f	signature:(stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)
stbtt_GetCodepointBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmapBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBoxSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapBoxSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetCodepointBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)
stbtt_GetCodepointBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
stbtt_GetCodepointBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)
stbtt_GetCodepointHMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f	signature:(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
stbtt_GetCodepointHMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing);$/;"	p	signature:(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)
stbtt_GetCodepointKernAdvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f	signature:(const stbtt_fontinfo *info, int ch1, int ch2)
stbtt_GetCodepointKernAdvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2);$/;"	p	signature:(const stbtt_fontinfo *info, int ch1, int ch2)
stbtt_GetCodepointShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f	signature:(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
stbtt_GetCodepointShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices);$/;"	p	signature:(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)
stbtt_GetFontBoundingBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
stbtt_GetFontBoundingBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)
stbtt_GetFontNameString	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f	signature:(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
stbtt_GetFontNameString	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID);$/;"	p	signature:(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)
stbtt_GetFontOffsetForIndex	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)$/;"	f	signature:(const unsigned char *data, int index)
stbtt_GetFontOffsetForIndex	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index);$/;"	p	signature:(const unsigned char *data, int index)
stbtt_GetFontOffsetForIndex_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)$/;"	f	signature:(unsigned char *font_collection, int index)
stbtt_GetFontVMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f	signature:(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
stbtt_GetFontVMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap);$/;"	p	signature:(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)
stbtt_GetGlyphBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmapBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBoxSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapBoxSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1);$/;"	p	signature:(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)
stbtt_GetGlyphBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff);$/;"	p	signature:(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)
stbtt_GetGlyphBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt_GetGlyphBox	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt_GetGlyphHMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
stbtt_GetGlyphHMetrics	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)
stbtt_GetGlyphKernAdvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph1, int glyph2)
stbtt_GetGlyphKernAdvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph1, int glyph2)
stbtt_GetGlyphShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
stbtt_GetGlyphShape	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **vertices)
stbtt_GetNumberOfFonts	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)$/;"	f	signature:(const unsigned char *data)
stbtt_GetNumberOfFonts	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data);$/;"	p	signature:(const unsigned char *data)
stbtt_GetNumberOfFonts_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)$/;"	f	signature:(unsigned char *font_collection)
stbtt_GetPackedQuad	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph,  \/\/ same data as above$/;"	p	signature:(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
stbtt_GetPackedQuad	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)$/;"	f	signature:(stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)
stbtt_InitFont	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)$/;"	f	signature:(stbtt_fontinfo *info, const unsigned char *data, int offset)
stbtt_InitFont	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset);$/;"	p	signature:(stbtt_fontinfo *info, const unsigned char *data, int offset)
stbtt_InitFont_internal	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)$/;"	f	signature:(stbtt_fontinfo *info, unsigned char *data, int fontstart)
stbtt_IsGlyphEmpty	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt_IsGlyphEmpty	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt_MakeCodepointBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
stbtt_MakeCodepointBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
stbtt_MakeCodepointBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
stbtt_MakeCodepointBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
stbtt_MakeGlyphBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
stbtt_MakeGlyphBitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
stbtt_MakeGlyphBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
stbtt_MakeGlyphBitmapSubpixel	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);$/;"	p	signature:(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
stbtt_PackBegin	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context);$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *pixels, int width, int height, int stride_in_bytes, int padding, void *alloc_context)
stbtt_PackBegin	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)
stbtt_PackEnd	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)$/;"	f	signature:(stbtt_pack_context *spc)
stbtt_PackEnd	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc);$/;"	p	signature:(stbtt_pack_context *spc)
stbtt_PackFontRange	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size, int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
stbtt_PackFontRange	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size,$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, float font_size, int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar *chardata_for_range)
stbtt_PackFontRanges	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges);$/;"	p	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
stbtt_PackFontRanges	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)$/;"	f	signature:(stbtt_pack_context *spc, unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)
stbtt_PackFontRangesGatherRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);$/;"	p	signature:(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesGatherRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f	signature:(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesPackRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)$/;"	f	signature:(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
stbtt_PackFontRangesPackRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects);$/;"	p	signature:(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)
stbtt_PackFontRangesRenderIntoRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects);$/;"	p	signature:(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackFontRangesRenderIntoRects	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f	signature:(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)
stbtt_PackSetOversampling	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)$/;"	f	signature:(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
stbtt_PackSetOversampling	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample);$/;"	p	signature:(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)
stbtt_Rasterize	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result,        \/\/ 1-channel bitmap to draw into$/;"	p	signature:(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
stbtt_Rasterize	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)
stbtt_ScaleForMappingEmToPixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f	signature:(const stbtt_fontinfo *info, float pixels)
stbtt_ScaleForMappingEmToPixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels);$/;"	p	signature:(const stbtt_fontinfo *info, float pixels)
stbtt_ScaleForPixelHeight	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f	signature:(const stbtt_fontinfo *info, float height)
stbtt_ScaleForPixelHeight	abstract-machine/libs/imgui/include/stb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float pixels);$/;"	p	signature:(const stbtt_fontinfo *info, float pixels)
stbtt__CompareUTF8toUTF16_bigendian_prefix	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f	signature:(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2)
stbtt__GetGlyfOffset	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt__GetGlyphInfoT2	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt__GetGlyphInfoT2	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1);$/;"	p	signature:(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)
stbtt__GetGlyphShapeT2	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
stbtt__GetGlyphShapeTT	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)
stbtt__active_edge	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__active_edge::direction	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::direction	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::dx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::ey	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fdx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fdy	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::fx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::next	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge	access:public
stbtt__active_edge::sy	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__active_edge::x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
stbtt__add_point	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f	signature:(stbtt__point *points, int n, float x, float y)
stbtt__bitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon48
stbtt__buf	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__buf;$/;"	t	typeref:struct:__anon41
stbtt__buf_get	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)$/;"	f	signature:(stbtt__buf *b, int n)
stbtt__buf_get16	abstract-machine/libs/imgui/include/stb_truetype.h	1021;"	d
stbtt__buf_get32	abstract-machine/libs/imgui/include/stb_truetype.h	1022;"	d
stbtt__buf_get8	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)$/;"	f	signature:(stbtt__buf *b)
stbtt__buf_peek8	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)$/;"	f	signature:(stbtt__buf *b)
stbtt__buf_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)$/;"	f	signature:(const stbtt__buf *b, int o, int s)
stbtt__buf_seek	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__buf_seek(stbtt__buf *b, int o)$/;"	f	signature:(stbtt__buf *b, int o)
stbtt__buf_skip	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__buf_skip(stbtt__buf *b, int o)$/;"	f	signature:(stbtt__buf *b, int o)
stbtt__cff_get_index	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)$/;"	f	signature:(stbtt__buf *b)
stbtt__cff_index_count	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__cff_index_count(stbtt__buf *b)$/;"	f	signature:(stbtt__buf *b)
stbtt__cff_index_get	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)$/;"	f	signature:(stbtt__buf b, int i)
stbtt__cff_int	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)$/;"	f	signature:(stbtt__buf *b)
stbtt__cff_skip_operand	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__cff_skip_operand(stbtt__buf *b) {$/;"	f	signature:(stbtt__buf *b)
stbtt__check_size16	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__cid_get_glyph_subrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index)
stbtt__close_shape	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f	signature:(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off, stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
stbtt__csctx	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__csctx;$/;"	t	typeref:struct:__anon55
stbtt__csctx_close_shape	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__csctx_close_shape(stbtt__csctx *ctx)$/;"	f	signature:(stbtt__csctx *ctx)
stbtt__csctx_rccurve_to	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)$/;"	f	signature:(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
stbtt__csctx_rline_to	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f	signature:(stbtt__csctx *ctx, float dx, float dy)
stbtt__csctx_rmove_to	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f	signature:(stbtt__csctx *ctx, float dx, float dy)
stbtt__csctx_v	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)$/;"	f	signature:(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
stbtt__dict_get	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)$/;"	f	signature:(stbtt__buf *b, int key)
stbtt__dict_get_ints	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)$/;"	f	signature:(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)
stbtt__edge	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__edge::invert	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__edge::y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
stbtt__fill_active_edges	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f	signature:(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)
stbtt__fill_active_edges_new	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)$/;"	f	signature:(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)
stbtt__find_table	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f	signature:(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)
stbtt__get_subr	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)$/;"	f	signature:(stbtt__buf idx, int n)
stbtt__get_subrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)$/;"	f	signature:(stbtt__buf cff, stbtt__buf fontdict)
stbtt__h_prefilter	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f	signature:(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
stbtt__handle_clipped_edge	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)$/;"	f	signature:(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)
stbtt__hheap	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt__hheap$/;"	s
stbtt__hheap	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__hheap;$/;"	t	typeref:struct:stbtt__hheap
stbtt__hheap::first_free	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap	access:public
stbtt__hheap::head	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk	access:public
stbtt__hheap::num_remaining_in_head_chunk	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap	access:public
stbtt__hheap_alloc	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, size_t size, void *userdata)
stbtt__hheap_chunk	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt__hheap_chunk$/;"	s
stbtt__hheap_chunk	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__hheap_chunk;$/;"	t	typeref:struct:stbtt__hheap_chunk
stbtt__hheap_chunk::next	abstract-machine/libs/imgui/include/stb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk	access:public
stbtt__hheap_cleanup	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, void *userdata)
stbtt__hheap_free	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__hheap_free(stbtt__hheap *hh, void *p)$/;"	f	signature:(stbtt__hheap *hh, void *p)
stbtt__isfont	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__isfont(stbtt_uint8 *font)$/;"	f	signature:(stbtt_uint8 *font)
stbtt__matches	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f	signature:(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)
stbtt__matchpair	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f	signature:(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
stbtt__new_active	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f	signature:(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)
stbtt__new_buf	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt__buf stbtt__new_buf(const void *p, size_t size)$/;"	f	signature:(const void *p, size_t size)
stbtt__oversample_shift	abstract-machine/libs/imgui/include/stb_truetype.h	/^static float stbtt__oversample_shift(int oversample)$/;"	f	signature:(int oversample)
stbtt__point	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon56
stbtt__rasterize	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)
stbtt__rasterize_sorted_edges	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f	signature:(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)
stbtt__run_charstring	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)$/;"	f	signature:(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)
stbtt__sort_edges	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__sort_edges(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__sort_edges_ins_sort	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__sort_edges_quicksort	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)$/;"	f	signature:(stbtt__edge *p, int n)
stbtt__tesselate_cubic	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)$/;"	f	signature:(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
stbtt__tesselate_curve	abstract-machine/libs/imgui/include/stb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f	signature:(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
stbtt__test_oversample_pow2	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];$/;"	t
stbtt__track_vertex	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)$/;"	f	signature:(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)
stbtt__v_prefilter	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f	signature:(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
stbtt_aligned_quad	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon43
stbtt_bakedchar	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon42
stbtt_fontinfo	abstract-machine/libs/imgui/include/stb_truetype.h	/^struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt_fontinfo stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_fontinfo::cff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf cff;                    \/\/ cff font data$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::charstrings	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf charstrings;            \/\/ the charstring index$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::data	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::fdselect	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf fdselect;               \/\/ map from glyph to fontdict$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::fontdicts	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf fontdicts;              \/\/ array of font dicts$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::fontstart	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::glyf	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::gsubrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf gsubrs;                 \/\/ global charstring subroutines index$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::head	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::hhea	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::hmtx	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::indexToLocFormat	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::index_map	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::kern	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::loca	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::numGlyphs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::subrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf subrs;                  \/\/ private charstring subroutines index$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_fontinfo::userdata	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo	access:public
stbtt_int16	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_pack_context	abstract-machine/libs/imgui/include/stb_truetype.h	/^struct stbtt_pack_context {$/;"	s
stbtt_pack_context	abstract-machine/libs/imgui/include/stb_truetype.h	/^typedef struct stbtt_pack_context stbtt_pack_context;$/;"	t	typeref:struct:stbtt_pack_context
stbtt_pack_context::h_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::height	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::nodes	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::pack_info	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::padding	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::pixels	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::stride_in_bytes	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::user_allocator_context	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::v_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_context::width	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context	access:public
stbtt_pack_range	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt_pack_range;$/;"	t	typeref:struct:__anon45
stbtt_packedchar	abstract-machine/libs/imgui/include/stb_truetype.h	/^} stbtt_packedchar;$/;"	t	typeref:struct:__anon44
stbtt_setvertex	abstract-machine/libs/imgui/include/stb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f	signature:(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
stbtt_tag	abstract-machine/libs/imgui/include/stb_truetype.h	1135;"	d
stbtt_tag4	abstract-machine/libs/imgui/include/stb_truetype.h	1134;"	d
stbtt_uint16	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	abstract-machine/libs/imgui/include/stb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	abstract-machine/libs/imgui/include/stb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon47
stbtt_vertex_type	abstract-machine/libs/imgui/include/stb_truetype.h	746;"	d
sti	abstract-machine/am/include/x86.h	/^static inline void sti() {$/;"	f	signature:()
stop_time	abstract-machine/apps/coremark/include/coremark.h	/^void stop_time(void);$/;"	p	signature:(void)
stop_time	abstract-machine/apps/coremark/src/core_portme.c	/^void stop_time(void) {$/;"	f	signature:(void)
stop_time_val	abstract-machine/apps/coremark/src/core_portme.c	/^unsigned long start_time_val, stop_time_val;$/;"	v
str	abstract-machine/apps/microbench/src/md5/md5.c	/^static uint8_t *str;$/;"	v	file:
strcat	abstract-machine/libs/klib/include/klib.h	/^char* strcat(char* dst, const char* src);$/;"	p	signature:(char* dst, const char* src)
strcat	abstract-machine/libs/klib/include/klib.h	17;"	d
strcat	abstract-machine/libs/klib/src/string.c	/^char* strcat(char* dst, const char* src) {$/;"	f	signature:(char* dst, const char* src)
strcmp	abstract-machine/libs/klib/include/klib.h	/^int strcmp(const char* s1, const char* s2);$/;"	p	signature:(const char* s1, const char* s2)
strcmp	abstract-machine/libs/klib/include/klib.h	18;"	d
strcmp	abstract-machine/libs/klib/src/string.c	/^int strcmp(const char* s1, const char* s2) {$/;"	f	signature:(const char* s1, const char* s2)
strcpy	abstract-machine/libs/klib/include/klib.h	/^char* strcpy(char* dst, const char* src);$/;"	p	signature:(char* dst, const char* src)
strcpy	abstract-machine/libs/klib/include/klib.h	15;"	d
strcpy	abstract-machine/libs/klib/src/string.c	/^char *strcpy(char* dst,const char* src) {$/;"	f	signature:(char* dst,const char* src)
stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon10	access:public
stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon8	access:public
stream_buffer	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		unsigned char stream_buffer[QLZ_STREAMING_BUFFER];$/;"	m	struct:__anon9	access:public
stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		size_t stream_counter;$/;"	m	struct:__anon10	access:public
stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^		size_t stream_counter;$/;"	m	struct:__anon9	access:public
stream_counter	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^	size_t stream_counter;$/;"	m	struct:__anon8	access:public
stride	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
stride_in_bytes	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context	access:public
strlen	abstract-machine/libs/klib/include/klib.h	/^size_t strlen(const char* s);$/;"	p	signature:(const char* s)
strlen	abstract-machine/libs/klib/include/klib.h	14;"	d
strlen	abstract-machine/libs/klib/src/string.c	/^size_t strlen(const char *s) {$/;"	f	signature:(const char *s)
strncmp	abstract-machine/libs/klib/include/klib.h	/^int strncmp(const char* s1, const char* s2, size_t n);$/;"	p	signature:(const char* s1, const char* s2, size_t n)
strncmp	abstract-machine/libs/klib/include/klib.h	19;"	d
strncmp	abstract-machine/libs/klib/src/string.c	/^int strncmp(const char* s1, const char* s2, size_t n) {$/;"	f	signature:(const char* s1, const char* s2, size_t n)
strncpy	abstract-machine/libs/klib/include/klib.h	/^char* strncpy(char* dst, const char* src, size_t n);$/;"	p	signature:(char* dst, const char* src, size_t n)
strncpy	abstract-machine/libs/klib/include/klib.h	16;"	d
strncpy	abstract-machine/libs/klib/src/string.c	/^char* strncpy(char* dst, const char* src, size_t n) {$/;"	f	signature:(char* dst, const char* src, size_t n)
structassign	abstract-machine/apps/dhrystone/dry.c	363;"	d	file:
structassign	abstract-machine/apps/dhrystone/dry.c	365;"	d	file:
su_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef unsigned su_int;$/;"	t
subrs	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbtt__buf subrs;                  \/\/ private charstring subroutines index$/;"	m	struct:stbtt_fontinfo	access:public
suffixArray	abstract-machine/apps/microbench/src/ssort/ssort.cpp	/^void suffixArray(int* s, int* SA, int n, int K) {$/;"	f	signature:(int* s, int* SA, int n, int K)
swap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    void inline swap( int, int );$/;"	p	class:Updatable_heap	access:private	signature:( int, int )
swap	abstract-machine/apps/microbench/src/15pz/heap.h	/^void inline Updatable_heap<T, M>::swap( int i, int j ) {$/;"	f	class:Updatable_heap	signature:( int i, int j )
swap	abstract-machine/apps/microbench/src/qsort/qsort.c	/^static void swap(int *a, int *b) {$/;"	f	file:	signature:(int *a, int *b)
swap	abstract-machine/libs/imgui/include/imgui.h	/^    inline void                 swap(ImVector<T>& rhs)          { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	class:ImVector	access:public	signature:(ImVector<T>& rhs)
sy	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge	access:public
t	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int n, m, s, t;$/;"	m	struct:Dinic	file:	access:public
t0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
t1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
table_init	abstract-machine/apps/litenes/src/ppu.c	/^static void table_init() {$/;"	f	file:
tan	abstract-machine/libs/fixmath/include/fix16.hpp	/^		Fix16  tan() { return Fix16(fix16_tan(value));  }$/;"	f	class:Fix16	access:public	signature:()
temp_bitmap	abstract-machine/libs/imgui/include/stb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
text	abstract-machine/apps/typing/game.h	/^	int text;$/;"	v
texture	abstract-machine/am/src/native/devices/video.c	/^static SDL_Texture *texture;$/;"	v	file:
texture_sync	abstract-machine/am/src/native/devices/video.c	/^static Uint32 texture_sync(Uint32 interval, void *param) {$/;"	f	file:	signature:(Uint32 interval, void *param)
thiscpu_halt	abstract-machine/am/src/x86/qemu/devices/cpu.c	/^void thiscpu_halt() {$/;"	f
thiscpu_halt	abstract-machine/am/src/x86/x86-qemu.h	/^void thiscpu_halt() __attribute__((__noreturn__));$/;"	p	signature:()
thiscpu_setstk0	abstract-machine/am/src/x86/qemu/devices/cpu.c	/^void thiscpu_setstk0(uintptr_t ss0, uintptr_t esp0) {$/;"	f	signature:(uintptr_t ss0, uintptr_t esp0)
thiscpu_setstk0	abstract-machine/am/src/x86/x86-qemu.h	/^void thiscpu_setstk0(uintptr_t ss0, uintptr_t esp0);$/;"	p	signature:(uintptr_t ss0, uintptr_t esp0)
ti_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef int      ti_int __attribute__ ((mode (TI)));$/;"	t
tile_down	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_down() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_down	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_down() const {$/;"	f	class:N_puzzle	signature:() const
tile_down_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_down_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_down_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_down_possible() const {$/;"	f	class:N_puzzle	signature:() const
tile_left	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_left() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_left	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_left() const {$/;"	f	class:N_puzzle	signature:() const
tile_left_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_left_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_left_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_left_possible() const {$/;"	f	class:N_puzzle	signature:() const
tile_right	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_right() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_right	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_right() const {$/;"	f	class:N_puzzle	signature:() const
tile_right_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_right_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_right_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_right_possible() const {$/;"	f	class:N_puzzle	signature:() const
tile_up	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    N_puzzle tile_up() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_up	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^N_puzzle<N> N_puzzle<N>::tile_up() const {$/;"	f	class:N_puzzle	signature:() const
tile_up_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool tile_up_possible() const;$/;"	p	class:N_puzzle	access:public	signature:() const
tile_up_possible	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::tile_up_possible() const {$/;"	f	class:N_puzzle	signature:() const
time	abstract-machine/am/amtrace.h	/^  uint32_t time;  \/\/ time stamp$/;"	m	struct:_TraceEvent	access:public
time_in_secs	abstract-machine/apps/coremark/include/coremark.h	/^secs_ret time_in_secs(CORE_TICKS ticks);$/;"	p	signature:(CORE_TICKS ticks)
time_in_secs	abstract-machine/apps/coremark/src/core_portme.c	/^secs_ret time_in_secs(CORE_TICKS ticks) {$/;"	f	signature:(CORE_TICKS ticks)
timer_init	abstract-machine/am/src/native/devices/timer.c	/^void timer_init() {$/;"	f
timer_init	abstract-machine/am/src/native/ioe.c	/^void timer_init();$/;"	p	file:
timer_init	abstract-machine/am/src/x86/qemu/devices/timer.c	/^void timer_init() {$/;"	f
timer_init	abstract-machine/am/src/x86/qemu/ioe.c	/^void timer_init();$/;"	p	file:
timer_read	abstract-machine/am/src/native/devices/timer.c	/^size_t timer_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
timer_read	abstract-machine/am/src/native/ioe.c	/^size_t timer_read(uintptr_t reg, void *buf, size_t size);$/;"	p	file:	signature:(uintptr_t reg, void *buf, size_t size)
timer_read	abstract-machine/am/src/x86/qemu/devices/timer.c	/^size_t timer_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
timer_read	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(timer_read);$/;"	v
tmp	abstract-machine/apps/microbench/src/fib/fib.c	/^static uint32_t *A, *ans, *T, *tmp;$/;"	v	file:
to	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  int from, to, cap, flow;$/;"	m	struct:Edge	file:	access:public
to_bytes	abstract-machine/apps/microbench/src/md5/md5.c	/^static void to_bytes(uint32_t val, uint8_t *bytes)$/;"	f	file:	signature:(uint32_t val, uint8_t *bytes)
to_int32	abstract-machine/apps/microbench/src/md5/md5.c	/^static uint32_t to_int32(const uint8_t *bytes)$/;"	f	file:	signature:(const uint8_t *bytes)
trace	abstract-machine/am/src/x86/qemu/trace.c	/^LOCKDEF(trace);$/;"	v
trace_flags	abstract-machine/am/src/x86/qemu/trace.c	/^volatile uint32_t trace_flags = 0; \/\/ current trace status$/;"	v
trap	abstract-machine/am/src/x86/qemu/cte_trap.S	/^trap:$/;"	l
trim_blanks	abstract-machine/libs/imgui/include/imgui.h	/^        void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e-1))) e--; }$/;"	f	struct:ImGuiTextFilter::TextRange	access:public	signature:()
true	abstract-machine/am/include/arch/native.h	13;"	d
true	abstract-machine/apps/dhrystone/dry.c	386;"	d	file:
true	abstract-machine/apps/litenes/include/common.h	11;"	d
true	abstract-machine/apps/microbench/include/benchmark.h	14;"	d
true	abstract-machine/apps/typing/game.h	103;"	d
tsc	abstract-machine/apps/microbench/include/benchmark.h	/^  unsigned long tsc, msec;$/;"	m	struct:Result	access:public
tss	abstract-machine/am/src/x86/x86-qemu.h	/^  TSS tss;$/;"	m	struct:cpu_local	access:public
ttBYTE	abstract-machine/libs/imgui/include/stb_truetype.h	1125;"	d
ttCHAR	abstract-machine/libs/imgui/include/stb_truetype.h	1126;"	d
ttFixed	abstract-machine/libs/imgui/include/stb_truetype.h	1127;"	d
ttLONG	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f	signature:(stbtt_uint8 *p)
ttSHORT	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f	signature:(stbtt_uint8 *p)
ttULONG	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f	signature:(stbtt_uint8 *p)
ttUSHORT	abstract-machine/libs/imgui/include/stb_truetype.h	/^static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f	signature:(stbtt_uint8 *p)
ttf_buffer	abstract-machine/libs/imgui/include/stb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
ttf_buffer	abstract-machine/libs/imgui/include/stb_truetype.h	/^unsigned char ttf_buffer[1<<20];$/;"	v
tu_int	abstract-machine/libs/compiler-rt/int_types.h	/^typedef unsigned tu_int __attribute__ ((mode (TI)));$/;"	t
twords	abstract-machine/libs/compiler-rt/int_types.h	/^} twords;$/;"	t	typeref:union:__anon20
type	abstract-machine/am/amtrace.h	/^  uint16_t type;  \/\/ _TRACE_ ## { CALL | RET }$/;"	m	struct:_TraceEvent	access:public
type	abstract-machine/am/include/x86.h	/^  uint32_t type : 4  ;     \/\/ Segment type (see STS_ constants)$/;"	m	struct:SegDesc	access:public
type	abstract-machine/am/include/x86.h	/^  uint32_t type : 4;        \/\/ Type(STS_{TG,IG32,TG32})$/;"	m	struct:GateDesc	access:public
type	abstract-machine/am/include/x86.h	/^  uint8_t type;     \/\/ config type$/;"	m	struct:MPDesc	access:public
type	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint16_t type;$/;"	m	struct:ELFHeader	file:	access:public
type	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t type;$/;"	m	struct:ProgramHeader	file:	access:public
type	abstract-machine/libs/imgui/include/stb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon47	access:public
u	abstract-machine/libs/compiler-rt/int_types.h	/^    su_int u;$/;"	m	union:__anon24	access:public
u	abstract-machine/libs/compiler-rt/int_types.h	/^    udwords u;$/;"	m	union:__anon25	access:public
u	abstract-machine/libs/compiler-rt/int_types.h	/^    uqwords     u;$/;"	m	union:__anon27	access:public
uc	abstract-machine/am/include/arch/native.h	/^      ucontext_t uc;$/;"	m	struct:_Context::__anon63::__anon64	access:public
uc_example	abstract-machine/am/src/native/platform.cpp	/^static ucontext_t uc_example;$/;"	v	file:
ucontext	abstract-machine/am/src/x86/qemu/vme.c	/^_Context *ucontext(_AddressSpace *p, _Area ustack, _Area kstack,$/;"	f	signature:(_AddressSpace *p, _Area ustack, _Area kstack, void *entry, void *args)
udwords	abstract-machine/libs/compiler-rt/int_types.h	/^} udwords;$/;"	t	typeref:union:__anon18
ui16	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^typedef unsigned short int ui16;$/;"	t
ui32	abstract-machine/apps/microbench/src/lzip/quicklz.h	/^typedef unsigned int ui32;$/;"	t
uint32_log2	abstract-machine/libs/fixmath/include/uint32.h	/^extern uint32_t uint32_log2(uint32_t inVal);$/;"	p	signature:(uint32_t inVal)
uint32_log2	abstract-machine/libs/fixmath/src/uint32.c	/^uint32_t uint32_log2(uint32_t inVal) {$/;"	f	signature:(uint32_t inVal)
undo_char	abstract-machine/libs/imgui/include/stb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon33	access:public
undo_char_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_char_point, redo_char_point;$/;"	m	struct:__anon33	access:public
undo_point	abstract-machine/libs/imgui/include/stb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon33	access:public
undo_rec	abstract-machine/libs/imgui/include/stb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon33	access:public
undostate	abstract-machine/libs/imgui/include/stb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon34	access:public
unprotect	abstract-machine/am/src/x86/qemu/vme.c	/^void unprotect(_AddressSpace *p) {$/;"	f	signature:(_AddressSpace *p)
unused_bp	abstract-machine/apps/litenes/include/cpu.h	/^    unused_bp     = 5,$/;"	e	enum:__anon4
unused_flag	abstract-machine/apps/litenes/include/cpu.h	/^    unused_flag    = 0x20,$/;"	e	enum:__anon3
update_hash	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static __inline void update_hash(qlz_state_decompress *state, const unsigned char *s)$/;"	f	file:	signature:(qlz_state_decompress *state, const unsigned char *s)
update_hash_upto	abstract-machine/apps/microbench/src/lzip/quicklz.c	/^static void update_hash_upto(qlz_state_decompress *state, unsigned char **lh, const unsigned char *max)$/;"	f	file:	signature:(qlz_state_decompress *state, unsigned char **lh, const unsigned char *max)
update_keypress	abstract-machine/apps/typing/game.c	/^bool update_keypress() {$/;"	f
update_keypress	abstract-machine/apps/typing/game.h	/^bool update_keypress(void);$/;"	p	signature:(void)
update_letter_pos	abstract-machine/apps/typing/game.c	/^void update_letter_pos() {$/;"	f
update_letter_pos	abstract-machine/apps/typing/game.h	/^void update_letter_pos(void);$/;"	p	signature:(void)
uptime	abstract-machine/libs/klib/include/klib.h	/^uint32_t uptime();$/;"	p	signature:()
uptime	abstract-machine/libs/klib/src/io.c	/^uint32_t uptime() {$/;"	f
uptsc	abstract-machine/am/src/x86/qemu/devices/timer.c	/^uint64_t uptsc;$/;"	v
uqwords	abstract-machine/libs/compiler-rt/int_types.h	/^} uqwords;$/;"	t	typeref:struct:__anon26
user_allocator_context	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context	access:public
user_entry	abstract-machine/am/src/x86/qemu/mpe.c	/^static void (* volatile user_entry)();$/;"	v	file:
user_handler	abstract-machine/am/src/native/cte.c	/^static _Context* (*user_handler)(_Event, _Context*) = NULL;$/;"	v	file:
user_handler	abstract-machine/am/src/x86/qemu/cte.c	/^static _Context* (*user_handler)(_Event, _Context*) = NULL;$/;"	v	file:
userdata	abstract-machine/libs/imgui/include/stb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo	access:public
utwords	abstract-machine/libs/compiler-rt/int_types.h	/^} utwords;$/;"	t	typeref:union:__anon22
uv	abstract-machine/libs/imgui/include/imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert	access:public
uvm_area	abstract-machine/am/src/x86/qemu/vme.c	13;"	d	file:
v	abstract-machine/apps/typing/game.h	/^	int v;$/;"	v
v_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon45	access:public
v_oversample	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context	access:public
va_copy	abstract-machine/libs/imgui/src/imgui.cpp	1553;"	d	file:
vaddr	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t vaddr;$/;"	m	struct:ProgramHeader	file:	access:public
val_f	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
val_i	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
val_p	abstract-machine/libs/imgui/include/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::Pair::__anon59	access:public
valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    bool valid() const;$/;"	p	class:N_puzzle	access:public	signature:() const
valid	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^bool N_puzzle<N>::valid() const {$/;"	f	class:N_puzzle	signature:() const
validate	abstract-machine/apps/microbench/include/benchmark.h	/^  int (*validate)();$/;"	m	struct:Benchmark	access:public
value	abstract-machine/libs/fixmath/include/fix16.hpp	/^		fix16_t value;$/;"	m	class:Fix16	access:public
value_type	abstract-machine/libs/imgui/include/imgui.h	/^    typedef T                   value_type;$/;"	t	class:ImVector	access:public
var_1	abstract-machine/apps/dhrystone/dry.c	/^                  } var_1;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon13	file:	access:public
var_2	abstract-machine/apps/dhrystone/dry.c	/^                  } var_2;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon14	file:	access:public
var_3	abstract-machine/apps/dhrystone/dry.c	/^                  } var_3;$/;"	m	union:record::__anon12	typeref:struct:record::__anon12::__anon15	file:	access:public
variant	abstract-machine/apps/dhrystone/dry.c	/^          } variant;$/;"	m	struct:record	typeref:union:record::__anon12	file:	access:public
version	abstract-machine/am/include/x86.h	/^  uint8_t  version;         \/\/ [14]$/;"	m	struct:MPConf	access:public
version	abstract-machine/am/src/x86/qemu/boot/main.c	/^	uint32_t version;$/;"	m	struct:ELFHeader	file:	access:public
vga_init	abstract-machine/am/src/x86/qemu/devices/video.c	/^void vga_init() {$/;"	f
vga_init	abstract-machine/am/src/x86/qemu/ioe.c	/^void vga_init();$/;"	p	file:
video_init	abstract-machine/am/src/native/devices/video.c	/^void video_init() {$/;"	f
video_init	abstract-machine/am/src/native/ioe.c	/^void video_init();$/;"	p	file:
video_read	abstract-machine/am/src/native/devices/video.c	/^size_t video_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
video_read	abstract-machine/am/src/native/ioe.c	/^size_t video_read(uintptr_t reg, void *buf, size_t size);$/;"	p	file:	signature:(uintptr_t reg, void *buf, size_t size)
video_read	abstract-machine/am/src/x86/qemu/devices/video.c	/^size_t video_read(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
video_read	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(video_read);$/;"	v
video_write	abstract-machine/am/src/native/devices/video.c	/^size_t video_write(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
video_write	abstract-machine/am/src/native/ioe.c	/^size_t video_write(uintptr_t reg, void *buf, size_t size);$/;"	p	file:	signature:(uintptr_t reg, void *buf, size_t size)
video_write	abstract-machine/am/src/x86/qemu/devices/video.c	/^size_t video_write(uintptr_t reg, void *buf, size_t size) {$/;"	f	signature:(uintptr_t reg, void *buf, size_t size)
video_write	abstract-machine/am/src/x86/qemu/ioe.c	/^DEF_DEVOP(video_write);$/;"	v
vis	abstract-machine/apps/microbench/src/dinic/dinic.cpp	/^  bool vis[MAXN*2 + 2];$/;"	m	struct:Dinic	file:	access:public
visited	abstract-machine/apps/microbench/src/15pz/heap.h	/^    bool visited;$/;"	m	class:Updatable_heap::Step	access:public
vm_area	abstract-machine/am/src/x86/qemu/vme.c	/^struct vm_area {$/;"	s	file:
vm_area::area	abstract-machine/am/src/x86/qemu/vme.c	/^  _Area area;$/;"	m	struct:vm_area	file:	access:public
vm_area::physical	abstract-machine/am/src/x86/qemu/vme.c	/^  int physical;$/;"	m	struct:vm_area	file:	access:public
vme_enable	abstract-machine/am/src/native/vme.c	/^static int vme_enable = 0;$/;"	v	file:
vme_init	abstract-machine/am/src/x86/qemu/vme.c	/^int vme_init(void *(*pgalloc_f)(size_t), void (*pgfree_f)(void *)) {$/;"	f	signature:(void *(*pgalloc_f)(size_t), void (*pgfree_f)(void *))
vpn	abstract-machine/am/src/native/vme.c	/^  uintptr_t vpn;$/;"	m	struct:PageMap	file:	access:public
vsprintf	abstract-machine/libs/klib/include/klib.h	/^int vsprintf(char *str, const char *format, va_list ap);$/;"	p	signature:(char *str, const char *format, va_list ap)
vsprintf	abstract-machine/libs/klib/include/klib.h	24;"	d
vsprintf	abstract-machine/libs/klib/src/stdio.c	/^int vsprintf(char *out, const char *fmt, va_list ap) {$/;"	f	signature:(char *out, const char *fmt, va_list ap)
w	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
w	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect	access:public
w	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
w	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon48	access:public
w	amgame/src/game.c	/^int w, h;$/;"	v
w_char	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t w_char;$/;"	m	struct:VBEInfo	file:	access:public
wait_for_frame	abstract-machine/apps/litenes/src/fce.c	/^void wait_for_frame() {$/;"	f
wait_sec	abstract-machine/am/src/x86/qemu/devices/timer.c	/^static void wait_sec() {$/;"	f	file:
waitdisk	abstract-machine/am/src/x86/qemu/boot/main.c	/^waitdisk(void) {$/;"	f	signature:(void)
was_packed	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect	access:public
was_packed	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect	access:public
weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^    int weight() const;$/;"	p	class:Updatable_heap::Step	access:public	signature:() const
weight	abstract-machine/apps/microbench/src/15pz/heap.h	/^int Updatable_heap<T, M>::Step::weight() const {$/;"	f	class:Updatable_heap::Step	signature:() const
where	abstract-machine/libs/imgui/include/stb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon32	access:public
width	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t width;$/;"	m	struct:VBEInfo	file:	access:public
width	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int width;$/;"	m	struct:stbrp_context	access:public
width	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context	access:public
width	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int width,height;$/;"	m	struct:__anon57	access:public
win_func_ptr	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint32_t win_func_ptr;$/;"	m	struct:VBEInfo	file:	access:public
window	abstract-machine/am/src/native/devices/video.c	/^static SDL_Window *window;$/;"	v	file:
window_a	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t window_a;$/;"	m	struct:VBEInfo	file:	access:public
window_b	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t window_b;$/;"	m	struct:VBEInfo	file:	access:public
window_size	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint16_t window_size;$/;"	m	struct:VBEInfo	file:	access:public
word	abstract-machine/apps/litenes/include/common.h	/^typedef uint16_t word;$/;"	t
x	abstract-machine/apps/litenes/include/ppu.h	/^    int x, scanline;$/;"	m	struct:__anon2	access:public
x	abstract-machine/apps/typing/game.h	/^	int x;$/;"	v
x	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
x	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon39	access:public
x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
x	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
x	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon36	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x, y;$/;"	m	struct:__anon55	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon56	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
x	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon58	access:public
x0	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon35	access:public
x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
x0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
x1	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon35	access:public
x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
x1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
xadvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
xadvance	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
xchecksum	abstract-machine/am/include/x86.h	/^  uint8_t  xchecksum;       \/\/ extended table checksum$/;"	m	struct:MPConf	access:public
xlength	abstract-machine/am/include/x86.h	/^  uint16_t xlength;        \/\/ extended table length$/;"	m	struct:MPConf	access:public
xmap	abstract-machine/apps/litenes/src/fce.c	/^static int xmap[1024];$/;"	v	file:
xmap_init	abstract-machine/apps/litenes/src/fce.c	/^void xmap_init() {$/;"	f
xoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
xoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
xoff2	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon44	access:public
y	abstract-machine/apps/typing/game.h	/^	int y;$/;"	v
y	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
y	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y;$/;"	m	struct:ImVec2	access:public
y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   int x,y;$/;"	m	struct:__anon39	access:public
y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect	access:public
y	abstract-machine/libs/imgui/include/stb_rect_pack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node	access:public
y	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon36	access:public
y	abstract-machine/libs/imgui/include/stb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon47	access:public
y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x, y;$/;"	m	struct:__anon55	access:public
y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x,y;$/;"	m	struct:__anon56	access:public
y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon57	access:public
y	abstract-machine/libs/imgui/include/stb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect	access:public
y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon43	access:public
y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
y0	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge	access:public
y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon43	access:public
y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon42	access:public
y1	abstract-machine/libs/imgui/include/stb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon44	access:public
y_char	abstract-machine/am/src/x86/qemu/devices/video.c	/^  uint8_t y_char;$/;"	m	struct:VBEInfo	file:	access:public
yield	abstract-machine/am/src/x86/qemu/cte.c	/^void yield() {$/;"	f
ymax	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon35	access:public
ymin	abstract-machine/libs/imgui/include/stb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon35	access:public
yoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon42	access:public
yoff	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon44	access:public
yoff2	abstract-machine/libs/imgui/include/stb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon44	access:public
z	abstract-machine/libs/imgui/include/imgui.h	/^    float x, y, z, w;$/;"	m	struct:ImVec4	access:public
zero_bp	abstract-machine/apps/litenes/include/cpu.h	/^    zero_bp       = 1,$/;"	e	enum:__anon4
zero_flag	abstract-machine/apps/litenes/include/cpu.h	/^    zero_flag      = 0x02,$/;"	e	enum:__anon3
zero_i	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    uint8_t zero_i, zero_j;$/;"	m	class:N_puzzle	access:private
zero_j	abstract-machine/apps/microbench/src/15pz/puzzle.h	/^    uint8_t zero_i, zero_j;$/;"	m	class:N_puzzle	access:private
~ExampleAppConsole	abstract-machine/libs/imgui/src/imgui_demo.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole	access:public	signature:()
~ImDrawList	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList	access:public	signature:()
~ImFont	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ~ImFont();$/;"	p	struct:ImFont	access:public	signature:()
~ImFont	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont	signature:()
~ImFontAtlas	abstract-machine/libs/imgui/include/imgui.h	/^    IMGUI_API ~ImFontAtlas();$/;"	p	struct:ImFontAtlas	access:public	signature:()
~ImFontAtlas	abstract-machine/libs/imgui/src/imgui_draw.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas	signature:()
~ImGuiListClipper	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      \/\/ Assert if user forgot to call End() or Step() until false.$/;"	f	struct:ImGuiListClipper	access:public	signature:()
~ImGuiTextFilter	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImGuiTextFilter() {}$/;"	f	struct:ImGuiTextFilter	access:public	signature:()
~ImGuiWindow	abstract-machine/libs/imgui/include/imgui_internal.h	/^    ~ImGuiWindow();$/;"	p	struct:ImGuiWindow	access:public	signature:()
~ImGuiWindow	abstract-machine/libs/imgui/src/imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow	signature:()
~ImVector	abstract-machine/libs/imgui/include/imgui.h	/^    ~ImVector()                 { if (Data) ImGui::MemFree(Data); }$/;"	f	class:ImVector	access:public	signature:()
~Updatable_heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^    ~Updatable_heap();$/;"	p	class:Updatable_heap	access:public	signature:()
~Updatable_heap	abstract-machine/apps/microbench/src/15pz/heap.h	/^Updatable_heap<T, M>::~Updatable_heap() {$/;"	f	class:Updatable_heap	signature:()
~_Init	abstract-machine/am/src/native/platform.cpp	/^  public : ~_Init() {$/;"	f	class:_Init	access:public	signature:()
